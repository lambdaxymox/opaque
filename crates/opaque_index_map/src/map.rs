use crate::equivalent::Equivalent;
use crate::get_disjoint_mut_error::GetDisjointMutError;
use crate::map_inner::{Bucket, OpaqueIndexMapInner, TypedProjIndexMapInner};
use crate::map_inner;

use core::any;
use core::cmp;
use core::fmt;
use core::iter;
use core::mem;
use core::ops;
use alloc_crate::boxed::Box;

#[cfg(feature = "std")]
use std::hash;

#[cfg(not(feature = "std"))]
use core::hash;

#[cfg(feature = "nightly")]
use alloc_crate::alloc;

#[cfg(not(feature = "nightly"))]
use opaque_allocator_api::alloc;

use opaque_alloc::TypedProjAlloc;
use opaque_error::TryReserveError;
use opaque_hash::TypedProjBuildHasher;
use opaque_vec::TypedProjVec;

/// A draining iterator over the entries of a [`TypedProjIndexMap`] or [`OpaqueIndexMap`].
///
/// Draining iterators are created by the [`TypedProjIndexMap::drain`] or [`OpaqueIndexMap::entry`]
/// methods.
///
/// # Examples
///
/// Using a draining iterator on a type-projected index map.
///
/// ```
/// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
/// # use opaque_index_map::TypedProjIndexMap;
/// # use opaque_hash::TypedProjBuildHasher;
/// # use opaque_alloc::TypedProjAlloc;
/// # use opaque_vec::TypedProjVec;
/// # use std::any::TypeId;
/// # use std::hash::RandomState;
/// #
/// # #[cfg(feature = "nightly")]
/// # use std::alloc::Global;
/// #
/// # #[cfg(not(feature = "nightly"))]
/// # use opaque_allocator_api::alloc::Global;
/// #
/// let mut result = TypedProjIndexMap::from([
///     (0_usize, 1_i32),
///     (1_usize, i32::MAX),
///     (2_usize, i32::MAX),
///     (3_usize, i32::MAX),
///     (4_usize, 2_i32),
///     (5_usize, 3_i32)
/// ]);
/// let expected = TypedProjVec::from([
///     (0_usize, 1_i32),
///     (4_usize, 2_i32),
///     (5_usize, 3_i32),
/// ]);
/// result.drain(1..4);
///
/// assert_eq!(result.as_slice(), expected.as_slice());
/// ```
///
/// Using a draining iterator on a type-erased index map.
///
/// ```
/// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
/// # use opaque_index_map::OpaqueIndexMap;
/// # use opaque_hash::TypedProjBuildHasher;
/// # use opaque_alloc::TypedProjAlloc;
/// # use opaque_vec::TypedProjVec;
/// # use std::any::TypeId;
/// # use std::hash::RandomState;
/// #
/// # #[cfg(feature = "nightly")]
/// # use std::alloc::Global;
/// #
/// # #[cfg(not(feature = "nightly"))]
/// # use opaque_allocator_api::alloc::Global;
/// #
/// let mut result = OpaqueIndexMap::from([
///     (0_usize, 1_i32),
///     (1_usize, i32::MAX),
///     (2_usize, i32::MAX),
///     (3_usize, i32::MAX),
///     (4_usize, 2_i32),
///     (5_usize, 3_i32)
/// ]);
/// let expected = TypedProjVec::from([
///     (0_usize, 1_i32),
///     (4_usize, 2_i32),
///     (5_usize, 3_i32),
/// ]);
/// result.drain::<_, usize, i32, RandomState, Global>(1..4);
///
/// assert_eq!(result.as_slice::<usize, i32, RandomState, Global>(), expected.as_slice());
/// ```
pub struct Drain<'a, K, V, A = alloc::Global>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    iter: map_inner::Drain<'a, K, V, A>,
}

impl<'a, K, V, A> Drain<'a, K, V, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    /// Constructs new draining iterator from an inner draining iterator.
    const fn new(iter: map_inner::Drain<'a, K, V, A>) -> Self {
        Self { iter }
    }

    /// Returns a slice of the remaining entries in the draining iterator.
    ///
    /// # Examples
    ///
    /// Getting a slice of remaining elements from a draining iterator of a type-projected index
    /// map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (0_usize, "spam"),
    ///     (1_usize, "eggs"),
    ///     (2_usize, "bacon"),
    ///     (3_usize, "baked beans"),
    ///     (4_usize, "spam"),
    /// ]);
    /// let mut drain = proj_map.drain(..);
    /// assert_eq!(drain.as_slice(), &[(0_usize, "spam"), (1_usize, "eggs"), (2_usize, "bacon"), (3_usize, "baked beans"), (4_usize, "spam")]);
    /// let _ = drain.next().unwrap();
    /// assert_eq!(drain.as_slice(), &[(1_usize, "eggs"), (2_usize, "bacon"), (3_usize, "baked beans"), (4_usize, "spam")]);
    /// let _ = drain.next().unwrap();
    /// assert_eq!(drain.as_slice(), &[(2_usize, "bacon"), (3_usize, "baked beans"), (4_usize, "spam")]);
    /// let _ = drain.next().unwrap();
    /// assert_eq!(drain.as_slice(), &[(3_usize, "baked beans"), (4_usize, "spam")]);
    /// let _ = drain.next().unwrap();
    /// assert_eq!(drain.as_slice(), &[(4_usize, "spam")]);
    /// let _ = drain.next().unwrap();
    /// assert!(drain.as_slice().is_empty());
    /// ```
    ///
    /// Getting a slice of remaining elements from a draining iterator of a type-erased index
    /// map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (0_usize, "spam"),
    ///     (1_usize, "eggs"),
    ///     (2_usize, "bacon"),
    ///     (3_usize, "baked beans"),
    ///     (4_usize, "spam"),
    /// ]);
    /// let mut drain = opaque_map.drain::<_, usize, &str, RandomState, Global>(..);
    /// assert_eq!(drain.as_slice(), &[(0_usize, "spam"), (1_usize, "eggs"), (2_usize, "bacon"), (3_usize, "baked beans"), (4_usize, "spam")]);
    /// let _ = drain.next().unwrap();
    /// assert_eq!(drain.as_slice(), &[(1_usize, "eggs"), (2_usize, "bacon"), (3_usize, "baked beans"), (4_usize, "spam")]);
    /// let _ = drain.next().unwrap();
    /// assert_eq!(drain.as_slice(), &[(2_usize, "bacon"), (3_usize, "baked beans"), (4_usize, "spam")]);
    /// let _ = drain.next().unwrap();
    /// assert_eq!(drain.as_slice(), &[(3_usize, "baked beans"), (4_usize, "spam")]);
    /// let _ = drain.next().unwrap();
    /// assert_eq!(drain.as_slice(), &[(4_usize, "spam")]);
    /// let _ = drain.next().unwrap();
    /// assert!(drain.as_slice().is_empty());
    /// ```
    pub fn as_slice(&self) -> &Slice<K, V> {
        Slice::from_slice(self.iter.as_slice())
    }
}

impl<K, V, A> Iterator for Drain<'_, K, V, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    type Item = (K, V);

    fn next(&mut self) -> Option<Self::Item> {
        self.iter.next()
    }
}

impl<K, V, A> DoubleEndedIterator for Drain<'_, K, V, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    fn next_back(&mut self) -> Option<Self::Item> {
        self.iter.next_back()
    }

    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
        self.iter.nth_back(n)
    }
}

impl<K, V, A> ExactSizeIterator for Drain<'_, K, V, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    fn len(&self) -> usize {
        self.iter.len()
    }
}

impl<K, V, A> iter::FusedIterator for Drain<'_, K, V, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
}

impl<K, V, A> fmt::Debug for Drain<'_, K, V, A>
where
    K: any::Any + fmt::Debug,
    V: any::Any + fmt::Debug,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Debug::fmt(&self.iter, formatter)
    }
}

/// An iterator over the keys of the entries of the index map.
///
/// This iterator returns the keys in the storage order of the entries in the index map. Key
/// iterators are created by the [`TypedProjIndexMap::keys`] and [`OpaqueIndexMap::keys`] methods.
///
/// # Examples
///
/// Using a key iterator on a type-projected index map.
///
/// ```
/// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
/// # use opaque_index_map::TypedProjIndexMap;
/// # use opaque_hash::TypedProjBuildHasher;
/// # use opaque_alloc::TypedProjAlloc;
/// # use opaque_vec::TypedProjVec;
/// # use std::any::TypeId;
/// # use std::hash::RandomState;
/// #
/// # #[cfg(feature = "nightly")]
/// # use std::alloc::Global;
/// #
/// # #[cfg(not(feature = "nightly"))]
/// # use opaque_allocator_api::alloc::Global;
/// #
/// let proj_map = TypedProjIndexMap::from([
///     ("foo",  1_i32),
///     ("bar",  2_i32),
///     ("baz",  3_i32),
///     ("quux", 4_i32),
/// ]);
/// let expected = TypedProjVec::from(["foo", "bar", "baz", "quux"]);
/// let result: TypedProjVec<&str> = proj_map
///     .keys()
///     .cloned()
///     .collect();
///
/// assert_eq!(result, expected);
/// ```
///
/// Using a key iterator on a type-erased index map.
///
/// ```
/// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
/// # use opaque_index_map::OpaqueIndexMap;
/// # use opaque_hash::TypedProjBuildHasher;
/// # use opaque_alloc::TypedProjAlloc;
/// # use opaque_vec::TypedProjVec;
/// # use std::any::TypeId;
/// # use std::hash::RandomState;
/// #
/// # #[cfg(feature = "nightly")]
/// # use std::alloc::Global;
/// #
/// # #[cfg(not(feature = "nightly"))]
/// # use opaque_allocator_api::alloc::Global;
/// #
/// let opaque_map = OpaqueIndexMap::from([
///     ("foo",  1_i32),
///     ("bar",  2_i32),
///     ("baz",  3_i32),
///     ("quux", 4_i32),
/// ]);
/// let expected = TypedProjVec::from(["foo", "bar", "baz", "quux"]);
/// let result: TypedProjVec<&str> = opaque_map
///     .keys::<&str, i32, RandomState, Global>()
///     .cloned()
///     .collect();
///
/// assert_eq!(result, expected);
/// ```
pub struct Keys<'a, K, V> {
    iter: map_inner::Keys<'a, K, V>,
}

impl<'a, K, V> Keys<'a, K, V> {
    /// Constructs a new key iterator.
    fn new(iter: map_inner::Keys<'a, K, V>) -> Self {
        Self { iter, }
    }
}

impl<'a, K, V> Clone for Keys<'a, K, V> {
    fn clone(&self) -> Self {
        Keys { iter: self.iter.clone() }
    }
}

impl<'a, K, V> Iterator for Keys<'a, K, V> {
    type Item = &'a K;

    fn next(&mut self) -> Option<Self::Item> {
        self.iter.next()
    }
}

impl<'a, K, V> DoubleEndedIterator for Keys<'a, K, V> {
    fn next_back(&mut self) -> Option<Self::Item> {
        self.iter.next_back()
    }

    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
        self.iter.nth_back(n)
    }
}

impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {
    fn len(&self) -> usize {
        self.iter.len()
    }
}

impl<'a, K, V> iter::FusedIterator for Keys<'a, K, V> {}

impl<'a, K, V> fmt::Debug for Keys<'a, K, V>
where
    K: fmt::Debug,
{
    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Debug::fmt(&self.iter, formatter)
    }
}

impl<'a, K, V> ops::Index<usize> for Keys<'a, K, V> {
    type Output = K;

    fn index(&self, index: usize) -> &Self::Output {
        self.iter.index(index)
    }
}

/// A moving iterator over the keys of the entries of the index map.
///
/// This iterator returns the keys in the storage order of the entries in the index map. Moving key
/// iterators are created by the [`TypedProjIndexMap::into_keys`] and [`OpaqueIndexMap::into_keys`]
/// methods.
///
/// # Examples
///
/// Using a moving key iterator on a type-projected index map.
///
/// ```
/// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
/// # use opaque_index_map::TypedProjIndexMap;
/// # use opaque_hash::TypedProjBuildHasher;
/// # use opaque_alloc::TypedProjAlloc;
/// # use opaque_vec::TypedProjVec;
/// # use std::any::TypeId;
/// # use std::hash::RandomState;
/// #
/// # #[cfg(feature = "nightly")]
/// # use std::alloc::Global;
/// #
/// # #[cfg(not(feature = "nightly"))]
/// # use opaque_allocator_api::alloc::Global;
/// #
/// let proj_map = TypedProjIndexMap::from([
///     ("foo",  1_i32),
///     ("bar",  2_i32),
///     ("baz",  3_i32),
///     ("quux", 4_i32),
/// ]);
/// let expected = TypedProjVec::from(["foo", "bar", "baz", "quux"]);
/// let result: TypedProjVec<&str> = proj_map
///     .into_keys()
///     .collect();
///
/// assert_eq!(result, expected);
/// ```
///
/// Using a moving key iterator on a type-erased index map.
///
/// ```
/// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
/// # use opaque_index_map::OpaqueIndexMap;
/// # use opaque_hash::TypedProjBuildHasher;
/// # use opaque_alloc::TypedProjAlloc;
/// # use opaque_vec::TypedProjVec;
/// # use std::any::TypeId;
/// # use std::hash::RandomState;
/// #
/// # #[cfg(feature = "nightly")]
/// # use std::alloc::Global;
/// #
/// # #[cfg(not(feature = "nightly"))]
/// # use opaque_allocator_api::alloc::Global;
/// #
/// let opaque_map = OpaqueIndexMap::from([
///     ("foo",  1_i32),
///     ("bar",  2_i32),
///     ("baz",  3_i32),
///     ("quux", 4_i32),
/// ]);
/// let expected = TypedProjVec::from(["foo", "bar", "baz", "quux"]);
/// let result: TypedProjVec<&str> = opaque_map
///     .into_keys::<&str, i32, RandomState, Global>()
///     .collect();
///
/// assert_eq!(result, expected);
/// ```
pub struct IntoKeys<K, V, A = alloc::Global>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    iter: map_inner::IntoKeys<K, V, A>,
}

impl<K, V, A> IntoKeys<K, V, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    /// Constructs a new moving key iterator.
    fn new(iter: map_inner::IntoKeys<K, V, A>) -> Self {
        Self { iter, }
    }
}

impl<K, V, A> Iterator for IntoKeys<K, V, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    type Item = K;

    fn next(&mut self) -> Option<Self::Item> {
        self.iter.next()
    }
}

impl<K, V, A> DoubleEndedIterator for IntoKeys<K, V, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    fn next_back(&mut self) -> Option<Self::Item> {
        self.iter.next_back()
    }

    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
        self.iter.nth_back(n)
    }
}

impl<K, V, A> ExactSizeIterator for IntoKeys<K, V, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    fn len(&self) -> usize {
        self.iter.len()
    }
}

impl<K, V, A> iter::FusedIterator for IntoKeys<K, V, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
}

impl<K, V, A> fmt::Debug for IntoKeys<K, V, A>
where
    K: any::Any + fmt::Debug,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Debug::fmt(&self.iter, formatter)
    }
}

impl<K, V, A> Default for IntoKeys<K, V, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync + Default,
{
    fn default() -> Self {
        Self {
            iter: Default::default(),
        }
    }
}

/// An iterator over the values of the entries of the index map.
///
/// This iterator returns the values in the storage order of the entries in the index map. Value
/// iterators are created by the [`TypedProjIndexMap::values`] and [`OpaqueIndexMap::values`]
/// methods.
///
/// # Examples
///
/// Using a value iterator on a type-projected index map.
///
/// ```
/// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
/// # use opaque_index_map::TypedProjIndexMap;
/// # use opaque_hash::TypedProjBuildHasher;
/// # use opaque_alloc::TypedProjAlloc;
/// # use opaque_vec::TypedProjVec;
/// # use std::any::TypeId;
/// # use std::hash::RandomState;
/// #
/// # #[cfg(feature = "nightly")]
/// # use std::alloc::Global;
/// #
/// # #[cfg(not(feature = "nightly"))]
/// # use opaque_allocator_api::alloc::Global;
/// #
/// let proj_map = TypedProjIndexMap::from([
///     ("foo",  1_i32),
///     ("bar",  2_i32),
///     ("baz",  3_i32),
///     ("quux", 4_i32),
/// ]);
/// let expected = TypedProjVec::from([1_i32, 2_i32, 3_i32, 4_i32]);
/// let result: TypedProjVec<i32> = proj_map
///     .values()
///     .cloned()
///     .collect();
///
/// assert_eq!(result, expected);
/// ```
///
/// Using a value iterator on a type-erased index map.
///
/// ```
/// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
/// # use opaque_index_map::OpaqueIndexMap;
/// # use opaque_hash::TypedProjBuildHasher;
/// # use opaque_alloc::TypedProjAlloc;
/// # use opaque_vec::TypedProjVec;
/// # use std::any::TypeId;
/// # use std::hash::RandomState;
/// #
/// # #[cfg(feature = "nightly")]
/// # use std::alloc::Global;
/// #
/// # #[cfg(not(feature = "nightly"))]
/// # use opaque_allocator_api::alloc::Global;
/// #
/// let opaque_map = OpaqueIndexMap::from([
///     ("foo",  1_i32),
///     ("bar",  2_i32),
///     ("baz",  3_i32),
///     ("quux", 4_i32),
/// ]);
/// let expected = TypedProjVec::from([1_i32, 2_i32, 3_i32, 4_i32]);
/// let result: TypedProjVec<i32> = opaque_map
///     .values::<&str, i32, RandomState, Global>()
///     .cloned()
///     .collect();
///
/// assert_eq!(result, expected);
/// ```
pub struct Values<'a, K, V> {
    iter: map_inner::Values<'a, K, V>,
}

impl<'a, K, V> Values<'a, K, V> {
    /// Construct a new value iterator.
    #[inline]
    const fn new(iter: map_inner::Values<'a, K, V>) -> Self {
        Self { iter, }
    }
}

impl<'a, K, V> Iterator for Values<'a, K, V> {
    type Item = &'a V;

    fn next(&mut self) -> Option<Self::Item> {
        self.iter.next()
    }
}

impl<'a, K, V> DoubleEndedIterator for Values<'a, K, V> {
    fn next_back(&mut self) -> Option<Self::Item> {
        self.iter.next_back()
    }

    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
        self.iter.nth_back(n)
    }
}

impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {
    fn len(&self) -> usize {
        self.iter.len()
    }
}

impl<'a, K, V> iter::FusedIterator for Values<'a, K, V> {}

impl<K, V> Clone for Values<'_, K, V> {
    fn clone(&self) -> Self {
        Values { iter: self.iter.clone() }
    }
}

impl<K, V> fmt::Debug for Values<'_, K, V>
where
    V: fmt::Debug,
{
    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
        formatter.debug_list().entries(self.clone()).finish()
    }
}

impl<K, V> Default for Values<'_, K, V> {
    fn default() -> Self {
        Self { iter: Default::default() }
    }
}

/// A mutable iterator over the values of the entries of the index map.
///
/// This iterator returns the values in the storage order of the entries in the index map. Mutable
/// values iterators are created by the [`TypedProjIndexMap::values_mut`] and
/// [`OpaqueIndexMap::values_mut`] methods.
///
/// # Examples
///
/// Using a value iterator on a type-projected index map.
///
/// ```
/// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
/// # use opaque_index_map::TypedProjIndexMap;
/// # use opaque_hash::TypedProjBuildHasher;
/// # use opaque_alloc::TypedProjAlloc;
/// # use opaque_vec::TypedProjVec;
/// # use std::any::TypeId;
/// # use std::hash::RandomState;
/// #
/// # #[cfg(feature = "nightly")]
/// # use std::alloc::Global;
/// #
/// # #[cfg(not(feature = "nightly"))]
/// # use opaque_allocator_api::alloc::Global;
/// #
/// let mut proj_map = TypedProjIndexMap::from([
///     ("foo",  1_i32),
///     ("bar",  2_i32),
///     ("baz",  3_i32),
///     ("quux", 4_i32),
/// ]);
/// let expected = TypedProjVec::from([1_i32, 2_i32, 3_i32, 4_i32]);
/// let result: TypedProjVec<i32> = proj_map
///     .values_mut()
///     .map(|v| v.clone())
///     .collect();
///
/// assert_eq!(result, expected);
///
/// for value in proj_map.values_mut() {
///     *value *= 2_i32;
/// }
///
/// let expected_mutated = TypedProjVec::from([2_i32, 4_i32, 6_i32, 8_i32]);
/// let result_mutated: TypedProjVec<i32> = proj_map
///     .values_mut()
///     .map(|v| v.clone())
///     .collect();
///
/// assert_eq!(result_mutated, expected_mutated);
/// ```
///
/// Using a value iterator on a type-erased index map.
///
/// ```
/// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
/// # use opaque_index_map::OpaqueIndexMap;
/// # use opaque_hash::TypedProjBuildHasher;
/// # use opaque_alloc::TypedProjAlloc;
/// # use opaque_vec::TypedProjVec;
/// # use std::any::TypeId;
/// # use std::hash::RandomState;
/// #
/// # #[cfg(feature = "nightly")]
/// # use std::alloc::Global;
/// #
/// # #[cfg(not(feature = "nightly"))]
/// # use opaque_allocator_api::alloc::Global;
/// #
/// let mut opaque_map = OpaqueIndexMap::from([
///     ("foo",  1_i32),
///     ("bar",  2_i32),
///     ("baz",  3_i32),
///     ("quux", 4_i32),
/// ]);
/// let expected = TypedProjVec::from([1_i32, 2_i32, 3_i32, 4_i32]);
/// let result: TypedProjVec<i32> = opaque_map
///     .values_mut::<&str, i32, RandomState, Global>()
///     .map(|v| v.clone())
///     .collect();
///
/// assert_eq!(result, expected);
///
/// for value in opaque_map.values_mut::<&str, i32, RandomState, Global>() {
///     *value *= 2_i32;
/// }
///
/// let expected_mutated = TypedProjVec::from([2_i32, 4_i32, 6_i32, 8_i32]);
/// let result_mutated: TypedProjVec<i32> = opaque_map
///     .values_mut::<&str, i32, RandomState, Global>()
///     .map(|v| v.clone())
///     .collect();
///
/// assert_eq!(result_mutated, expected_mutated);
/// ```
pub struct ValuesMut<'a, K, V> {
    iter: map_inner::ValuesMut<'a, K, V>,
}

impl<'a, K, V> ValuesMut<'a, K, V> {
    /// Constructs a new mutable value iterator.
    #[inline]
    const fn new(iter: map_inner::ValuesMut<'a, K, V>) -> Self {
        Self { iter, }
    }
}

impl<'a, K, V> Iterator for ValuesMut<'a, K, V> {
    type Item = &'a mut V;

    fn next(&mut self) -> Option<Self::Item> {
        self.iter.next()
    }
}

impl<K, V> DoubleEndedIterator for ValuesMut<'_, K, V> {
    fn next_back(&mut self) -> Option<Self::Item> {
        self.iter.next_back()
    }

    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
        self.iter.nth_back(n)
    }
}

impl<'a, K, V> ExactSizeIterator for ValuesMut<'a, K, V> {
    fn len(&self) -> usize {
        self.iter.len()
    }
}

impl<'a, K, V> iter::FusedIterator for ValuesMut<'a, K, V> {}

impl<K, V> fmt::Debug for ValuesMut<'_, K, V>
where
    V: fmt::Debug,
{
    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Debug::fmt(&self.iter, formatter)
    }
}

impl<K, V> Default for ValuesMut<'_, K, V> {
    fn default() -> Self {
        Self { iter: Default::default() }
    }
}

/// A moving iterator over the values of the entries of the index map.
///
/// This iterator returns the values in the storage order of the entries in the index map. Moving
/// value iterators are created by the [`TypedProjIndexMap::into_values`] and
/// [`OpaqueIndexMap::into_values`] methods.
///
/// # Examples
///
/// Using a moving value iterator on a type-projected index map.
///
/// ```
/// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
/// # use opaque_index_map::TypedProjIndexMap;
/// # use opaque_hash::TypedProjBuildHasher;
/// # use opaque_alloc::TypedProjAlloc;
/// # use opaque_vec::TypedProjVec;
/// # use std::any::TypeId;
/// # use std::hash::RandomState;
/// #
/// # #[cfg(feature = "nightly")]
/// # use std::alloc::Global;
/// #
/// # #[cfg(not(feature = "nightly"))]
/// # use opaque_allocator_api::alloc::Global;
/// #
/// let proj_map = TypedProjIndexMap::from([
///     ("foo",  1_i32),
///     ("bar",  2_i32),
///     ("baz",  3_i32),
///     ("quux", 4_i32),
/// ]);
/// let expected = TypedProjVec::from([1_i32, 2_i32, 3_i32, 4_i32]);
/// let result: TypedProjVec<i32> = proj_map
///     .into_values()
///     .collect();
///
/// assert_eq!(result, expected);
/// ```
///
/// Using a moving value iterator on a type-erased index map.
///
/// ```
/// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
/// # use opaque_index_map::OpaqueIndexMap;
/// # use opaque_hash::TypedProjBuildHasher;
/// # use opaque_alloc::TypedProjAlloc;
/// # use opaque_vec::TypedProjVec;
/// # use std::any::TypeId;
/// # use std::hash::RandomState;
/// #
/// # #[cfg(feature = "nightly")]
/// # use std::alloc::Global;
/// #
/// # #[cfg(not(feature = "nightly"))]
/// # use opaque_allocator_api::alloc::Global;
/// #
/// let opaque_map = OpaqueIndexMap::from([
///     ("foo",  1_i32),
///     ("bar",  2_i32),
///     ("baz",  3_i32),
///     ("quux", 4_i32),
/// ]);
/// let expected = TypedProjVec::from([1_i32, 2_i32, 3_i32, 4_i32]);
/// let result: TypedProjVec<i32> = opaque_map
///     .into_values::<&str, i32, RandomState, Global>()
///     .collect();
///
/// assert_eq!(result, expected);
/// ```
pub struct IntoValues<K, V, A = alloc::Global>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    iter: map_inner::IntoValues<K, V, A>,
}

impl<K, V, A> IntoValues<K, V, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    /// Constructs a new moving value iterator.
    #[inline]
    const fn new(iter: map_inner::IntoValues<K, V, A>) -> Self {
        Self { iter, }
    }
}

impl<K, V, A> Iterator for IntoValues<K, V, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    type Item = V;

    fn next(&mut self) -> Option<Self::Item> {
        self.iter.next()
    }
}

impl<K, V, A> DoubleEndedIterator for IntoValues<K, V, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    fn next_back(&mut self) -> Option<Self::Item> {
        self.iter.next_back()
    }

    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
        self.iter.nth_back(n)
    }
}

impl<K, V, A> ExactSizeIterator for IntoValues<K, V, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    fn len(&self) -> usize {
        self.iter.len()
    }
}

impl<K, V, A> iter::FusedIterator for IntoValues<K, V, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
}

impl<K, V, A> fmt::Debug for IntoValues<K, V, A>
where
    K: any::Any,
    V: any::Any + fmt::Debug,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Debug::fmt(&self.iter, formatter)
    }
}

impl<K, V, A> Default for IntoValues<K, V, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync + Default,
{
    fn default() -> Self {
        Self {
            iter: Default::default(),
        }
    }
}

/// A dynamically-sized slice of entries in an index map.
///
/// This supports indexed operations much like a `[(K, V)]` slice, but there are no hashed
/// operations on the index map keys.
///
/// Unlike [`TypedProjIndexMap`] and [`OpaqueIndexMap`], `Slice` **does** consider the order for
/// [`PartialEq`] and [`Eq`], and it also implements [`PartialOrd`], [`Ord`], and [`Hash`].
///
/// Slices are created by the [`TypedProjIndexMap::as_slice`], [`TypedProjIndexMap::as_mut_slice`],
/// [`OpaqueIndexMap::as_slice`], and [`OpaqueIndexMap::as_mut_slice`] methods.
///
/// # Examples
///
/// ```
/// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
/// # use opaque_index_map::TypedProjIndexMap;
/// # use opaque_hash::TypedProjBuildHasher;
/// # use opaque_alloc::TypedProjAlloc;
/// # use opaque_vec::TypedProjVec;
/// # use std::any::TypeId;
/// # use std::cmp::Ordering;
/// # use std::hash::RandomState;
/// #
/// # #[cfg(feature = "nightly")]
/// # use std::alloc::Global;
/// #
/// # #[cfg(not(feature = "nightly"))]
/// # use opaque_allocator_api::alloc::Global;
/// #
/// let mut proj_map = TypedProjIndexMap::from([
///     ("Amnesia", "City Ruins"),
///     ("The Wandering Couple", "Desert Zone"),
///     ("Find a Present", "Amusement Park"),
///     ("Data Analysis Freak", "Factory"),
///     ("Supply Recon", "Forest Zone"),
/// ]);
/// let slice = proj_map.as_slice();
///
/// assert_eq!(slice.get_index(0), Some((&"Amnesia", &"City Ruins")));
/// assert_eq!(slice.get_index(1), Some((&"The Wandering Couple", &"Desert Zone")));
/// assert_eq!(slice.get_index(4), Some((&"Supply Recon", &"Forest Zone")));
///
/// let mid_slice = slice.get_range(1..3).unwrap();
/// assert_eq!(mid_slice.get_index(0), Some((&"The Wandering Couple", &"Desert Zone")));
/// assert_eq!(mid_slice.get_index(1), Some((&"Find a Present", &"Amusement Park")));
///
/// // Out of bounds access is safe.
/// assert_eq!(slice.get_index(5), None);
/// ```
#[repr(transparent)]
pub struct Slice<K, V> {
    entries: map_inner::Slice<K, V>,
}

impl<K, V> Slice<K, V> {
    /// Constructs a new index map slice from an inner index map slice.
    #[inline]
    pub(crate) const fn from_slice(entries: &map_inner::Slice<K, V>) -> &Self {
        unsafe { &*(entries as *const map_inner::Slice<K, V> as *const Self) }
    }

    /// Constructs a new mutable index map slice from a mutable inner index map slice.
    #[inline]
    pub(crate) const fn from_slice_mut(entries: &mut map_inner::Slice<K, V>) -> &mut Self {
        unsafe { &mut *(entries as *mut map_inner::Slice<K, V> as *mut Self) }
    }
}

#[cfg(feature = "nightly")]
impl<K, V> Slice<K, V> {
    /// Constructs a new boxed slice from an inner boxed slice.
    fn from_boxed_slice<A>(entries: Box<map_inner::Slice<K, V>, TypedProjAlloc<A>>) -> Box<Self, TypedProjAlloc<A>>
    where
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        unsafe {
            let (ptr, alloc) = Box::into_raw_with_allocator(entries);

            Box::from_raw_in(ptr as *mut Self, alloc)
        }
    }

    /// Converts a boxed slice into an inner boxed slice.
    fn into_boxed_slice<A>(self: Box<Self, TypedProjAlloc<A>>) -> Box<map_inner::Slice<K, V>, TypedProjAlloc<A>>
    where
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        unsafe {
            let (ptr, alloc) = Box::into_raw_with_allocator(self);

            Box::from_raw_in(ptr as *mut map_inner::Slice<K, V>, alloc)
        }
    }

    /// Constructs a new boxed slice from a type-projected vector.
    fn from_entries_in<A>(vec: TypedProjVec<Bucket<K, V>, A>) -> Box<Self, TypedProjAlloc<A>>
    where
        K: any::Any,
        V: any::Any,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let boxed_slice_inner = map_inner::Slice::from_entries_in(vec);
        let boxed_slice = unsafe {
            let (_ptr, alloc) = Box::into_raw_with_allocator(boxed_slice_inner);
            let ptr = _ptr as *mut Self;
            Box::from_raw_in(ptr, alloc)
        };

        boxed_slice
    }
}

impl<K, V> Slice<K, V> {
    /// Constructs a new empty index map slice.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::map::Slice;
    /// #
    /// let slice: &Slice<usize, isize> = Slice::new();
    ///
    /// assert!(slice.is_empty());
    /// ```
    pub const fn new<'a>() -> &'a Self {
        Self::from_slice(map_inner::Slice::new())
    }

    /// Constructs a new empty index map slice.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::map::Slice;
    /// #
    /// let mut slice: &mut Slice<usize, isize> = Slice::new_mut();
    ///
    /// assert!(slice.is_empty());
    /// ```
    pub fn new_mut<'a>() -> &'a mut Self {
        Self::from_slice_mut(map_inner::Slice::new_mut())
    }

    /// Returns the length of the index map slice.
    ///
    /// The **length** of an index map slice is the number of entries in the slice.
    ///
    /// # Examples
    ///
    /// Getting a slice of the entries of a type-projected index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map = TypedProjIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    ///     (4_usize, 5_i32),
    ///     (5_usize, 6_i32),
    /// ]);
    /// let slice = proj_map.as_slice();
    ///
    /// assert_eq!(slice.len(), 6);
    /// ```
    ///
    /// Getting a slice of the entries of a type-erased index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    ///     (4_usize, 5_i32),
    ///     (5_usize, 6_i32),
    /// ]);
    /// let slice = opaque_map.as_slice::<usize, i32, RandomState, Global>();
    ///
    /// assert_eq!(slice.len(), 6);
    /// ```
    #[inline]
    pub const fn len(&self) -> usize {
        self.entries.len()
    }

    /// Determines whether an index map slice is empty.
    ///
    /// An index map slice is **empty** if it has no entries, i.e. its length is zero.
    ///
    /// # Examples
    ///
    /// Getting a slice of the entries of a type-projected index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map = TypedProjIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    ///     (4_usize, 5_i32),
    ///     (5_usize, 6_i32),
    /// ]);
    /// let slice = proj_map.as_slice();
    ///
    /// assert!(!slice.is_empty());
    /// assert!(slice[1..1].is_empty());
    /// ```
    ///
    /// Getting a slice of the entries of a type-erased index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    ///     (4_usize, 5_i32),
    ///     (5_usize, 6_i32),
    /// ]);
    /// let slice = opaque_map.as_slice::<usize, i32, RandomState, Global>();
    ///
    /// assert!(!slice.is_empty());
    /// assert!(slice[1..1].is_empty());
    /// ```
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.entries.is_empty()
    }

    /// Returns a (key reference, value reference) pair corresponding to the key-value pair stored
    /// at a given index in the index map slice, if it exists.
    ///
    /// If `index < self.len()`, this method returns `Some((&key, &value))`, where `key` is the key
    /// of the entry at index `index` in the map, and `value` is the value of the entry at index
    /// `index`. If `index >= self.len()`, this method returns `None`.
    ///
    /// # Examples
    ///
    /// Getting entries from a type-projected index map slice by index.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map = TypedProjIndexMap::from([
    ///     (1_usize, 10_i32),
    ///     (2_usize, 40_i32),
    ///     (3_usize, 30_i32),
    ///
    /// ]);
    /// let slice = proj_map.as_slice();
    ///
    /// assert_eq!(slice.get_index(0), Some((&1_usize, &10_i32)));
    /// assert_eq!(slice.get_index(1), Some((&2_usize, &40_i32)));
    /// assert_eq!(slice.get_index(2), Some((&3_usize, &30_i32)));
    /// assert_eq!(slice.get_index(3), None);
    /// ```
    ///
    /// Getting entries from a type-erased index map slice by index.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 10_i32),
    ///     (2_usize, 40_i32),
    ///     (3_usize, 30_i32),
    ///
    /// ]);
    /// let slice = opaque_map.as_slice::<usize, i32, RandomState, Global>();
    ///
    /// assert_eq!(slice.get_index(0), Some((&1_usize, &10_i32)));
    /// assert_eq!(slice.get_index(1), Some((&2_usize, &40_i32)));
    /// assert_eq!(slice.get_index(2), Some((&3_usize, &30_i32)));
    /// assert_eq!(slice.get_index(3), None);
    /// ```
    pub fn get_index(&self, index: usize) -> Option<(&K, &V)> {
        self.entries.get_index(index)
    }

    /// Returns a (key reference, mutable value reference) pair corresponding to the key-value pair
    /// stored at a given index in the index map slice, if it exists.
    ///
    /// If `index < self.len()`, this method returns `Some((&key, &value))`, where `key` is the key
    /// of the entry at index `index` in the map, and `value` is the value of the entry at index
    /// `index`. If `index >= self.len()`, this method returns `None`.
    ///
    /// # Examples
    ///
    /// Getting entries from a type-projected index map slice by index.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (1_usize, 10_i32),
    ///     (2_usize, 40_i32),
    ///     (3_usize, 30_i32),
    ///
    /// ]);
    /// let slice = proj_map.as_mut_slice();
    ///
    /// assert_eq!(slice.get_index_mut(0), Some((&1_usize, &mut 10_i32)));
    /// assert_eq!(slice.get_index_mut(1), Some((&2_usize, &mut 40_i32)));
    /// assert_eq!(slice.get_index_mut(2), Some((&3_usize, &mut 30_i32)));
    /// assert_eq!(slice.get_index_mut(3), None);
    /// ```
    ///
    /// Getting entries from a type-erased index map slice by index.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 10_i32),
    ///     (2_usize, 40_i32),
    ///     (3_usize, 30_i32),
    ///
    /// ]);
    /// let slice = opaque_map.as_mut_slice::<usize, i32, RandomState, Global>();
    ///
    /// assert_eq!(slice.get_index_mut(0), Some((&1_usize, &mut 10_i32)));
    /// assert_eq!(slice.get_index_mut(1), Some((&2_usize, &mut 40_i32)));
    /// assert_eq!(slice.get_index_mut(2), Some((&3_usize, &mut 30_i32)));
    /// assert_eq!(slice.get_index_mut(3), None);
    /// ```
    pub fn get_index_mut(&mut self, index: usize) -> Option<(&K, &mut V)> {
        self.entries.get_index_mut(index)
    }

    /// Returns a subslice of entries in the index map slice from the given storage range in the
    /// map.
    ///
    /// If the range `range` is in bounds, this method returns `Some(&slice)`, where `slice` is the
    /// slice of entries from the index map slice in the storage range `range`. if the range `range`
    /// is out of bounds, this method returns `None`.
    ///
    /// # Examples
    ///
    /// Subslicing a slice from a type-projected index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map = TypedProjIndexMap::from([
    ///     (1_usize, 10_i32),
    ///     (2_usize, 40_i32),
    ///     (3_usize, 30_i32),
    ///     (4_usize, 60_i32),
    /// ]);
    ///
    /// let maybe_slice = proj_map.get_range(1..);
    ///
    /// assert!(maybe_slice.is_some());
    ///
    /// let slice = maybe_slice.unwrap();
    ///
    /// assert_eq!(slice.len(), 3);
    /// assert_eq!(slice[0], 40_i32);
    /// assert_eq!(slice[1], 30_i32);
    /// assert_eq!(slice[2], 60_i32);
    ///
    /// let maybe_subslice = slice.get_range(1..);
    ///
    /// assert!(maybe_subslice.is_some());
    ///
    /// let subslice = maybe_subslice.unwrap();
    ///
    /// assert_eq!(subslice.len(), 2);
    /// assert_eq!(subslice[0], 30_i32);
    /// assert_eq!(subslice[1], 60_i32);
    /// ```
    ///
    /// Subslicing a slice from a type-erased index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 10_i32),
    ///     (2_usize, 40_i32),
    ///     (3_usize, 30_i32),
    ///     (4_usize, 60_i32),
    /// ]);
    ///
    /// let maybe_slice = opaque_map.get_range::<_, usize, i32, RandomState, Global>(1..);
    ///
    /// assert!(maybe_slice.is_some());
    ///
    /// let slice = maybe_slice.unwrap();
    ///
    /// assert_eq!(slice.len(), 3);
    /// assert_eq!(slice[0], 40_i32);
    /// assert_eq!(slice[1], 30_i32);
    /// assert_eq!(slice[2], 60_i32);
    ///
    /// let maybe_subslice = slice.get_range(1..);
    ///
    /// assert!(maybe_subslice.is_some());
    ///
    /// let subslice = maybe_subslice.unwrap();
    ///
    /// assert_eq!(subslice.len(), 2);
    /// assert_eq!(subslice[0], 30_i32);
    /// assert_eq!(subslice[1], 60_i32);
    /// ```
    pub fn get_range<R>(&self, range: R) -> Option<&Self>
    where
        R: ops::RangeBounds<usize>,
    {
        self.entries.get_range(range).map(Slice::from_slice)
    }

    /// Returns a mutable subslice of entries in the index map slice from the given storage range
    /// in the map.
    ///
    /// If the range `range` is in bounds, this method returns `Some(&mut slice)`, where `slice` is
    /// the slice of entries from the index map slice in the storage range `range`. if the range
    /// `range` is out of bounds, this method returns `None`.
    ///
    /// # Examples
    ///
    /// Subslicing a slice from a type-projected index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (1_usize, 10_i32),
    ///     (2_usize, 40_i32),
    ///     (3_usize, 30_i32),
    ///     (4_usize, 60_i32),
    /// ]);
    ///
    /// let maybe_slice = proj_map.get_range_mut(1..);
    ///
    /// assert!(maybe_slice.is_some());
    ///
    /// let slice = maybe_slice.unwrap();
    ///
    /// assert_eq!(slice.len(), 3);
    /// assert_eq!(slice[0], 40_i32);
    /// assert_eq!(slice[1], 30_i32);
    /// assert_eq!(slice[2], 60_i32);
    ///
    /// let maybe_subslice = slice.get_range_mut(1..);
    ///
    /// assert!(maybe_subslice.is_some());
    ///
    /// let subslice = maybe_subslice.unwrap();
    ///
    /// assert_eq!(subslice.len(), 2);
    /// assert_eq!(subslice[0], 30_i32);
    /// assert_eq!(subslice[1], 60_i32);
    /// ```
    ///
    /// Subslicing a slice from a type-erased index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 10_i32),
    ///     (2_usize, 40_i32),
    ///     (3_usize, 30_i32),
    ///     (4_usize, 60_i32),
    /// ]);
    ///
    /// let maybe_slice = opaque_map.get_range_mut::<_, usize, i32, RandomState, Global>(1..);
    ///
    /// assert!(maybe_slice.is_some());
    ///
    /// let slice = maybe_slice.unwrap();
    ///
    /// assert_eq!(slice.len(), 3);
    /// assert_eq!(slice[0], 40_i32);
    /// assert_eq!(slice[1], 30_i32);
    /// assert_eq!(slice[2], 60_i32);
    ///
    /// let maybe_subslice = slice.get_range_mut(1..);
    ///
    /// assert!(maybe_subslice.is_some());
    ///
    /// let subslice = maybe_subslice.unwrap();
    ///
    /// assert_eq!(subslice.len(), 2);
    /// assert_eq!(subslice[0], 30_i32);
    /// assert_eq!(subslice[1], 60_i32);
    /// ```
    pub fn get_range_mut<R>(&mut self, range: R) -> Option<&mut Self>
    where
        R: ops::RangeBounds<usize>,
    {
        self.entries.get_range_mut(range).map(Slice::from_slice_mut)
    }

    /// Returns a reference to the first entry in the index map slice as a
    /// (key reference, value reference) pair, if it exists.
    ///
    /// If the index map slice is nonempty, this method returns `Some((&key, &value))` where `key`
    /// is the key of the first entry in the index map, and `value` is the value of the first entry
    /// in the index map slice. If the index map slice is empty, this method returns `None`.
    ///
    /// # Examples
    ///
    /// Getting the first entry of a non-empty type-projected index map slice.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map = TypedProjIndexMap::from([
    ///     (String::from("foo"),  1_usize),
    ///     (String::from("bar"),  2_usize),
    ///     (String::from("baz"),  3_usize),
    ///     (String::from("quux"), 4_usize),
    /// ]);
    /// let slice = proj_map.as_slice();
    /// let result = slice.first();
    ///
    /// assert_eq!(result, Some((&String::from("foo"), &1_usize)));
    /// ```
    ///
    /// Getting the first entry from an empty typed-projected index map slice.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<String, usize> = TypedProjIndexMap::new();
    /// let slice = proj_map.as_slice();
    /// let maybe_entry = slice.first();
    ///
    /// assert!(maybe_entry.is_none());
    /// ```
    ///
    /// Getting the first entry of a non-empty type-erased index map slice.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (String::from("foo"),  1_usize),
    ///     (String::from("bar"),  2_usize),
    ///     (String::from("baz"),  3_usize),
    ///     (String::from("quux"), 4_usize),
    /// ]);
    /// let slice = opaque_map.as_slice::<String, usize, RandomState, Global>();
    /// let result = slice.first();
    ///
    /// assert_eq!(result, Some((&String::from("foo"), &1_usize)));
    /// ```
    ///
    /// Getting the first entry from an empty typed-erased index map slice.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::new::<String, usize>();
    /// let slice = opaque_map.as_slice::<String, usize, RandomState, Global>();
    /// let maybe_entry = slice.first();
    ///
    /// assert!(maybe_entry.is_none());
    /// ```
    pub fn first(&self) -> Option<(&K, &V)> {
        self.entries.first()
    }

    /// Returns a mutable reference to the first entry in the index map slice as a
    /// (key reference, mutable value reference) pair, if it exists.
    ///
    /// If the index map slice is nonempty, this method returns `Some((&key, &mut value))` where
    /// `key` is the key of the first entry in the index map slice, and `value` is the value of the
    /// first entry in the index map slice. If the index map slice is empty, this method returns
    /// `None`.
    ///
    /// # Examples
    ///
    /// Getting the first entry of a non-empty type-projected index map slice.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (String::from("foo"),  1_usize),
    ///     (String::from("bar"),  2_usize),
    ///     (String::from("baz"),  3_usize),
    ///     (String::from("quux"), 4_usize),
    /// ]);
    /// let slice = proj_map.as_mut_slice();
    /// let result = slice.first_mut();
    ///
    /// assert_eq!(result, Some((&String::from("foo"), &mut 1_usize)));
    /// ```
    ///
    /// Getting the first entry from an empty typed-projected index map slice.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<String, usize> = TypedProjIndexMap::new();
    /// let slice = proj_map.as_mut_slice();
    /// let maybe_entry = slice.first_mut();
    ///
    /// assert!(maybe_entry.is_none());
    /// ```
    ///
    /// Getting the first entry of a non-empty type-erased index map slice.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (String::from("foo"),  1_usize),
    ///     (String::from("bar"),  2_usize),
    ///     (String::from("baz"),  3_usize),
    ///     (String::from("quux"), 4_usize),
    /// ]);
    /// let slice = opaque_map.as_mut_slice::<String, usize, RandomState, Global>();
    /// let result = slice.first_mut();
    ///
    /// assert_eq!(result, Some((&String::from("foo"), &mut 1_usize)));
    /// ```
    ///
    /// Getting the first entry from an empty typed-erased index map slice.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::new::<String, usize>();
    /// let slice = opaque_map.as_mut_slice::<String, usize, RandomState, Global>();
    /// let maybe_entry = slice.first_mut();
    ///
    /// assert!(maybe_entry.is_none());
    /// ```
    pub fn first_mut(&mut self) -> Option<(&K, &mut V)> {
        self.entries.first_mut()
    }

    /// Returns a reference to the last entry in the index map slice as a
    /// (key reference, value reference) pair, if it exists.
    ///
    /// If the index map slice is nonempty, this method returns `Some((&key, &value))` where `key`
    /// is the key of the last entry in the index map slice, and `value` is the value of the last
    /// entry in the index map slice. If the index map slice is empty, this method returns `None`.
    ///
    /// # Examples
    ///
    /// Getting the last entry of a non-empty type-projected index map slice.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map = TypedProjIndexMap::from([
    ///     (String::from("foo"),  1_usize),
    ///     (String::from("bar"),  2_usize),
    ///     (String::from("baz"),  3_usize),
    ///     (String::from("quux"), 4_usize),
    /// ]);
    /// let slice = proj_map.as_slice();
    /// let result = slice.last();
    ///
    /// assert_eq!(result, Some((&String::from("quux"), &4_usize)));
    /// ```
    ///
    /// Getting the last entry from an empty typed-projected index map slice.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<String, usize> = TypedProjIndexMap::new();
    /// let slice = proj_map.as_slice();
    /// let maybe_entry = slice.last();
    ///
    /// assert!(maybe_entry.is_none());
    /// ```
    ///
    /// Getting the last entry of a non-empty type-erased index map slice.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (String::from("foo"),  1_usize),
    ///     (String::from("bar"),  2_usize),
    ///     (String::from("baz"),  3_usize),
    ///     (String::from("quux"), 4_usize),
    /// ]);
    /// let slice = opaque_map.as_slice::<String, usize, RandomState, Global>();
    /// let result = slice.last();
    ///
    /// assert_eq!(result, Some((&String::from("quux"), &4_usize)));
    /// ```
    ///
    /// Getting the last entry from an empty typed-erased index map slice.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::new::<String, usize>();
    /// let slice = opaque_map.as_slice::<String, usize, RandomState, Global>();
    /// let maybe_entry = slice.last();
    ///
    /// assert!(maybe_entry.is_none());
    /// ```
    pub fn last(&self) -> Option<(&K, &V)> {
        self.entries.last()
    }

    /// Returns a reference to the last entry in the index map slice as a
    /// (key reference, mutable value reference) pair, if it exists.
    ///
    /// If the index map slice is nonempty, this method returns `Some((&key, &value))` where `key`
    /// is the key of the last entry in the index map slice, and `value` is the value of the last
    /// entry in the index map slice. If the index map slice is empty, this method returns `None`.
    ///
    /// # Examples
    ///
    /// Getting the last entry of a non-empty type-projected index map slice.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (String::from("foo"),  1_usize),
    ///     (String::from("bar"),  2_usize),
    ///     (String::from("baz"),  3_usize),
    ///     (String::from("quux"), 4_usize),
    /// ]);
    /// let slice = proj_map.as_mut_slice();
    /// let result = slice.last_mut();
    ///
    /// assert_eq!(result, Some((&String::from("quux"), &mut 4_usize)));
    /// ```
    ///
    /// Getting the last entry from an empty typed-projected index map slice.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<String, usize> = TypedProjIndexMap::new();
    /// let slice = proj_map.as_mut_slice();
    /// let maybe_entry = slice.last_mut();
    ///
    /// assert!(maybe_entry.is_none());
    /// ```
    ///
    /// Getting the last entry of a non-empty type-erased index map slice.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (String::from("foo"),  1_usize),
    ///     (String::from("bar"),  2_usize),
    ///     (String::from("baz"),  3_usize),
    ///     (String::from("quux"), 4_usize),
    /// ]);
    /// let slice = opaque_map.as_mut_slice::<String, usize, RandomState, Global>();
    /// let result = slice.last_mut();
    ///
    /// assert_eq!(result, Some((&String::from("quux"), &mut 4_usize)));
    /// ```
    ///
    /// Getting the last entry from an empty typed-erased index map slice.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::new::<String, usize>();
    /// let slice = opaque_map.as_mut_slice::<String, usize, RandomState, Global>();
    /// let maybe_entry = slice.last_mut();
    ///
    /// assert!(maybe_entry.is_none());
    /// ```
    pub fn last_mut(&mut self) -> Option<(&K, &mut V)> {
        self.entries.last_mut()
    }

    /// Divides an index map slice in two slices at the given index.
    ///
    /// # Panics
    ///
    /// This method panics if `index > self.len()`.
    ///
    /// # Examples
    ///
    /// Splitting a slice from a type-projected index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map = TypedProjIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    ///     (4_usize, 5_i32),
    /// ]);
    /// let (prefix, suffix) = proj_map.as_slice().split_at(2);
    ///
    /// assert_eq!(prefix, &[(0_usize, 1_i32), (1_usize, 2_i32)]);
    /// assert_eq!(suffix, &[(2_usize, 3_i32), (3_usize, 4_i32), (4_usize, 5_i32)]);
    /// ```
    ///
    /// Splitting a slice from a type-erased index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    ///     (4_usize, 5_i32),
    /// ]);
    /// let (prefix, suffix) = opaque_map.as_slice::<usize, i32, RandomState, Global>().split_at(2);
    ///
    /// assert_eq!(prefix, &[(0_usize, 1_i32), (1_usize, 2_i32)]);
    /// assert_eq!(suffix, &[(2_usize, 3_i32), (3_usize, 4_i32), (4_usize, 5_i32)]);
    /// ```
    #[track_caller]
    pub fn split_at(&self, index: usize) -> (&Self, &Self) {
        let (first, second) = self.entries.split_at(index);

        (Self::from_slice(first), Self::from_slice(second))
    }

    /// Divides a mutable index map slice in two mutable slices at the given index.
    ///
    /// # Panics
    ///
    /// This method panics if `index > self.len()`.
    ///
    /// # Examples
    ///
    /// Splitting a slice from a type-projected index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    ///     (4_usize, 5_i32),
    /// ]);
    /// let (prefix, suffix) = proj_map.as_mut_slice().split_at_mut(2);
    ///
    /// assert_eq!(prefix, &[(0_usize, 1_i32), (1_usize, 2_i32)]);
    /// assert_eq!(suffix, &[(2_usize, 3_i32), (3_usize, 4_i32), (4_usize, 5_i32)]);
    /// ```
    ///
    /// Splitting a slice from a type-erased index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    ///     (4_usize, 5_i32),
    /// ]);
    /// let (prefix, suffix) = opaque_map.as_mut_slice::<usize, i32, RandomState, Global>() .split_at_mut(2);
    ///
    /// assert_eq!(prefix, &[(0_usize, 1_i32), (1_usize, 2_i32)]);
    /// assert_eq!(suffix, &[(2_usize, 3_i32), (3_usize, 4_i32), (4_usize, 5_i32)]);
    /// ```
    #[track_caller]
    pub fn split_at_mut(&mut self, index: usize) -> (&mut Self, &mut Self) {
        let (first, second) = self.entries.split_at_mut(index);

        (Self::from_slice_mut(first), Self::from_slice_mut(second))
    }

    /// Divides an index map slice into the first entry and the remainder of the original slice.
    ///
    /// If `self` is nonempty, this method returns `Some(first, suffix)` where `first` is a
    /// reference to the first entry in the slice, and `suffix` is the remainder of the slice. If
    /// `self` is empty, this method returns `None`.
    ///
    /// # Examples
    ///
    /// Splitting a type-projected index map slice.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map = TypedProjIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    ///     (4_usize, 5_i32),
    /// ]);
    /// let result = proj_map.as_slice().split_first();
    ///
    /// assert!(result.is_some());
    ///
    /// let (head, tail) = result.unwrap();
    ///
    /// assert_eq!(head, (&0_usize, &1_i32));
    /// assert_eq!(tail, &[(1_usize, 2_i32), (2_usize, 3_i32), (3_usize, 4_i32), (4_usize, 5_i32)]);
    /// ```
    ///
    /// Splitting a type-erased index map slice.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    ///     (4_usize, 5_i32),
    /// ]);
    /// let result = opaque_map.as_slice::<usize, i32, RandomState, Global>().split_first();
    ///
    /// assert!(result.is_some());
    ///
    /// let (head, tail) = result.unwrap();
    ///
    /// assert_eq!(head, (&0_usize, &1_i32));
    /// assert_eq!(tail, &[(1_usize, 2_i32), (2_usize, 3_i32), (3_usize, 4_i32), (4_usize, 5_i32)]);
    /// ```
    pub fn split_first(&self) -> Option<((&K, &V), &Self)> {
        let (split, slice) = self.entries.split_first()?;

        Some((split, Self::from_slice(slice)))
    }

    /// Divides a mutable index map slice into the first entry and the remainder of the original
    /// slice.
    ///
    /// If `self` is nonempty, this method returns `Some(first, suffix)` where `first` is a
    /// mutable reference to the first entry in the slice, and `suffix` is the remainder of the
    /// slice. If `self` is empty, this method returns `None`.
    ///
    /// # Examples
    ///
    /// Splitting a type-projected index map slice.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    ///     (4_usize, 5_i32),
    /// ]);
    /// let result = proj_map.as_mut_slice().split_first_mut();
    ///
    /// assert!(result.is_some());
    ///
    /// let (head, tail) = result.unwrap();
    ///
    /// assert_eq!(head, (&0_usize, &mut 1_i32));
    /// assert_eq!(tail, &[(1_usize, 2_i32), (2_usize, 3_i32), (3_usize, 4_i32), (4_usize, 5_i32)]);
    /// ```
    ///
    /// Splitting a type-erased index map slice.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    ///     (4_usize, 5_i32),
    /// ]);
    /// let result = opaque_map.as_mut_slice::<usize, i32, RandomState, Global>().split_first_mut();
    ///
    /// assert!(result.is_some());
    ///
    /// let (head, tail) = result.unwrap();
    ///
    /// assert_eq!(head, (&0_usize, &mut 1_i32));
    /// assert_eq!(tail, &[(1_usize, 2_i32), (2_usize, 3_i32), (3_usize, 4_i32), (4_usize, 5_i32)]);
    /// ```
    pub fn split_first_mut(&mut self) -> Option<((&K, &mut V), &mut Self)> {
        let (split, slice) = self.entries.split_first_mut()?;

        Some((split, Self::from_slice_mut(slice)))
    }

    /// Divides an index map slice into the last entry and a prefix of the original slice.
    ///
    /// If `self` is nonempty, this method returns `Some(last, prefix)` where `last` is a
    /// reference to the last entry in the slice, and `prefix` is a slice of the elements before
    /// `last`. If `self` is empty, this method returns `None`.
    ///
    /// # Examples
    ///
    /// Splitting a type-projected index map slice.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map = TypedProjIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    ///     (4_usize, 5_i32),
    /// ]);
    /// let result = proj_map.as_slice().split_last();
    ///
    /// assert!(result.is_some());
    ///
    /// let (last, prefix) = result.unwrap();
    ///
    /// assert_eq!(last, (&4_usize, &5_i32));
    /// assert_eq!(prefix, &[(0_usize, 1_i32), (1_usize, 2_i32), (2_usize, 3_i32), (3_usize, 4_i32)]);
    /// ```
    ///
    /// Splitting a type-erased index map slice.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    ///     (4_usize, 5_i32),
    /// ]);
    /// let result = opaque_map.as_slice::<usize, i32, RandomState, Global>().split_last();
    ///
    /// assert!(result.is_some());
    ///
    /// let (last, prefix) = result.unwrap();
    ///
    /// assert_eq!(last, (&4_usize, &5_i32));
    /// assert_eq!(prefix, &[(0_usize, 1_i32), (1_usize, 2_i32), (2_usize, 3_i32), (3_usize, 4_i32)]);
    /// ```
    pub fn split_last(&self) -> Option<((&K, &V), &Self)> {
        let (split, slice) = self.entries.split_last()?;

        Some((split, Self::from_slice(slice)))
    }

    /// Divides a mutable index map slice into the last entry and a prefix of the original slice.
    ///
    /// If `self` is nonempty, this method returns `Some(last, prefix)` where `last` is a mutable
    /// reference to the last entry in the slice, and `prefix` is a slice of the elements before
    /// `last`. If `self` is empty, this method returns `None`.
    ///
    /// # Examples
    ///
    /// Splitting a type-projected index map slice.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    ///     (4_usize, 5_i32),
    /// ]);
    /// let result = proj_map.as_mut_slice().split_last_mut();
    ///
    /// assert!(result.is_some());
    ///
    /// let (last, prefix) = result.unwrap();
    ///
    /// assert_eq!(last, (&4_usize, &mut 5_i32));
    /// assert_eq!(prefix, &[(0_usize, 1_i32), (1_usize, 2_i32), (2_usize, 3_i32), (3_usize, 4_i32)]);
    /// ```
    ///
    /// Splitting a type-erased index map slice.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    ///     (4_usize, 5_i32),
    /// ]);
    /// let result = opaque_map.as_mut_slice::<usize, i32, RandomState, Global>().split_last_mut();
    ///
    /// assert!(result.is_some());
    ///
    /// let (last, prefix) = result.unwrap();
    ///
    /// assert_eq!(last, (&4_usize, &mut 5_i32));
    /// assert_eq!(prefix, &[(0_usize, 1_i32), (1_usize, 2_i32), (2_usize, 3_i32), (3_usize, 4_i32)]);
    /// ```
    pub fn split_last_mut(&mut self) -> Option<((&K, &mut V), &mut Self)> {
        let (split, slice) = self.entries.split_last_mut()?;

        Some((split, Slice::from_slice_mut(slice)))
    }

    /// Returns an iterator over the entries in the index map slice.
    ///
    /// The iterator returns the entries in their storage order in the index map slice.
    ///
    /// # Examples
    ///
    /// Iterating over the entries of an index map slice.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map = TypedProjIndexMap::from([
    ///     (0_usize, 2_f32),
    ///     (1_usize, 3_f32),
    ///     (2_usize, 4_f32),
    /// ]);
    /// let slice = proj_map.as_slice();
    /// let entries: TypedProjVec<(usize, f32)> = slice
    ///     .iter()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(entries.as_slice(), &[(0_usize, 2_f32), (1_usize, 3_f32), (2_usize, 4_f32)]);
    /// ```
    pub fn iter(&self) -> Iter<'_, K, V> {
        Iter::new(self.entries.iter())
    }

    /// Returns a mutable iterator over the entries in the index map slice.
    ///
    /// The iterator returns the entries in their storage order in the index map slice.
    ///
    /// # Examples
    ///
    /// Iterating over the entries of an index map slice.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (0_usize, 2_f32),
    ///     (1_usize, 3_f32),
    ///     (2_usize, 4_f32),
    /// ]);
    /// let slice = proj_map.as_mut_slice();
    /// let entries: TypedProjVec<(usize, f32)> = slice
    ///     .iter_mut()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(entries.as_slice(), &[(0_usize, 2_f32), (1_usize, 3_f32), (2_usize, 4_f32)]);
    /// ```
    ///
    /// Iterating over the entries of an index map slice while mutating them.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (0_usize, 2_f32),
    ///     (1_usize, 3_f32),
    ///     (2_usize, 4_f32),
    /// ]);
    /// let slice = proj_map.as_mut_slice();
    /// let entries: TypedProjVec<(usize, f32)> = slice
    ///     .iter_mut()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(entries.as_slice(), &[(0_usize, 2_f32), (1_usize, 3_f32), (2_usize, 4_f32)]);
    ///
    /// for (key, value) in proj_map.iter_mut() {
    ///     *value *= 2_f32;
    /// }
    ///
    /// let new_entries: TypedProjVec<(usize, f32)> = proj_map
    ///     .iter_mut()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(new_entries.as_slice(), &[(0_usize, 4_f32), (1_usize, 6_f32), (2_usize, 8_f32)]);
    /// ```
    pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {
        IterMut::new(self.entries.iter_mut())
    }

    /// Returns an iterator over the keys in the index map slice.
    ///
    /// The iterator returns the keys in the storage order of the entries in the index map slice.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    /// let slice = proj_map.as_slice();
    /// let keys: TypedProjVec<usize> = slice
    ///     .keys()
    ///     .cloned()
    ///     .collect();
    ///
    /// assert_eq!(keys.as_slice(), &[1_usize, 2_usize, 3_usize]);
    /// ```
    pub fn keys(&self) -> Keys<'_, K, V> {
        Keys::new(self.entries.keys())
    }
}

#[cfg(feature = "nightly")]
impl<K, V> Slice<K, V> {
    /// Returns a moving iterator over the keys in the index map slice.
    ///
    /// The iterator returns the keys in the storage order of the entries in the index map slice.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    /// let boxed_slice = proj_map.into_boxed_slice();
    ///
    /// let keys: TypedProjVec<usize> = boxed_slice.into_keys().collect();
    ///
    /// assert_eq!(keys.as_slice(), &[1_usize, 2_usize, 3_usize]);
    /// ```
    pub fn into_keys<A>(self: Box<Self, TypedProjAlloc<A>>) -> IntoKeys<K, V, A>
    where
        K: any::Any,
        V: any::Any,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        IntoKeys::new(self.into_boxed_slice().into_keys())
    }
}

impl<K, V> Slice<K, V> {
    /// Returns an iterator over the values in the index map slice.
    ///
    /// The iterator returns the values in the storage order of the entries in the index map slice.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    /// let slice = proj_map.as_slice();
    ///
    /// let values: TypedProjVec<f64> = slice
    ///     .values()
    ///     .cloned()
    ///     .collect();
    ///
    /// assert_eq!(values.as_slice(), &[2_f64, 3_f64, 4_f64]);
    /// ```
    pub fn values(&self) -> Values<'_, K, V> {
        Values::new(self.entries.values())
    }

    /// Returns a mutable iterator over the values in the index map slice.
    ///
    /// The iterator returns the values in the storage order of the entries in the index map slice.
    ///
    /// # Examples
    ///
    /// Iterating over the entries of a type-projected index map without mutating them.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    /// let slice = proj_map.as_mut_slice();
    ///
    /// let values: TypedProjVec<f64> = slice
    ///     .values_mut()
    ///     .map(|v| v.clone())
    ///     .collect();
    ///
    /// assert_eq!(values.as_slice(), &[2_f64, 3_f64, 4_f64]);
    /// ```
    ///
    /// Iterating over the entries of a type-projected index map while mutating them.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    /// let slice = proj_map.as_mut_slice();
    ///
    /// let values: TypedProjVec<f64> = slice
    ///     .values_mut()
    ///     .map(|v| v.clone())
    ///     .collect();
    ///
    /// assert_eq!(values.as_slice(), &[2_f64, 3_f64, 4_f64]);
    ///
    /// for value in slice.values_mut() {
    ///     *value *= 2_f64;
    /// }
    ///
    /// let new_values: TypedProjVec<f64> = slice
    ///     .values_mut()
    ///     .map(|v| v.clone())
    ///     .collect();
    ///
    /// assert_eq!(new_values.as_slice(), &[4_f64, 6_f64, 8_f64]);
    /// ```
    pub fn values_mut(&mut self) -> ValuesMut<'_, K, V> {
        ValuesMut::new(self.entries.values_mut())
    }
}

#[cfg(feature = "nightly")]
impl<K, V> Slice<K, V> {
    /// Returns a moving iterator over the values in the index map slice.
    ///
    /// The iterator returns the values in the storage order of the entries in the index map slice.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    /// let boxed_slice = proj_map.into_boxed_slice();
    ///
    /// let values: TypedProjVec<f64> = boxed_slice.into_values().collect();
    ///
    /// assert_eq!(values.as_slice(), &[2_f64, 3_f64, 4_f64]);
    /// ```
    pub fn into_values<A>(self: Box<Self, TypedProjAlloc<A>>) -> IntoValues<K, V, A>
    where
        K: any::Any,
        V: any::Any,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        IntoValues::new(self.into_boxed_slice().into_values())
    }
}

impl<K, V> Slice<K, V> {
    /// Binary searches a sorted index map slice for the given key. If the index map slice is
    /// unsorted, the returned result is unspecified and meaningless.
    ///
    /// If the entry with the key `key` is found in the slice, then this method returns `Ok(index)`,
    /// where `index` is the storage index of the entry with key `key` in the slice. If the entry
    /// with the key `key` is not found in the map, then this method returns `Err(new_index)` where
    /// `new_index` is the position in the storage where an entry with the key `key` could be
    /// inserted to maintain the sorted order.
    ///
    /// # Examples
    ///
    /// Binary searching a sorted index map slice.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<isize, char> = TypedProjIndexMap::from_iter((1_isize..=26_isize).zip('a'..='z'));
    /// let slice = proj_map.as_slice();
    /// for (i, (key, value)) in (1_isize..=26_isize).zip('a'..='z').enumerate() {
    ///     let result = slice.binary_search_keys(&key);
    ///     assert_eq!(result, Ok(i));
    /// }
    /// ```
    pub fn binary_search_keys(&self, key: &K) -> Result<usize, usize>
    where
        K: Ord,
    {
        self.entries.binary_search_keys(key)
    }

    /// Binary searches a sorted index map slice using a given comparator function. If the index map
    /// slice is unsorted, the returned result is unspecified and meaningless.
    ///
    /// The comparator function should return an order code that indicates whether its argument is
    /// `Less`, `Equal` or `Greater` than the desired target.
    ///
    /// If the index map slice is not in sorted order or if the comparator function does not
    /// implement an order consistent with the sorted order of the underlying index map slice, the
    /// returned result is unspecified and meaningless.
    ///
    /// If an entry satisfying the comparator is found in the slice, then this method returns
    /// `Ok(index)`, where `index` is the storage index of the entry found in the slice. If an entry
    /// satisfying the comparator is not found in the slice, then this method returns
    /// `Err(new_index)` where `new_index` is the position in the storage where an entry with the
    /// key `key` could be inserted to maintain the sorted order. If multiple entries in the index
    /// map satisfy the comparator, then any one of them could be returned. The index is chosen
    /// deterministically, but this method makes no guarantees as to how it picks that index.
    ///
    /// # Examples
    ///
    /// Binary searching a sorted index map slice.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<isize, char> = TypedProjIndexMap::from_iter((1_isize..=26_isize).zip('a'..='z'));
    /// let slice = proj_map.as_slice();
    /// let expected = Ok(23);
    /// let result = slice.binary_search_by(|k, v| v.cmp(&'x'));
    ///
    /// assert_eq!(result, expected);
    ///
    /// assert!('*' < 'a');
    ///
    /// let expected = Err(0);
    /// let result = slice.binary_search_by(|k, v| v.cmp(&'*'));
    ///
    /// assert_eq!(result, expected);
    /// ```
    ///
    /// Binary searching a sorted index map slice with repeating values.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map = TypedProjIndexMap::from([
    ///     (1_usize, 'a'), (2_usize, 'b'), (3_usize, 'c'),
    ///     (4_usize, 'd'), (5_usize, 'd'), (6_usize, 'd'),  (7_usize, 'd'),
    ///     (8_usize, 'e'), (9_usize, 'f'), (10_usize, 'g'), (11_usize, 'h'),
    /// ]);
    /// let slice = proj_map.as_slice();
    ///
    /// assert_eq!(slice.binary_search_by(|&k, &v| v.cmp(&'a')), Ok(0));
    /// assert_eq!(slice.binary_search_by(|&k, &v| v.cmp(&'b')), Ok(1));
    /// assert_eq!(slice.binary_search_by(|&k, &v| v.cmp(&'c')), Ok(2));
    ///
    /// let result = slice.binary_search_by(|&k, &v| v.cmp(&'d'));
    /// assert!(match result { Ok(3..=6) => true, _ => false });
    ///
    /// assert_eq!(slice.binary_search_by(|&k, &v| v.cmp(&'e')), Ok(7));
    /// assert_eq!(slice.binary_search_by(|&k, &v| v.cmp(&'f')), Ok(8));
    /// assert_eq!(slice.binary_search_by(|&k, &v| v.cmp(&'g')), Ok(9));
    /// assert_eq!(slice.binary_search_by(|&k, &v| v.cmp(&'h')), Ok(10));
    /// ```
    #[inline]
    pub fn binary_search_by<F>(&self, f: F) -> Result<usize, usize>
    where
        F: FnMut(&K, &V) -> cmp::Ordering,
    {
        self.entries.binary_search_by(f)
    }

    /// Binary searches the index map slice with a key extraction function.
    ///
    /// This method assumes that the index map slice is in sorted order by the key, for instance by
    /// sorting the index map with [`sort_by_key`] using the same key extraction function. If the
    /// index map slice is not sorted by the key, the returned result is unspecified and meaningless.
    ///
    /// If an entry matching the key is found in the slice, then this method returns `Ok(index)`,
    /// where `index` is the storage index of the entry found in the slice. If an entry matching the
    /// key is not found in the slice, then this method returns `Err(new_index)` where `new_index`
    /// is the position in the slice where an entry with the matching key could be inserted to
    /// maintain the sorted order. If multiple entries in the index map slice match the key, then
    /// any one of them could be returned. The index is chosen deterministically, but this method
    /// makes no guarantees as to how it picks that index.
    ///
    /// See also [`binary_search`], [`binary_search_by`], and [`partition_point`].
    ///
    /// [`sort_by_key`]: TypedProjIndexMap::sort_by_key
    /// [`binary_search`]: Slice::binary_search
    /// [`binary_search_by`]: Slice::binary_search_by
    /// [`partition_point`]: Slice::partition_point
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map = TypedProjIndexMap::from([
    ///     (0_usize,  0_isize),
    ///     (1_usize,  1_isize), (2_usize, 1_isize), (3_usize, 1_isize), (4_usize, 1_isize),
    ///     (5_usize,  2_isize),
    ///     (6_usize,  3_isize),
    ///     (7_usize,  5_isize),
    ///     (8_usize,  8_isize),
    ///     (9_usize,  13_isize),
    ///     (10_usize, 21_isize),
    ///     (11_usize, 34_isize),
    ///     (12_usize, 55_isize),
    /// ]);
    /// let slice = proj_map.as_slice();
    ///
    /// assert_eq!(slice.binary_search_by_key(&13, |&a, &b| b),  Ok(9));
    /// assert_eq!(slice.binary_search_by_key(&4, |&a, &b| b),   Err(7));
    /// assert_eq!(slice.binary_search_by_key(&100, |&a, &b| b), Err(13));
    ///
    /// let result = slice.binary_search_by_key(&1, |&a, &b| b);
    ///
    /// assert!(match result { Ok(1..=4) => true, _ => false, });
    /// ```
    #[inline]
    pub fn binary_search_by_key<B, F>(&self, b: &B, f: F) -> Result<usize, usize>
    where
        F: FnMut(&K, &V) -> B,
        B: Ord,
    {
        self.entries.binary_search_by_key(b, f)
    }

    /// Returns the index of the partition point of a sorted index map slice according to the given
    /// predicate (the index of the first element of the second partition).
    ///
    /// This method assumes that the storage order of the entries in the index map slice is
    /// partitioned according to the predicate. That is, all entries for which the predicate returns
    /// `true` are at the start of the slice, and all entries for which the predicate returns
    /// `false` are at the end of the slice. If the index map slice's storage order does not
    /// partition according to the predicate, the result is unspecified and meaningless.
    ///
    /// # Examples
    ///
    /// Finding the partition point of a partitioned index map slice where not every entry matches
    /// the predicate.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map = TypedProjIndexMap::from([
    ///     (0_usize, 1_isize),
    ///     (1_usize, 2_isize),
    ///     (2_usize, 2_isize),
    ///     (3_usize, 3_isize),
    ///     (4_usize, 5_isize),
    ///     (5_usize, 5_isize),
    ///     (6_usize, 5_isize),
    ///     (7_usize, 6_isize),
    ///     (8_usize, 9_isize),
    /// ]);
    /// let slice = proj_map.as_slice();
    ///
    /// assert_eq!(slice.partition_point(|&k, &v| v < 5_isize), 4);
    /// ```
    ///
    /// Finding the partition point of an index map slice where every entry matches the predicate.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// fn is_power_of_two(n: usize) -> bool {
    ///     n != 0 && (n & (n - 1)) == 0
    /// }
    ///
    /// let proj_map = TypedProjIndexMap::from([
    ///     (0_usize, 1_usize),
    ///     (1_usize, 2_usize),
    ///     (2_usize, 4_usize),
    ///     (3_usize, 8_usize),
    ///     (4_usize, 16_usize),
    ///     (5_usize, 32_usize),
    ///     (6_usize, 64_usize),
    /// ]);
    /// let slice = proj_map.as_slice();
    ///
    /// assert_eq!(slice.partition_point(|&k, &v| is_power_of_two(v)), slice.len());
    /// ```
    ///
    /// Finding the partition point of an index map slice where no entry matches the predicate.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// fn is_power_of_two(n: usize) -> bool {
    ///     n != 0 && (n & (n - 1)) == 0
    /// }
    ///
    /// let proj_map = TypedProjIndexMap::from([
    ///     (0_usize, 3_usize),
    ///     (1_usize, 5_usize),
    ///     (2_usize, 7_usize),
    ///     (3_usize, 11_usize),
    ///     (4_usize, 13_usize),
    ///     (5_usize, 17_usize),
    ///     (6_usize, 19_usize),
    /// ]);
    /// let slice = proj_map.as_slice();
    ///
    /// assert_eq!(slice.partition_point(|&k, &v| is_power_of_two(v)), 0);
    /// ```
    #[must_use]
    pub fn partition_point<P>(&self, pred: P) -> usize
    where
        P: FnMut(&K, &V) -> bool,
    {
        self.entries.partition_point(pred)
    }

    /// Returns multiple references to the key-value pairs of multiple entries in the index map at
    /// once.
    ///
    /// # Panics
    ///
    /// This method panics if there are any duplicate indices.
    ///
    /// # Examples
    ///
    /// Getting key-value pairs from a type-projected index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (1_isize, 'a'),
    ///     (3_isize, 'b'),
    ///     (2_isize, 'c'),
    ///     (6_isize, 'e'),
    ///     (4_isize, 'f'),
    ///     (5_isize, '@'),
    /// ]);
    /// let slice = proj_map.as_mut_slice();
    ///
    /// let maybe_result = slice.get_disjoint_mut([2, 1, 5]);
    ///
    /// assert!(maybe_result.is_ok());
    ///
    /// let result = maybe_result.unwrap();
    ///
    /// assert_eq!(result[0], (&2_isize, &mut 'c'));
    /// assert_eq!(result[1], (&3_isize, &mut 'b'));
    /// assert_eq!(result[2], (&5_isize, &mut '@'));
    /// ```
    ///
    /// Getting key-value pairs from a type-erased index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_isize, 'a'),
    ///     (3_isize, 'b'),
    ///     (2_isize, 'c'),
    ///     (6_isize, 'e'),
    ///     (4_isize, 'f'),
    ///     (5_isize, '@'),
    /// ]);
    /// let slice = opaque_map.as_mut_slice::<isize, char, RandomState, Global>();
    ///
    /// let maybe_result = slice.get_disjoint_mut([2, 1, 5]);
    ///
    /// assert!(maybe_result.is_ok());
    ///
    /// let result = maybe_result.unwrap();
    ///
    /// assert_eq!(result[0], (&2_isize, &mut 'c'));
    /// assert_eq!(result[1], (&3_isize, &mut 'b'));
    /// assert_eq!(result[2], (&5_isize, &mut '@'));
    /// ```
    #[track_caller]
    pub fn get_disjoint_mut<const N: usize>(
        &mut self,
        indices: [usize; N],
    ) -> Result<[(&K, &mut V); N], GetDisjointMutError> {
        self.entries.get_disjoint_mut(indices)
    }
}

impl<'a, K, V> IntoIterator for &'a Slice<K, V> {
    type Item = (&'a K, &'a V);
    type IntoIter = Iter<'a, K, V>;

    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}

impl<'a, K, V> IntoIterator for &'a mut Slice<K, V> {
    type Item = (&'a K, &'a mut V);
    type IntoIter = IterMut<'a, K, V>;

    fn into_iter(self) -> Self::IntoIter {
        self.iter_mut()
    }
}

#[cfg(feature = "nightly")]
impl<K, V, A> IntoIterator for Box<Slice<K, V>, TypedProjAlloc<A>>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    type Item = (K, V);
    type IntoIter = IntoIter<K, V, A>;

    fn into_iter(self) -> Self::IntoIter {
        IntoIter::new(self.into_boxed_slice().into_iter())
    }
}

impl<K, V> Default for &'_ Slice<K, V> {
    fn default() -> Self {
        Slice::from_slice(Default::default())
    }
}


impl<K, V> Default for &'_ mut Slice<K, V> {
    fn default() -> Self {
        Slice::from_slice_mut(Default::default())
    }
}

#[cfg(feature = "nightly")]
impl<K, V, A> Default for Box<Slice<K, V>, TypedProjAlloc<A>>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync + Default,
{
    fn default() -> Self {
        Slice::from_boxed_slice(Box::default())
    }
}

#[cfg(feature = "nightly")]
impl<K, V, A> Clone for Box<Slice<K, V>, TypedProjAlloc<A>>
where
    K: any::Any + Clone,
    V: any::Any + Clone,
    A: any::Any + alloc::Allocator + Send + Sync + Clone,
{
    fn clone(&self) -> Self {
        let alloc = Box::allocator(&self).clone();
        let entries = self.entries.to_entries_in(alloc);

        Slice::from_entries_in(entries)
    }
}

#[cfg(feature = "nightly")]
impl<K, V> From<&Slice<K, V>> for Box<Slice<K, V>, TypedProjAlloc<alloc::Global>>
where
    K: any::Any + Copy,
    V: any::Any + Copy,
{
    fn from(slice: &Slice<K, V>) -> Self {
        let boxed_entries: Box<map_inner::Slice<K, V>, TypedProjAlloc<alloc::Global>> = Box::from(&slice.entries);

        Slice::from_boxed_slice(boxed_entries)
    }
}

impl<K, V> fmt::Debug for Slice<K, V>
where
    K: fmt::Debug,
    V: fmt::Debug,
{
    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
        formatter.debug_list().entries(self).finish()
    }
}

impl<K, V, K2, V2> PartialEq<Slice<K2, V2>> for Slice<K, V>
where
    K: PartialEq<K2>,
    V: PartialEq<V2>,
{
    fn eq(&self, other: &Slice<K2, V2>) -> bool {
        self.entries.eq(&other.entries)
    }
}

impl<K, V, K2, V2> PartialEq<[(K2, V2)]> for Slice<K, V>
where
    K: PartialEq<K2>,
    V: PartialEq<V2>,
{
    fn eq(&self, other: &[(K2, V2)]) -> bool {
        self.entries.eq(other)
    }
}

impl<K, V, K2, V2> PartialEq<Slice<K2, V2>> for [(K, V)]
where
    K: PartialEq<K2>,
    V: PartialEq<V2>,
{
    fn eq(&self, other: &Slice<K2, V2>) -> bool {
        self.eq(&other.entries)
    }
}

impl<K, V, K2, V2, const N: usize> PartialEq<[(K2, V2); N]> for Slice<K, V>
where
    K: PartialEq<K2>,
    V: PartialEq<V2>,
{
    fn eq(&self, other: &[(K2, V2); N]) -> bool {
        self.entries.eq(other)
    }
}

impl<K, V, const N: usize, K2, V2> PartialEq<Slice<K2, V2>> for [(K, V); N]
where
    K: PartialEq<K2>,
    V: PartialEq<V2>,
{
    fn eq(&self, other: &Slice<K2, V2>) -> bool {
        self.eq(&other.entries)
    }
}

impl<K, V> Eq for Slice<K, V>
where
    K: Eq,
    V: Eq,
{
}

impl<K, V> PartialOrd for Slice<K, V>
where
    K: PartialOrd,
    V: PartialOrd,
{
    fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {
        self.iter().partial_cmp(other)
    }
}

impl<K, V> Ord for Slice<K, V>
where
    K: Ord,
    V: Ord,
{
    fn cmp(&self, other: &Self) -> cmp::Ordering {
        Ord::cmp(&self.entries, &other.entries)
    }
}

impl<K, V> hash::Hash for Slice<K, V>
where
    K: hash::Hash,
    V: hash::Hash,
{
    fn hash<H>(&self, state: &mut H)
    where
        H: hash::Hasher,
    {
        self.entries.hash(state);
    }
}

impl<K, V> ops::Index<usize> for Slice<K, V> {
    type Output = V;

    fn index(&self, index: usize) -> &Self::Output {
        self.entries.index(index).value_ref()
    }
}

impl<K, V> ops::IndexMut<usize> for Slice<K, V> {
    fn index_mut(&mut self, index: usize) -> &mut Self::Output {
        self.entries.index_mut(index).value_mut()
    }
}

macro_rules! impl_index_for_index_map_slice {
    ($($range:ty),*) => {$(
        impl<K, V> ops::Index<$range> for Slice<K, V> {
            type Output = Slice<K, V>;

            fn index(&self, range: $range) -> &Self {
                Self::from_slice(&self.entries[range])
            }
        }

        impl<K, V> ops::IndexMut<$range> for Slice<K, V> {
            fn index_mut(&mut self, range: $range) -> &mut Self {
                Self::from_slice_mut(&mut self.entries[range])
            }
        }
    )*}
}

impl_index_for_index_map_slice!(
    ops::Range<usize>,
    ops::RangeFrom<usize>,
    ops::RangeFull,
    ops::RangeInclusive<usize>,
    ops::RangeTo<usize>,
    ops::RangeToInclusive<usize>,
    (ops::Bound<usize>, ops::Bound<usize>)
);

/// An immutable iterator over the entries of an index map.
///
/// Iterators are created by the [`TypedProjIndexMap::iter`] and [`OpaqueIndexMap::iter`] methods.
///
/// # Examples
///
/// Iterating over the entries of a type-projected index map.
///
/// ```
/// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
/// # use opaque_index_map::TypedProjIndexMap;
/// # use opaque_hash::TypedProjBuildHasher;
/// # use opaque_alloc::TypedProjAlloc;
/// # use opaque_vec::TypedProjVec;
/// # use std::any::TypeId;
/// # use std::cmp::Ordering;
/// # use std::hash::RandomState;
/// #
/// # #[cfg(feature = "nightly")]
/// # use std::alloc::Global;
/// #
/// # #[cfg(not(feature = "nightly"))]
/// # use opaque_allocator_api::alloc::Global;
/// #
/// let proj_map = TypedProjIndexMap::from([
///     (0_usize, 1_i32),
///     (1_usize, 2_i32),
///     (2_usize, 3_i32),
///     (3_usize, 4_i32),
/// ]);
/// let mut iterator = proj_map.iter();
///
/// assert_eq!(iterator.next(), Some((&0_usize, &1_i32)));
/// assert_eq!(iterator.next(), Some((&1_usize, &2_i32)));
/// assert_eq!(iterator.next(), Some((&2_usize, &3_i32)));
/// assert_eq!(iterator.next(), Some((&3_usize, &4_i32)));
/// assert_eq!(iterator.next(), None);
/// ```
///
/// Iterating over the entries of a type-erased index map.
///
/// ```
/// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
/// # use opaque_index_map::OpaqueIndexMap;
/// # use opaque_hash::TypedProjBuildHasher;
/// # use opaque_alloc::TypedProjAlloc;
/// # use opaque_vec::TypedProjVec;
/// # use std::any::TypeId;
/// # use std::cmp::Ordering;
/// # use std::hash::RandomState;
/// #
/// # #[cfg(feature = "nightly")]
/// # use std::alloc::Global;
/// #
/// # #[cfg(not(feature = "nightly"))]
/// # use opaque_allocator_api::alloc::Global;
/// #
/// let opaque_map = OpaqueIndexMap::from([
///     (0_usize, 1_i32),
///     (1_usize, 2_i32),
///     (2_usize, 3_i32),
///     (3_usize, 4_i32),
/// ]);
/// let mut iterator = opaque_map.iter::<usize, i32, RandomState, Global>();
///
/// assert_eq!(iterator.next(), Some((&0_usize, &1_i32)));
/// assert_eq!(iterator.next(), Some((&1_usize, &2_i32)));
/// assert_eq!(iterator.next(), Some((&2_usize, &3_i32)));
/// assert_eq!(iterator.next(), Some((&3_usize, &4_i32)));
/// assert_eq!(iterator.next(), None);
/// ```
pub struct Iter<'a, K, V> {
    iter: map_inner::Iter<'a, K, V>,
}

impl<'a, K, V> Iter<'a, K, V> {
    /// Constructs a new index map iterator from an inner index map iterator.
    #[inline]
    fn new(iter: map_inner::Iter<'a, K, V>) -> Self {
        Self { iter, }
    }

    /// Returns a slice of the remaining entries in the iterator.
    ///
    /// # Examples
    ///
    /// Slicing an iterator over a type-projected index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map = TypedProjIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    /// ]);
    /// let mut iterator = proj_map.iter();
    ///
    /// assert_eq!(iterator.as_slice(), &[(0_usize, 1_i32), (1_usize, 2_i32), (2_usize, 3_i32), (3_usize, 4_i32)]);
    /// let _ = iterator.next().unwrap();
    /// assert_eq!(iterator.as_slice(), &[(1_usize, 2_i32), (2_usize, 3_i32), (3_usize, 4_i32)]);
    /// let _ = iterator.next().unwrap();
    /// assert_eq!(iterator.as_slice(), &[(2_usize, 3_i32), (3_usize, 4_i32)]);
    /// let _ = iterator.next().unwrap();
    /// assert_eq!(iterator.as_slice(), &[(3_usize, 4_i32)]);
    /// let _ = iterator.next().unwrap();
    /// assert!(iterator.as_slice().is_empty());
    /// ```
    ///
    /// Slice an iterator over a type-erased index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    /// ]);
    /// let mut iterator = opaque_map.iter::<usize, i32, RandomState, Global>();
    ///
    /// assert_eq!(iterator.as_slice(), &[(0_usize, 1_i32), (1_usize, 2_i32), (2_usize, 3_i32), (3_usize, 4_i32)]);
    /// let _ = iterator.next().unwrap();
    /// assert_eq!(iterator.as_slice(), &[(1_usize, 2_i32), (2_usize, 3_i32), (3_usize, 4_i32)]);
    /// let _ = iterator.next().unwrap();
    /// assert_eq!(iterator.as_slice(), &[(2_usize, 3_i32), (3_usize, 4_i32)]);
    /// let _ = iterator.next().unwrap();
    /// assert_eq!(iterator.as_slice(), &[(3_usize, 4_i32)]);
    /// let _ = iterator.next().unwrap();
    /// assert!(iterator.as_slice().is_empty());
    /// ```
    pub fn as_slice(&self) -> &Slice<K, V> {
        Slice::from_slice(self.iter.as_slice())
    }
}

impl<'a, K, V> Iterator for Iter<'a, K, V> {
    type Item = (&'a K, &'a V);

    fn next(&mut self) -> Option<Self::Item> {
        self.iter.next()
    }
}

impl<K, V> DoubleEndedIterator for Iter<'_, K, V> {
    fn next_back(&mut self) -> Option<Self::Item> {
        self.iter.next_back()
    }

    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
        self.iter.nth_back(n)
    }
}

impl<K, V> ExactSizeIterator for Iter<'_, K, V> {
    fn len(&self) -> usize {
        self.iter.len()
    }
}

impl<K, V> iter::FusedIterator for Iter<'_, K, V> {}

impl<K, V> Clone for Iter<'_, K, V> {
    fn clone(&self) -> Self {
        Iter { iter: self.iter.clone() }
    }
}

impl<K, V> fmt::Debug for Iter<'_, K, V>
where
    K: fmt::Debug,
    V: fmt::Debug,
{
    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
        formatter.debug_list().entries(self.clone()).finish()
    }
}

impl<K, V> Default for Iter<'_, K, V> {
    fn default() -> Self {
        Self { iter: Default::default() }
    }
}

/// A mutable iterator over the entries of an index map.
///
/// Mutable iterators are created by the [`TypedProjIndexMap::iter_mut`] and [`OpaqueIndexMap::iter_mut`]
/// methods.
///
/// # Examples
///
/// Iterating over the entries of a type-projected index map.
///
/// ```
/// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
/// # use opaque_index_map::TypedProjIndexMap;
/// # use opaque_hash::TypedProjBuildHasher;
/// # use opaque_alloc::TypedProjAlloc;
/// # use opaque_vec::TypedProjVec;
/// # use std::any::TypeId;
/// # use std::cmp::Ordering;
/// # use std::hash::RandomState;
/// #
/// # #[cfg(feature = "nightly")]
/// # use std::alloc::Global;
/// #
/// # #[cfg(not(feature = "nightly"))]
/// # use opaque_allocator_api::alloc::Global;
/// #
/// let mut proj_map = TypedProjIndexMap::from([
///     (0_usize, 1_i32),
///     (1_usize, 2_i32),
///     (2_usize, 3_i32),
///     (3_usize, 4_i32),
/// ]);
/// let mut iterator = proj_map.iter_mut();
///
/// assert_eq!(iterator.next(), Some((&0_usize, &mut 1_i32)));
/// assert_eq!(iterator.next(), Some((&1_usize, &mut 2_i32)));
/// assert_eq!(iterator.next(), Some((&2_usize, &mut 3_i32)));
/// assert_eq!(iterator.next(), Some((&3_usize, &mut 4_i32)));
/// assert_eq!(iterator.next(), None);
/// ```
///
/// Iterating over the entries of a type-erased index map.
///
/// ```
/// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
/// # use opaque_index_map::OpaqueIndexMap;
/// # use opaque_hash::TypedProjBuildHasher;
/// # use opaque_alloc::TypedProjAlloc;
/// # use opaque_vec::TypedProjVec;
/// # use std::any::TypeId;
/// # use std::cmp::Ordering;
/// # use std::hash::RandomState;
/// #
/// # #[cfg(feature = "nightly")]
/// # use std::alloc::Global;
/// #
/// # #[cfg(not(feature = "nightly"))]
/// # use opaque_allocator_api::alloc::Global;
/// #
/// let mut opaque_map = OpaqueIndexMap::from([
///     (0_usize, 1_i32),
///     (1_usize, 2_i32),
///     (2_usize, 3_i32),
///     (3_usize, 4_i32),
/// ]);
/// let mut iterator = opaque_map.iter_mut::<usize, i32, RandomState, Global>();
///
/// assert_eq!(iterator.next(), Some((&0_usize, &mut 1_i32)));
/// assert_eq!(iterator.next(), Some((&1_usize, &mut 2_i32)));
/// assert_eq!(iterator.next(), Some((&2_usize, &mut 3_i32)));
/// assert_eq!(iterator.next(), Some((&3_usize, &mut 4_i32)));
/// assert_eq!(iterator.next(), None);
/// ```
pub struct IterMut<'a, K, V> {
    iter: map_inner::IterMut<'a, K, V>,
}

impl<'a, K, V> IterMut<'a, K, V> {
    /// Constructs a new mutable index map iterator from a mutable inner index map iterator.
    #[inline]
    const fn new(iter: map_inner::IterMut<'a, K, V>) -> Self {
        Self { iter, }
    }

    /// Returns a mutable slice of the remaining entries in the iterator.
    ///
    /// # Examples
    ///
    /// Slicing an iterator over a type-projected index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    /// ]);
    /// let mut iterator = proj_map.iter_mut();
    ///
    /// let _ = iterator.next().unwrap();
    /// let _ = iterator.next().unwrap();
    ///
    /// # #[cfg(feature = "nightly")]
    /// assert_eq!(iterator.as_slice_mut(), &[(2_usize, 3_i32), (3_usize, 4_i32)]);
    /// ```
    ///
    /// Slice an iterator over a type-erased index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    /// ]);
    /// let mut iterator = opaque_map.iter_mut::<usize, i32, RandomState, Global>();
    ///
    /// let _ = iterator.next().unwrap();
    /// let _ = iterator.next().unwrap();
    ///
    /// # #[cfg(feature = "nightly")]
    /// assert_eq!(iterator.as_slice_mut(), &[(2_usize, 3_i32), (3_usize, 4_i32)]);
    /// ```
    pub fn as_slice_mut(&'a mut self) -> &'a mut Slice<K, V> {
        Slice::from_slice_mut(self.iter.as_slice_mut())
    }

    /// Converts a mutable iterator into a mutable slice of the remaining entries in the iterator.
    ///
    /// # Examples
    ///
    /// Slicing an iterator over a type-projected index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    /// ]);
    /// let mut iterator = proj_map.iter_mut();
    ///
    /// let _ = iterator.next().unwrap();
    /// let _ = iterator.next().unwrap();
    ///
    /// let slice = iterator.into_slice_mut();
    ///
    /// assert_eq!(slice, &[(2_usize, 3_i32), (3_usize, 4_i32)]);
    /// ```
    ///
    /// Slice an iterator over a type-erased index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    /// ]);
    /// let mut iterator = opaque_map.iter_mut::<usize, i32, RandomState, Global>();
    ///
    /// let _ = iterator.next().unwrap();
    /// let _ = iterator.next().unwrap();
    ///
    /// let slice = iterator.into_slice_mut();
    ///
    /// assert_eq!(slice, &[(2_usize, 3_i32), (3_usize, 4_i32)]);
    /// ```
    pub fn into_slice_mut(self) -> &'a mut Slice<K, V> {
        Slice::from_slice_mut(self.iter.into_slice_mut())
    }
}

impl<'a, K, V> Iterator for IterMut<'a, K, V> {
    type Item = (&'a K, &'a mut V);

    fn next(&mut self) -> Option<Self::Item> {
        self.iter.next()
    }
}

impl<K, V> DoubleEndedIterator for IterMut<'_, K, V> {
    fn next_back(&mut self) -> Option<Self::Item> {
        self.iter.next_back()
    }

    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
        self.iter.nth_back(n)
    }
}

impl<K, V> ExactSizeIterator for IterMut<'_, K, V> {
    fn len(&self) -> usize {
        self.iter.len()
    }
}

impl<K, V> iter::FusedIterator for IterMut<'_, K, V> {}

impl<K, V> fmt::Debug for IterMut<'_, K, V>
where
    K: fmt::Debug,
    V: fmt::Debug,
{
    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Debug::fmt(&self.iter, formatter)
    }
}

impl<K, V> Default for IterMut<'_, K, V> {
    fn default() -> Self {
        Self { iter: Default::default() }
    }
}

/// A moving iterator over the entries of an index map.
///
/// Moving iterators are created by the [`TypedProjIndexMap::into_iter`] and
/// [`OpaqueIndexMap::into_iter`] methods.
///
/// # Examples
///
/// Moving the entries of a type-projected index map.
///
/// ```
/// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
/// # use opaque_index_map::TypedProjIndexMap;
/// # use opaque_hash::TypedProjBuildHasher;
/// # use opaque_alloc::TypedProjAlloc;
/// # use opaque_vec::TypedProjVec;
/// # use std::any::TypeId;
/// # use std::cmp::Ordering;
/// # use std::hash::RandomState;
/// #
/// # #[cfg(feature = "nightly")]
/// # use std::alloc::Global;
/// #
/// # #[cfg(not(feature = "nightly"))]
/// # use opaque_allocator_api::alloc::Global;
/// #
/// let proj_map = TypedProjIndexMap::from([
///     (0_usize, 1_i32),
///     (1_usize, 2_i32),
///     (2_usize, 3_i32),
///     (3_usize, 4_i32),
/// ]);
/// let mut iterator = proj_map.into_iter();
///
/// assert_eq!(iterator.next(), Some((0_usize, 1_i32)));
/// assert_eq!(iterator.next(), Some((1_usize, 2_i32)));
/// assert_eq!(iterator.next(), Some((2_usize, 3_i32)));
/// assert_eq!(iterator.next(), Some((3_usize, 4_i32)));
/// assert_eq!(iterator.next(), None);
/// ```
///
/// Moving the entries of a type-erased index map.
///
/// ```
/// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
/// # use opaque_index_map::OpaqueIndexMap;
/// # use opaque_hash::TypedProjBuildHasher;
/// # use opaque_alloc::TypedProjAlloc;
/// # use opaque_vec::TypedProjVec;
/// # use std::any::TypeId;
/// # use std::cmp::Ordering;
/// # use std::hash::RandomState;
/// #
/// # #[cfg(feature = "nightly")]
/// # use std::alloc::Global;
/// #
/// # #[cfg(not(feature = "nightly"))]
/// # use opaque_allocator_api::alloc::Global;
/// #
/// let opaque_map = OpaqueIndexMap::from([
///     (0_usize, 1_i32),
///     (1_usize, 2_i32),
///     (2_usize, 3_i32),
///     (3_usize, 4_i32),
/// ]);
/// let mut iterator = opaque_map.into_iter::<usize, i32, RandomState, Global>();
///
/// assert_eq!(iterator.next(), Some((0_usize, 1_i32)));
/// assert_eq!(iterator.next(), Some((1_usize, 2_i32)));
/// assert_eq!(iterator.next(), Some((2_usize, 3_i32)));
/// assert_eq!(iterator.next(), Some((3_usize, 4_i32)));
/// assert_eq!(iterator.next(), None);
/// ```
#[derive(Clone)]
pub struct IntoIter<K, V, A = alloc::Global>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    iter: map_inner::IntoIter<K, V, A>,
}

impl<K, V, A> IntoIter<K, V, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    /// Constructs new a moving iterator from an inner moving iterator.
    #[inline]
    const fn new(iter: map_inner::IntoIter<K, V, A>) -> Self {
        Self { iter, }
    }

    /// Returns a slice of the remaining entries in the moving iterator.
    ///
    /// # Examples
    ///
    /// Slicing a moving iterator over a type-projected index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map = TypedProjIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    /// ]);
    /// let mut iterator = proj_map.into_iter();
    ///
    /// assert_eq!(iterator.as_slice(), &[(0_usize, 1_i32), (1_usize, 2_i32), (2_usize, 3_i32), (3_usize, 4_i32)]);
    /// let _ = iterator.next().unwrap();
    /// assert_eq!(iterator.as_slice(), &[(1_usize, 2_i32), (2_usize, 3_i32), (3_usize, 4_i32)]);
    /// let _ = iterator.next().unwrap();
    /// assert_eq!(iterator.as_slice(), &[(2_usize, 3_i32), (3_usize, 4_i32)]);
    /// let _ = iterator.next().unwrap();
    /// assert_eq!(iterator.as_slice(), &[(3_usize, 4_i32)]);
    /// let _ = iterator.next().unwrap();
    /// assert!(iterator.as_slice().is_empty());
    /// ```
    ///
    /// Slice a moving iterator over a type-erased index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    /// ]);
    /// let mut iterator = opaque_map.into_iter::<usize, i32, RandomState, Global>();
    ///
    /// assert_eq!(iterator.as_slice(), &[(0_usize, 1_i32), (1_usize, 2_i32), (2_usize, 3_i32), (3_usize, 4_i32)]);
    /// let _ = iterator.next().unwrap();
    /// assert_eq!(iterator.as_slice(), &[(1_usize, 2_i32), (2_usize, 3_i32), (3_usize, 4_i32)]);
    /// let _ = iterator.next().unwrap();
    /// assert_eq!(iterator.as_slice(), &[(2_usize, 3_i32), (3_usize, 4_i32)]);
    /// let _ = iterator.next().unwrap();
    /// assert_eq!(iterator.as_slice(), &[(3_usize, 4_i32)]);
    /// let _ = iterator.next().unwrap();
    /// assert!(iterator.as_slice().is_empty());
    /// ```
    pub fn as_slice(&self) -> &Slice<K, V> {
        Slice::from_slice(self.iter.as_slice())
    }

    /// Returns a mutable slice of the remaining entries in the moving iterator.
    ///
    /// # Examples
    ///
    /// Slicing a moving iterator over a type-projected index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map = TypedProjIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    /// ]);
    /// let mut iterator = proj_map.into_iter();
    ///
    /// assert_eq!(iterator.as_mut_slice(), &[(0_usize, 1_i32), (1_usize, 2_i32), (2_usize, 3_i32), (3_usize, 4_i32)]);
    /// let _ = iterator.next().unwrap();
    /// assert_eq!(iterator.as_mut_slice(), &[(1_usize, 2_i32), (2_usize, 3_i32), (3_usize, 4_i32)]);
    /// let _ = iterator.next().unwrap();
    /// assert_eq!(iterator.as_mut_slice(), &[(2_usize, 3_i32), (3_usize, 4_i32)]);
    /// let _ = iterator.next().unwrap();
    /// assert_eq!(iterator.as_mut_slice(), &[(3_usize, 4_i32)]);
    /// let _ = iterator.next().unwrap();
    /// assert!(iterator.as_mut_slice().is_empty());
    /// ```
    ///
    /// Slice a moving iterator over a type-erased index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    /// ]);
    /// let mut iterator = opaque_map.into_iter::<usize, i32, RandomState, Global>();
    ///
    /// assert_eq!(iterator.as_mut_slice(), &[(0_usize, 1_i32), (1_usize, 2_i32), (2_usize, 3_i32), (3_usize, 4_i32)]);
    /// let _ = iterator.next().unwrap();
    /// assert_eq!(iterator.as_mut_slice(), &[(1_usize, 2_i32), (2_usize, 3_i32), (3_usize, 4_i32)]);
    /// let _ = iterator.next().unwrap();
    /// assert_eq!(iterator.as_mut_slice(), &[(2_usize, 3_i32), (3_usize, 4_i32)]);
    /// let _ = iterator.next().unwrap();
    /// assert_eq!(iterator.as_mut_slice(), &[(3_usize, 4_i32)]);
    /// let _ = iterator.next().unwrap();
    /// assert!(iterator.as_mut_slice().is_empty());
    /// ```
    pub fn as_mut_slice(&mut self) -> &mut Slice<K, V> {
        Slice::from_slice_mut(self.iter.as_mut_slice())
    }
}

impl<K, V, A> Iterator for IntoIter<K, V, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    type Item = (K, V);

    fn next(&mut self) -> Option<Self::Item> {
        self.iter.next()
    }
}

impl<K, V, A> DoubleEndedIterator for IntoIter<K, V, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    fn next_back(&mut self) -> Option<Self::Item> {
        self.iter.next_back()
    }

    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
        self.iter.nth_back(n)
    }
}

impl<K, V, A> ExactSizeIterator for IntoIter<K, V, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    fn len(&self) -> usize {
        self.iter.len()
    }
}

impl<K, V, A> iter::FusedIterator for IntoIter<K, V, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
}

impl<K, V, A> fmt::Debug for IntoIter<K, V, A>
where
    K: any::Any + fmt::Debug,
    V: any::Any + fmt::Debug,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Debug::fmt(&self.iter, formatter)
    }
}

impl<K, V, A> Default for IntoIter<K, V, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync + Default,
{
    fn default() -> Self {
        Self {
            iter: Default::default(),
        }
    }
}

/// An iterator that drains a slice of an index map, then splices a new slice in place of the
/// drained slice.
///
/// If an entry in the new slice has the same key as an entry in the remaining
/// entries of the index map, that entry is updated with the new value from the splicing iterator.
///
/// Splicing iterators are created by the [`TypedProjIndexMap::splice`] and
/// [`OpaqueIndexMap::splice`] methods.
///
/// # Examples
///
/// Using a splicing iterator on a type-projected index map.
///
/// ```
/// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
/// # use opaque_index_map::TypedProjIndexMap;
/// # use opaque_hash::TypedProjBuildHasher;
/// # use opaque_alloc::TypedProjAlloc;
/// # use opaque_vec::TypedProjVec;
/// # use std::any::TypeId;
/// # use std::cmp::Ordering;
/// # use std::hash::RandomState;
/// #
/// # #[cfg(feature = "nightly")]
/// # use std::alloc::Global;
/// #
/// # #[cfg(not(feature = "nightly"))]
/// # use opaque_allocator_api::alloc::Global;
/// #
/// let proj_map = TypedProjIndexMap::from([
///     (0_usize, 1_i32),
///     (1_usize, 2_i32),
///     (2_usize, 3_i32),
///     (3_usize, 4_i32),
///     (4_usize, 5_i32),
/// ]);
/// let mut result = proj_map.clone();
/// let splice_data = [
///     (4_usize, i32::MAX),
///     (5_usize, 8_i32),
///     (6_usize, 9_i32),
///     (7_usize, 10_i32),
///     (8_usize, 11_i32),
/// ];
/// let expected = TypedProjIndexMap::from([
///     (0_usize, 1_i32),
///     (5_usize, 8_i32),
///     (6_usize, 9_i32),
///     (7_usize, 10_i32),
///     (8_usize, 11_i32),
///     (4_usize, i32::MAX),
/// ]);
/// result.splice(1..4, splice_data);
///
/// assert_eq!(result.as_slice(), expected.as_slice());
/// ```
///
/// Using a splicing iterator on a type-erased index map.
/// ```
/// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
/// # use opaque_index_map::OpaqueIndexMap;
/// # use opaque_hash::TypedProjBuildHasher;
/// # use opaque_alloc::TypedProjAlloc;
/// # use opaque_vec::TypedProjVec;
/// # use std::any::TypeId;
/// # use std::cmp::Ordering;
/// # use std::hash::RandomState;
/// #
/// # #[cfg(feature = "nightly")]
/// # use std::alloc::Global;
/// #
/// # #[cfg(not(feature = "nightly"))]
/// # use opaque_allocator_api::alloc::Global;
/// #
/// let opaque_map = OpaqueIndexMap::from([
///     (0_usize, 1_i32),
///     (1_usize, 2_i32),
///     (2_usize, 3_i32),
///     (3_usize, 4_i32),
///     (4_usize, 5_i32),
/// ]);
/// let mut result = opaque_map.clone::<usize, i32, RandomState, Global>();
/// let splice_data = [
///     (4_usize, i32::MAX),
///     (5_usize, 8_i32),
///     (6_usize, 9_i32),
///     (7_usize, 10_i32),
///     (8_usize, 11_i32),
/// ];
/// let expected = OpaqueIndexMap::from([
///     (0_usize, 1_i32),
///     (5_usize, 8_i32),
///     (6_usize, 9_i32),
///     (7_usize, 10_i32),
///     (8_usize, 11_i32),
///     (4_usize, i32::MAX),
/// ]);
/// result.splice::<_, _, usize, i32, RandomState, Global>(1..4, splice_data);
///
/// assert_eq!(result.as_slice::<usize, i32, RandomState, Global>(), expected.as_slice::<usize, i32, RandomState, Global>());
/// ```
#[cfg(feature = "std")]
pub struct Splice<'a, I, K, V, S = hash::RandomState, A = alloc::Global>
where
    I: Iterator<Item = (K, V)>,
    K: any::Any + hash::Hash + Eq,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    inner: map_inner::Splice<'a, I, K, V, S, A>,
}

#[cfg(not(feature = "std"))]
pub struct Splice<'a, I, K, V, S, A = alloc::Global>
where
    I: Iterator<Item = (K, V)>,
    K: any::Any + hash::Hash + Eq,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    inner: map_inner::Splice<'a, I, K, V, S, A>,
}

impl<'a, I, K, V, S, A> Splice<'a, I, K, V, S, A>
where
    I: Iterator<Item = (K, V)>,
    K: any::Any + hash::Hash + Eq,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync + Clone,
{
    /// Constructs a new splicing iterator.
    #[inline]
    const fn new<R>(inner: map_inner::Splice<'a, I, K, V, S, A>) -> Self
    where
        R: ops::RangeBounds<usize>,
    {
        Self { inner, }
    }
}

impl<I, K, V, S, A> Iterator for Splice<'_, I, K, V, S, A>
where
    I: Iterator<Item = (K, V)>,
    K: any::Any + hash::Hash + Eq,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    type Item = (K, V);

    fn next(&mut self) -> Option<Self::Item> {
        self.inner.next()
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        self.inner.size_hint()
    }
}

impl<I, K, V, S, A> DoubleEndedIterator for Splice<'_, I, K, V, S, A>
where
    I: Iterator<Item = (K, V)>,
    K: any::Any + hash::Hash + Eq,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    fn next_back(&mut self) -> Option<Self::Item> {
        self.inner.next_back()
    }
}

impl<I, K, V, S, A> ExactSizeIterator for Splice<'_, I, K, V, S, A>
where
    I: Iterator<Item = (K, V)>,
    K: any::Any + hash::Hash + Eq,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    fn len(&self) -> usize {
        self.inner.len()
    }
}

impl<I, K, V, S, A> iter::FusedIterator for Splice<'_, I, K, V, S, A>
where
    I: Iterator<Item = (K, V)>,
    K: any::Any + hash::Hash + Eq,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
}

impl<I, K, V, S, A> fmt::Debug for Splice<'_, I, K, V, S, A>
where
    I: fmt::Debug + Iterator<Item = (K, V)>,
    K: any::Any + fmt::Debug + hash::Hash + Eq,
    V: any::Any + fmt::Debug,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Debug::fmt(&self.inner, formatter)
    }
}

/// A view into a single entry in a [`TypedProjIndexMap`] or an [`OpaqueIndexMap`], which may be
/// occupied or vacant.
///
/// Entries are obtained by the [`TypedProjIndexMap::entry`] and [`OpaqueIndexMap::entry`] methods.
///
/// # Examples
///
/// ```
/// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
/// # use opaque_index_map::TypedProjIndexMap;
/// # use opaque_hash::TypedProjBuildHasher;
/// # use opaque_alloc::TypedProjAlloc;
/// # use opaque_vec::TypedProjVec;
/// # use std::any::TypeId;
/// # use std::hash::RandomState;
/// #
/// # #[cfg(feature = "nightly")]
/// # use std::alloc::Global;
/// #
/// # #[cfg(not(feature = "nightly"))]
/// # use opaque_allocator_api::alloc::Global;
/// #
/// let mut proj_map: TypedProjIndexMap<&str, i32> = TypedProjIndexMap::from([
///     ("foo",  1_i32),
///     ("bar",  2_i32),
///     ("baz",  4_i32),
///     ("quux", 8_i32),
/// ]);
///
/// assert_eq!(proj_map.len(), 4);
///
/// assert_eq!(proj_map.entry("foo").key(), &"foo");
/// assert_eq!(proj_map.entry("bar").key(), &"bar");
/// assert_eq!(proj_map.entry("baz").key(), &"baz");
/// assert_eq!(proj_map.entry("quux").key(), &"quux");
///
/// // Vacant entries also return their keys.
/// assert_eq!(proj_map.entry("quuz").key(), &"quuz");
/// assert_eq!(proj_map.entry("garply").key(), &"garply");
///
/// assert_eq!(proj_map.entry("foo").index(), 0);
/// assert_eq!(proj_map.entry("bar").index(), 1);
/// assert_eq!(proj_map.entry("baz").index(), 2);
/// assert_eq!(proj_map.entry("quux").index(), 3);
///
/// // Vacant entries have the length of the index map as their index.
/// assert_eq!(proj_map.entry("quuz").index(), proj_map.len());
/// assert_eq!(proj_map.entry("garply").index(), proj_map.len());
///
/// assert_eq!(proj_map.len(), 4);
///
/// proj_map.entry("quuz").insert_entry(16_i32);
///
/// assert_eq!(proj_map.len(), 5);
///
/// assert_eq!(proj_map.entry("quuz").index(), 4);
/// assert_eq!(proj_map.entry("garply").index(), 5);
/// ```
pub enum Entry<'a, K, V, A = alloc::Global>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    /// An occupied entry.
    Occupied(OccupiedEntry<'a, K, V, A>),
    /// A vacant entry.
    Vacant(VacantEntry<'a, K, V, A>),
}

impl<'a, K, V, A> Entry<'a, K, V, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    /// Returns the storage index of the entry in the index map.
    ///
    /// If the entry is occupied, this method returns the index where the entry is actually stored
    /// in the index map. If the entry is vacant, this method returns the index where the entry
    /// would be stored if the entry was inserted into the index map.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo", 1_i32),
    ///     ("bar", 2_i32),
    ///     ("baz", 3_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.entry("foo").index(), 0);
    /// assert_eq!(proj_map.entry("bar").index(), 1);
    /// assert_eq!(proj_map.entry("baz").index(), 2);
    ///
    /// assert_eq!(proj_map.entry("quux").index(), 3);
    /// ```
    pub fn index(&self) -> usize {
        match *self {
            Entry::Occupied(ref entry) => entry.index(),
            Entry::Vacant(ref entry) => entry.index(),
        }
    }

    /// Sets the value of the entry (after inserting the entry if it is vacant), and returning an
    /// [`OccupiedEntry`].
    ///
    /// This method behaves as follows:
    ///
    /// * If the entry is occupied, this method replaces the old value with the new value in the
    ///   entry, and returns an occupied entry. The entry retains its position in the storage order
    ///   of the index map.
    /// * If the entry is vacant, the entry is appended to the end of the map, so the resulting
    ///   entry is in last place in the storage order, and the method returns an occupied entry
    ///   containing the value `value` and the key from the original vacant entry.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::new();
    /// let new_entry = proj_map.entry("foo");
    /// let occupied_entry = new_entry.insert_entry(1_i32);
    ///
    /// assert_eq!(occupied_entry.index(), 0);
    /// assert_eq!(occupied_entry.key(), &"foo");
    /// assert_eq!(occupied_entry.get(), &1_i32);
    /// ```
    pub fn insert_entry(self, value: V) -> OccupiedEntry<'a, K, V, A> {
        match self {
            Entry::Occupied(mut entry) => {
                entry.insert(value);
                entry
            }
            Entry::Vacant(entry) => entry.insert_entry(value),
        }
    }

    /// Ensures a value is in the entry by inserting the default value if it is empty, and returns
    /// a mutable reference to the value in the entry.
    ///
    /// If the entry is occupied, this method does nothing and returns a mutable reference to its
    /// value. If the entry is vacant, this method inserts the provided default value and returns a
    /// mutable reference to the entry's value.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::new();
    /// proj_map.entry("foo").or_insert(3_i32);
    ///
    /// assert_eq!(proj_map["foo"], 3_i32);
    ///
    /// // This does nothing since the entry with key `"foo"` already exists in the map.
    /// proj_map.entry("foo").or_insert(10_i32);
    ///
    /// assert_ne!(proj_map["foo"], 10_32);
    /// assert_eq!(proj_map["foo"], 3_i32);
    /// ```
    pub fn or_insert(self, default: V) -> &'a mut V {
        match self {
            Entry::Occupied(entry) => entry.into_mut(),
            Entry::Vacant(entry) => entry.insert(default),
        }
    }

    /// Ensures a value is in the entry by inserting the result of the default function if it is
    /// empty, and returns a mutable reference to the value in the entry.
    ///
    /// This method behaves as follows:
    ///
    /// * If the entry is occupied, this method does nothing and returns a mutable reference to its
    ///   value.
    /// * If the entry is vacant, this method inserts the result of calling the provided function
    ///   `call` and returns a mutable reference to the entry's value.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::new();
    /// let default_value = "garply";
    /// let another_value = "corge";
    ///
    /// proj_map.entry("foo").or_insert_with(|| default_value);
    ///
    /// assert_eq!(proj_map["foo"], default_value);
    ///
    /// // This does nothing since the entry with key `"foo"` already exists in the map.
    /// proj_map.entry("foo").or_insert_with(|| another_value);
    ///
    /// assert_ne!(proj_map["foo"], another_value);
    /// assert_eq!(proj_map["foo"], default_value);
    /// ```
    pub fn or_insert_with<F>(self, call: F) -> &'a mut V
    where
        F: FnOnce() -> V,
    {
        match self {
            Entry::Occupied(entry) => entry.into_mut(),
            Entry::Vacant(entry) => entry.insert(call()),
        }
    }

    /// Ensures a value is in the entry, using the provided default function if necessary.
    ///
    /// This method behaves as follows:
    ///
    /// * If the entry is occupied, this method does nothing, and returns a mutable reference to its
    ///   value.
    /// * Is the entry is vacant, this method inserts the result of the default function.
    ///
    /// This method allows for generating key-derived values for insertion by providing the default
    /// function a reference to the key that was moved during the [`entry`] method call.
    ///
    /// [`entry`]: TypedProjIndexMap::entry
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::new();
    /// let default_value = "garply";
    /// let another_value = "corge";
    /// let func = |key: &&str| if key == &"foo" { default_value } else { another_value };
    ///
    /// proj_map.entry("foo").or_insert_with_key(func);
    ///
    /// assert_eq!(proj_map["foo"], default_value);
    /// assert_ne!(proj_map["foo"], another_value);
    ///
    /// proj_map.entry("bar").or_insert_with_key(func);
    ///
    /// assert_eq!(proj_map["bar"], another_value);
    /// assert_ne!(proj_map["bar"], default_value);
    /// ```
    pub fn or_insert_with_key<F>(self, call: F) -> &'a mut V
    where
        F: FnOnce(&K) -> V,
    {
        match self {
            Entry::Occupied(entry) => entry.into_mut(),
            Entry::Vacant(entry) => {
                let value = call(&entry.key());
                entry.insert(value)
            }
        }
    }

    /// Gets a reference to the entry's key in the index map.
    ///
    /// This method behaves as follows:
    ///
    /// * If the entry is occupied, this method returns the key stored in the index map for that
    ///   entry.
    /// * If the entry is vacant, this method returns the key that was used to search for the entry
    ///   in the index map.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo", 1_i32),
    ///     ("bar", 2_i32),
    ///     ("baz", 3_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.entry("foo").key(), &"foo");
    /// assert_eq!(proj_map.entry("bar").key(), &"bar");
    /// assert_eq!(proj_map.entry("baz").key(), &"baz");
    ///
    /// // Vacant entries have keys too.
    /// assert_eq!(proj_map.entry("quux").key(), &"quux");
    /// ```
    pub fn key(&self) -> &K {
        match *self {
            Entry::Occupied(ref entry) => entry.key(),
            Entry::Vacant(ref entry) => entry.key(),
        }
    }

    /// Provides in place mutable access to an occupied entry before any potential insertions into
    /// the index map.
    ///
    /// If the entry `self` is vacant, this method does nothing.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::new();
    /// proj_map.entry("foo").and_modify(|e| { *e += 1 }).or_insert(42);
    ///
    /// assert_eq!(proj_map["foo"], 42);
    ///
    /// proj_map.entry("foo").and_modify(|e| { *e += 1 }).or_insert(42);
    ///
    /// assert_eq!(proj_map["foo"], 43);
    ///
    /// // The `and_modify` method has no effect on vacant entries.
    /// proj_map.entry("bar").and_modify(|e| *e = 55).or_insert(44);
    ///
    /// assert_eq!(proj_map["bar"], 44);
    /// ```
    pub fn and_modify<F>(mut self, f: F) -> Self
    where
        F: FnOnce(&mut V),
    {
        if let Entry::Occupied(entry) = &mut self {
            f(entry.get_mut());
        }

        self
    }

    /// Ensures that a value is in the entry by inserting the default value if necessary.
    ///
    /// This method behaves as follows:
    ///
    /// * If the entry is vacant, this method inserts the default value and returns a mutable
    ///   reference to the value in the entry.
    /// * If the entry is occupied, the method does nothing and returns a mutable reference to the
    ///   value in the entry.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// # #[derive(Copy, Clone, Debug, PartialEq, Eq)]
    /// enum SpatialPartition {
    ///     QuadTree,
    ///     OctTree,
    ///     BVH,
    ///     Grid,
    /// }
    /// # impl Default for SpatialPartition {
    /// #     fn default() -> Self {
    /// #         SpatialPartition::QuadTree
    /// #     }
    /// # }
    /// #
    ///
    /// let mut proj_map: TypedProjIndexMap<&str, SpatialPartition> = TypedProjIndexMap::new();
    ///
    /// assert!(!proj_map.contains_key("foo"));
    ///
    /// proj_map.entry("foo").or_default();
    ///
    /// assert!(proj_map.contains_key("foo"));
    ///
    /// assert_eq!(proj_map["foo"], SpatialPartition::default());
    /// ```
    pub fn or_default(self) -> &'a mut V
    where
        V: Default,
    {
        match self {
            Entry::Occupied(entry) => entry.into_mut(),
            Entry::Vacant(entry) => entry.insert(V::default()),
        }
    }
}

impl<K, V, A> fmt::Debug for Entry<'_, K, V, A>
where
    K: any::Any + fmt::Debug,
    V: any::Any + fmt::Debug,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut tuple = formatter.debug_tuple("Entry");
        match self {
            Entry::Vacant(v) => tuple.field(v),
            Entry::Occupied(o) => tuple.field(o),
        };
        tuple.finish()
    }
}

/// A view into an occupied entry in an [`TypedProjIndexMap`] or [`OpaqueIndexMap`]. It is part of
/// the [`Entry`] sum type.
pub struct OccupiedEntry<'a, K, V, A = alloc::Global>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    inner: map_inner::OccupiedEntry<'a, K, V, A>,
}

impl<'a, K, V, A> OccupiedEntry<'a, K, V, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{

    /// Constructs a new occupied entry.
    #[inline]
    pub(crate) const fn new(inner: map_inner::OccupiedEntry<'a, K, V, A>) -> Self {
        Self { inner, }
    }

    /// Returns the storage index of the occupied entry in the index map.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::map::{TypedProjIndexMap, Entry, OccupiedEntry};
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// fn into_occupied<K: Any, V: Any>(entry: Entry<'_, K, V>) -> OccupiedEntry<'_, K, V> {
    ///     match entry {
    ///         Entry::Occupied(occupied_entry) => occupied_entry,
    ///         _ => panic!("This method only destructures occupied entries")
    ///     }
    /// }
    ///
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  3_i32),
    ///     ("quux", 4_i32),
    /// ]);
    ///
    /// assert_eq!(into_occupied(proj_map.entry("foo")).index(),  0);
    /// assert_eq!(into_occupied(proj_map.entry("bar")).index(),  1);
    /// assert_eq!(into_occupied(proj_map.entry("baz")).index(),  2);
    /// assert_eq!(into_occupied(proj_map.entry("quux")).index(), 3);
    /// ```
    #[inline]
    pub fn index(&self) -> usize {
        self.inner.index()
    }

    /// Gets a reference to the key stored in the occupied entry in the index map.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::map::{TypedProjIndexMap, Entry, OccupiedEntry};
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// fn into_occupied<K: Any, V: Any>(entry: Entry<'_, K, V>) -> OccupiedEntry<'_, K, V> {
    ///     match entry {
    ///         Entry::Occupied(occupied_entry) => occupied_entry,
    ///         _ => panic!("This method only destructures occupied entries")
    ///     }
    /// }
    ///
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  3_i32),
    ///     ("quux", 4_i32),
    /// ]);
    ///
    /// assert_eq!(into_occupied(proj_map.entry("foo")).key(),  &"foo");
    /// assert_eq!(into_occupied(proj_map.entry("bar")).key(),  &"bar");
    /// assert_eq!(into_occupied(proj_map.entry("baz")).key(),  &"baz");
    /// assert_eq!(into_occupied(proj_map.entry("quux")).key(), &"quux");
    /// ```
    pub fn key(&self) -> &K {
        self.inner.key()
    }

    /*
    pub(crate) fn key_mut(&mut self) -> &mut K {
        self.inner.key_mut()
    }
    */

    /// Gets a reference to the occupied entry's value in the index map.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::map::{TypedProjIndexMap, Entry, OccupiedEntry};
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// fn into_occupied<K: Any, V: Any>(entry: Entry<'_, K, V>) -> OccupiedEntry<'_, K, V> {
    ///     match entry {
    ///         Entry::Occupied(occupied_entry) => occupied_entry,
    ///         _ => panic!("This method only destructures occupied entries")
    ///     }
    /// }
    ///
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  3_i32),
    ///     ("quux", 4_i32),
    /// ]);
    ///
    /// assert_eq!(into_occupied(proj_map.entry("foo")).get(),  &1_i32);
    /// assert_eq!(into_occupied(proj_map.entry("bar")).get(),  &2_i32);
    /// assert_eq!(into_occupied(proj_map.entry("baz")).get(),  &3_i32);
    /// assert_eq!(into_occupied(proj_map.entry("quux")).get(), &4_i32);
    /// ```
    pub fn get(&self) -> &V {
        self.inner.get()
    }

    /// Gets a mutable reference to the occupied entry's value in the index map.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::map::{TypedProjIndexMap, Entry, OccupiedEntry};
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// fn into_occupied<K: Any, V: Any>(entry: Entry<'_, K, V>) -> OccupiedEntry<'_, K, V> {
    ///     match entry {
    ///         Entry::Occupied(occupied_entry) => occupied_entry,
    ///         _ => panic!("This method only destructures occupied entries")
    ///     }
    /// }
    ///
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  3_i32),
    ///     ("quux", 4_i32),
    /// ]);
    ///
    /// assert_eq!(into_occupied(proj_map.entry("foo")).get_mut(),  &mut 1_i32);
    /// assert_eq!(into_occupied(proj_map.entry("bar")).get_mut(),  &mut 2_i32);
    /// assert_eq!(into_occupied(proj_map.entry("baz")).get_mut(),  &mut 3_i32);
    /// assert_eq!(into_occupied(proj_map.entry("quux")).get_mut(), &mut 4_i32);
    /// ```
    pub fn get_mut(&mut self) -> &mut V {
        self.inner.get_mut()
    }

    /// Converts the [`OccupiedEntry`] into a mutable reference to the value in the entry
    /// with a lifetime bound to the index map itself.
    ///
    /// Use [`get_mut`] to get multiple references to the occupied entry.
    ///
    /// [`get_mut`]: OccupiedEntry::get_mut
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::map::{TypedProjIndexMap, Entry, OccupiedEntry};
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// fn into_occupied<K: Any, V: Any>(entry: Entry<'_, K, V>) -> OccupiedEntry<'_, K, V> {
    ///     match entry {
    ///         Entry::Occupied(occupied_entry) => occupied_entry,
    ///         _ => panic!("This method only destructures occupied entries")
    ///     }
    /// }
    ///
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  3_i32),
    ///     ("quux", 4_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((0, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("bar"),  Some((1, &"bar",  &2_i32)));
    /// assert_eq!(proj_map.get_full("baz"),  Some((2, &"baz",  &3_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((3, &"quux", &4_i32)));
    /// {
    ///     let mut occupied_entry = into_occupied(proj_map.entry("bar"));
    ///     let result = occupied_entry.into_mut();
    ///
    ///     assert_eq!(result, &2_i32);
    ///
    ///     *result = i32::MAX;
    /// }
    /// assert_eq!(into_occupied(proj_map.entry("bar")).get(), &i32::MAX);
    /// ```
    pub fn into_mut(self) -> &'a mut V {
        self.inner.into_mut()
    }

    /// Sets the value of the occupied entry to a new value, and returns the old value.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::map::{TypedProjIndexMap, Entry, OccupiedEntry};
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// fn into_occupied<K: Any, V: Any>(entry: Entry<'_, K, V>) -> OccupiedEntry<'_, K, V> {
    ///     match entry {
    ///         Entry::Occupied(occupied_entry) => occupied_entry,
    ///         _ => panic!("This method only destructures occupied entries")
    ///     }
    /// }
    ///
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  3_i32),
    ///     ("quux", 4_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((0, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("bar"),  Some((1, &"bar",  &2_i32)));
    /// assert_eq!(proj_map.get_full("baz"),  Some((2, &"baz",  &3_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((3, &"quux", &4_i32)));
    ///
    /// let mut occupied_entry = into_occupied(proj_map.entry("bar"));
    /// let result = occupied_entry.insert(i32::MAX);
    ///
    /// assert_eq!(result, 2_i32);
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((0, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("bar"),  Some((1, &"bar",  &i32::MAX)));
    /// assert_eq!(proj_map.get_full("baz"),  Some((2, &"baz",  &3_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((3, &"quux", &4_i32)));
    /// ```
    pub fn insert(&mut self, value: V) -> V {
        mem::replace(self.get_mut(), value)
    }

    /// Removes the occupied entry from the index map, and returns the value of the entry.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::map::{TypedProjIndexMap, Entry, OccupiedEntry};
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// fn into_occupied<K: Any, V: Any>(entry: Entry<'_, K, V>) -> OccupiedEntry<'_, K, V> {
    ///     match entry {
    ///         Entry::Occupied(occupied_entry) => occupied_entry,
    ///         _ => panic!("This method only destructures occupied entries")
    ///     }
    /// }
    ///
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  3_i32),
    ///     ("quux", 4_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((0, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("bar"),  Some((1, &"bar",  &2_i32)));
    /// assert_eq!(proj_map.get_full("baz"),  Some((2, &"baz",  &3_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((3, &"quux", &4_i32)));
    ///
    /// let occupied_entry = into_occupied(proj_map.entry("bar"));
    /// let result = occupied_entry.swap_remove();
    ///
    /// assert_eq!(result, 2_i32);
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((0, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("baz"),  Some((2, &"baz",  &3_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((1, &"quux", &4_i32)));
    /// ```
    pub fn swap_remove(self) -> V {
        self.swap_remove_entry().1
    }

    /// Removes the occupied entry from the index map, and returns the value of the entry.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::map::{TypedProjIndexMap, Entry, OccupiedEntry};
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// fn into_occupied<K: Any, V: Any>(entry: Entry<'_, K, V>) -> OccupiedEntry<'_, K, V> {
    ///     match entry {
    ///         Entry::Occupied(occupied_entry) => occupied_entry,
    ///         _ => panic!("This method only destructures occupied entries")
    ///     }
    /// }
    ///
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  3_i32),
    ///     ("quux", 4_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((0, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("bar"),  Some((1, &"bar",  &2_i32)));
    /// assert_eq!(proj_map.get_full("baz"),  Some((2, &"baz",  &3_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((3, &"quux", &4_i32)));
    ///
    /// let occupied_entry = into_occupied(proj_map.entry("baz"));
    /// let result = occupied_entry.shift_remove();
    ///
    /// assert_eq!(result, 3_i32);
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((0, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("bar"),  Some((1, &"bar",  &2_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((2, &"quux", &4_i32)));
    /// ```
    pub fn shift_remove(self) -> V {
        self.shift_remove_entry().1
    }

    /// Removes the occupied entry from the index map, and returns the key-value pair for the entry.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::map::{TypedProjIndexMap, Entry, OccupiedEntry};
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// fn into_occupied<K: Any, V: Any>(entry: Entry<'_, K, V>) -> OccupiedEntry<'_, K, V> {
    ///     match entry {
    ///         Entry::Occupied(occupied_entry) => occupied_entry,
    ///         _ => panic!("This method only destructures occupied entries")
    ///     }
    /// }
    ///
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  3_i32),
    ///     ("quux", 4_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((0, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("bar"),  Some((1, &"bar",  &2_i32)));
    /// assert_eq!(proj_map.get_full("baz"),  Some((2, &"baz",  &3_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((3, &"quux", &4_i32)));
    ///
    /// let occupied_entry = into_occupied(proj_map.entry("bar"));
    /// let result = occupied_entry.swap_remove_entry();
    ///
    /// assert_eq!(result, ("bar", 2_i32));
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((0, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("baz"),  Some((2, &"baz",  &3_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((1, &"quux", &4_i32)));
    /// ```
    pub fn swap_remove_entry(self) -> (K, V) {
        self.inner.swap_remove_entry()
    }

    /// Removes the occupied entry from the index map, and returns the key-value pair for the entry.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::map::{TypedProjIndexMap, Entry, OccupiedEntry};
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// fn into_occupied<K: Any, V: Any>(entry: Entry<'_, K, V>) -> OccupiedEntry<'_, K, V> {
    ///     match entry {
    ///         Entry::Occupied(occupied_entry) => occupied_entry,
    ///         _ => panic!("This method only destructures occupied entries")
    ///     }
    /// }
    ///
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  3_i32),
    ///     ("quux", 4_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((0, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("bar"),  Some((1, &"bar",  &2_i32)));
    /// assert_eq!(proj_map.get_full("baz"),  Some((2, &"baz",  &3_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((3, &"quux", &4_i32)));
    ///
    /// let occupied_entry = into_occupied(proj_map.entry("baz"));
    /// let result = occupied_entry.shift_remove_entry();
    ///
    /// assert_eq!(result, ("baz", 3_i32));
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((0, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("bar"),  Some((1, &"bar",  &2_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((2, &"quux", &4_i32)));
    /// ```
    pub fn shift_remove_entry(self) -> (K, V) {
        self.inner.shift_remove_entry()
    }

    /// Moves the storage position of an occupied entry from one index to another by shifting all
    /// other pairs in between.
    ///
    /// This method behaves as follows:
    ///
    /// * If `self.index() < to`, the other pairs will shift up while the targeted pair moves down.
    /// * If `self.index() > to`, the other pairs will shift down while the targeted pair moves up.
    ///
    /// # Panics
    ///
    /// This method panics if `to` is out of bounds.
    ///
    /// # Examples
    ///
    /// Moving an entry to an index where `self.index() > to`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::map::{TypedProjIndexMap, Entry, OccupiedEntry};
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// fn into_occupied<K: Any, V: Any>(entry: Entry<'_, K, V>) -> OccupiedEntry<'_, K, V> {
    ///     match entry {
    ///         Entry::Occupied(occupied_entry) => occupied_entry,
    ///         _ => panic!("This method only destructures occupied entries")
    ///     }
    /// }
    ///
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  3_i32),
    ///     ("quux", 4_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((0, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("bar"),  Some((1, &"bar",  &2_i32)));
    /// assert_eq!(proj_map.get_full("baz"),  Some((2, &"baz",  &3_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((3, &"quux", &4_i32)));
    ///
    /// let occupied_entry = into_occupied(proj_map.entry("foo"));
    /// occupied_entry.move_index(3);
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((3, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("bar"),  Some((0, &"bar",  &2_i32)));
    /// assert_eq!(proj_map.get_full("baz"),  Some((1, &"baz",  &3_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((2, &"quux", &4_i32)));
    /// ```
    ///
    /// Moving an entry to an index where `self.index() < to`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::map::{TypedProjIndexMap, Entry, OccupiedEntry};
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// fn into_occupied<K: Any, V: Any>(entry: Entry<'_, K, V>) -> OccupiedEntry<'_, K, V> {
    ///     match entry {
    ///         Entry::Occupied(occupied_entry) => occupied_entry,
    ///         _ => panic!("This method only destructures occupied entries")
    ///     }
    /// }
    ///
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  3_i32),
    ///     ("quux", 4_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((0, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("bar"),  Some((1, &"bar",  &2_i32)));
    /// assert_eq!(proj_map.get_full("baz"),  Some((2, &"baz",  &3_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((3, &"quux", &4_i32)));
    ///
    /// let occupied_entry = into_occupied(proj_map.entry("baz"));
    /// occupied_entry.move_index(0);
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((1, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("bar"),  Some((2, &"bar",  &2_i32)));
    /// assert_eq!(proj_map.get_full("baz"),  Some((0, &"baz",  &3_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((3, &"quux", &4_i32)));
    /// ```
    #[track_caller]
    pub fn move_index(self, to: usize) {
        self.inner.move_index(to);
    }

    /// Swaps the position of the occupied entry with the entry located at another storage index in
    /// the index map.
    ///
    /// # Panics
    ///
    /// This method panics if `other` is out of bounds.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::map::{TypedProjIndexMap, Entry, OccupiedEntry};
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// fn into_occupied<K: Any, V: Any>(entry: Entry<'_, K, V>) -> OccupiedEntry<'_, K, V> {
    ///     match entry {
    ///         Entry::Occupied(occupied_entry) => occupied_entry,
    ///         _ => panic!("This method only destructures occupied entries")
    ///     }
    /// }
    ///
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo", 1_i32),
    ///     ("bar", 2_i32),
    ///     ("baz", 3_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_full("foo"), Some((0, &"foo", &1_i32)));
    /// assert_eq!(proj_map.get_full("baz"), Some((2, &"baz", &3_i32)));
    ///
    /// let occupied_entry = into_occupied(proj_map.entry("foo"));
    /// occupied_entry.swap_indices(2);
    ///
    /// assert_eq!(proj_map.get_full("foo"), Some((2, &"foo", &1_i32)));
    /// assert_eq!(proj_map.get_full("baz"), Some((0, &"baz", &3_i32)));
    /// ```
    #[track_caller]
    pub fn swap_indices(self, other: usize) {
        self.inner.swap_indices(other);
    }
}

impl<K, V, A> fmt::Debug for OccupiedEntry<'_, K, V, A>
where
    K: any::Any + fmt::Debug,
    V: any::Any + fmt::Debug,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
        formatter.debug_struct("OccupiedEntry")
            .field("key", self.key())
            .field("value", self.get())
            .finish()
    }
}

impl<'a, K, V, A> From<IndexedEntry<'a, K, V, A>> for OccupiedEntry<'a, K, V, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    fn from(other: IndexedEntry<'a, K, V, A>) -> Self {
        Self::new(map_inner::OccupiedEntry::from(other.inner))
    }
}

/// A view into a vacant entry in an [`TypedProjIndexMap`] or [`OpaqueIndexMap`]. It is part of
/// the [`Entry`] sum type.
pub struct VacantEntry<'a, K, V, A = alloc::Global>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    inner: map_inner::VacantEntry<'a, K, V, A>,
}

impl<'a, K, V, A> VacantEntry<'a, K, V, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    /// Constructs a new vacant entry.
    #[inline]
    const fn new(inner: map_inner::VacantEntry<'a, K, V, A>) -> Self {
        Self { inner, }
    }

    /// Returns the storage index the entry would have when inserted into the index map.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::map::{TypedProjIndexMap, Entry, VacantEntry};
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// fn into_vacant<K: Any, V: Any>(entry: Entry<'_, K, V>) -> VacantEntry<'_, K, V> {
    ///     match entry {
    ///         Entry::Vacant(vacant_entry) => vacant_entry,
    ///         _ => panic!("This method only destructures vacant entries")
    ///     }
    /// }
    ///
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  3_i32),
    ///     ("quux", 4_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get("foo"),  Some(&1_i32));
    /// assert_eq!(proj_map.get("bar"),  Some(&2_i32));
    /// assert_eq!(proj_map.get("baz"),  Some(&3_i32));
    /// assert_eq!(proj_map.get("quux"), Some(&4_i32));
    ///
    /// let vacant_entry = into_vacant(proj_map.entry("corge"));
    ///
    /// assert_eq!(vacant_entry.index(), 4);
    /// ```
    pub fn index(&self) -> usize {
        self.inner.index()
    }

    /// Gets a reference to the key that would be used when inserting a value through the vacant
    /// entry.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::map::{TypedProjIndexMap, Entry, VacantEntry};
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// fn into_vacant<K: Any, V: Any>(entry: Entry<'_, K, V>) -> VacantEntry<'_, K, V> {
    ///     match entry {
    ///         Entry::Vacant(vacant_entry) => vacant_entry,
    ///         _ => panic!("This method only destructures vacant entries")
    ///     }
    /// }
    ///
    /// let mut proj_map: TypedProjIndexMap<&str, i32> = TypedProjIndexMap::new();
    /// let vacant_entry = into_vacant(proj_map.entry("foo"));
    /// let expected = "foo";
    /// let result = vacant_entry.key();
    ///
    /// assert_eq!(result, &expected);
    /// ```
    pub fn key(&self) -> &K {
        self.inner.key()
    }

    /*
    pub(crate) fn key_mut(&mut self) -> &mut K {
        self.inner.key_mut()
    }
    */

    /// Takes ownership of the key for this vacant entry.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::map::{TypedProjIndexMap, Entry, VacantEntry};
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// fn into_vacant<K: Any, V: Any>(entry: Entry<'_, K, V>) -> VacantEntry<'_, K, V> {
    ///     match entry {
    ///         Entry::Vacant(vacant_entry) => vacant_entry,
    ///         _ => panic!("This method only destructures vacant entries")
    ///     }
    /// }
    ///
    /// let mut proj_map: TypedProjIndexMap<&str, i32> = TypedProjIndexMap::new();
    /// let vacant_entry = into_vacant(proj_map.entry("foo"));
    /// let expected = "foo";
    /// let result = vacant_entry.into_key();
    ///
    /// assert_eq!(result, expected);
    /// ```
    pub fn into_key(self) -> K {
        self.inner.into_key()
    }

    /// Sets the value of the vacant entry, then returns a mutable reference to the value.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::map::{TypedProjIndexMap, Entry, VacantEntry};
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// fn into_vacant<K: Any, V: Any>(entry: Entry<'_, K, V>) -> VacantEntry<'_, K, V> {
    ///     match entry {
    ///         Entry::Vacant(vacant_entry) => vacant_entry,
    ///         _ => panic!("This method only destructures vacant entries")
    ///     }
    /// }
    ///
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  3_i32),
    ///     ("quux", 4_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get("foo"),  Some(&1_i32));
    /// assert_eq!(proj_map.get("bar"),  Some(&2_i32));
    /// assert_eq!(proj_map.get("baz"),  Some(&3_i32));
    /// assert_eq!(proj_map.get("quux"), Some(&4_i32));
    ///
    /// let result = into_vacant(proj_map.entry("corge")).insert(i32::MAX);
    ///
    /// assert_eq!(result, &i32::MAX);
    /// ```
    pub fn insert(self, value: V) -> &'a mut V {
        self.inner.insert(value)
    }

    /// Sets the value of the vacant entry in the index map, then returns an occupied entry
    /// corresponding to the key-value pair now stored in the index map.
    ///
    /// # Examples
    ///
    /// Calling this method on a vacant entry from an index map with a set of sorted keys yields the
    /// index of the entry in the underlying storage.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::map::{TypedProjIndexMap, Entry, VacantEntry};
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// fn into_vacant<K: Any, V: Any>(entry: Entry<'_, K, V>) -> VacantEntry<'_, K, V> {
    ///     match entry {
    ///         Entry::Vacant(vacant_entry) => vacant_entry,
    ///         _ => panic!("This method only destructures vacant entries")
    ///     }
    /// }
    ///
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  3_i32),
    ///     ("quux", 4_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get("foo"),  Some(&1_i32));
    /// assert_eq!(proj_map.get("bar"),  Some(&2_i32));
    /// assert_eq!(proj_map.get("baz"),  Some(&3_i32));
    /// assert_eq!(proj_map.get("quux"), Some(&4_i32));
    ///
    /// let occupied_entry = into_vacant(proj_map.entry("corge")).insert_entry(i32::MAX);
    ///
    /// assert_eq!(occupied_entry.key(), &"corge");
    /// assert_eq!(occupied_entry.get(), &i32::MAX);
    /// assert_eq!(occupied_entry.index(), 4);
    /// ```
    pub fn insert_entry(self, value: V) -> OccupiedEntry<'a, K, V, A> {
        OccupiedEntry::new(self.inner.insert_entry(value))
    }

    /// Inserts a new entry in the index map at its ordered position among sorted keys.
    ///
    /// This method is equivalent to finding the position with [`binary_search_keys`], then either
    /// updating it or calling [`insert_before`] for a new key.
    ///
    /// This method behaves as follows:
    ///
    /// * If the index map is in sorted order and contains the sorted key `key`, its corresponding
    ///   value is updated with `value`, and the older value is returned as
    ///   `(index, Some(old_value))`, where `index` is the storage index of the sorted key.
    /// * If the index map is in sorted order and does not contain the sorted key `key`, this method
    ///   inserts the new entry at the sorted position, returns `(index, None)`, where `index` is
    ///   the storage index of the sorted key.
    /// * If the existing keys are **not** sorted order, then the insertion index is unspecified.
    ///
    /// # Examples
    ///
    /// Calling this method on a vacant entry from an index map with a set of sorted keys yields the
    /// index of the entry in the underlying storage.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::map::{TypedProjIndexMap, Entry, VacantEntry};
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// fn into_vacant<K: Any, V: Any>(entry: Entry<'_, K, V>) -> VacantEntry<'_, K, V> {
    ///     match entry {
    ///         Entry::Vacant(vacant_entry) => vacant_entry,
    ///         _ => panic!("This method only destructures vacant entries")
    ///     }
    /// }
    ///
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  3_i32),
    ///     ("quux", 4_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get("foo"),  Some(&1_i32));
    /// assert_eq!(proj_map.get("bar"),  Some(&2_i32));
    /// assert_eq!(proj_map.get("baz"),  Some(&3_i32));
    /// assert_eq!(proj_map.get("quux"), Some(&4_i32));
    ///
    /// let result = into_vacant(proj_map.entry("corge")).insert_sorted(i32::MAX);
    ///
    /// // The map is sorted, so the index returned is the storage index in the map.
    /// assert_eq!(result, (3, &mut i32::MAX));
    /// ```
    ///
    /// Calling this method on a vacant entry from an index map with a set of unsorted keys yields a
    /// meaningless result for the insertion index.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::map::{TypedProjIndexMap, Entry, VacantEntry};
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// fn into_vacant<K: Any, V: Any>(entry: Entry<'_, K, V>) -> VacantEntry<'_, K, V> {
    ///     match entry {
    ///         Entry::Vacant(vacant_entry) => vacant_entry,
    ///         _ => panic!("This method only destructures vacant entries")
    ///     }
    /// }
    ///
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("quux", 4_i32),
    ///     ("bar",  2_i32),
    ///     ("foo",  1_i32),
    ///     ("baz",  3_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get("foo"),  Some(&1_i32));
    /// assert_eq!(proj_map.get("bar"),  Some(&2_i32));
    /// assert_eq!(proj_map.get("baz"),  Some(&3_i32));
    /// assert_eq!(proj_map.get("quux"), Some(&4_i32));
    ///
    /// let result = into_vacant(proj_map.entry("corge")).insert_sorted(i32::MAX);
    ///
    /// // The map is sorted, so the index returned is the storage index in the map.
    /// assert_ne!(result, (3, &mut i32::MAX));
    /// ```
    pub fn insert_sorted(self, value: V) -> (usize, &'a mut V)
    where
        K: Ord,
    {
        self.inner.insert_sorted(value)
    }

    /// Sets the value of the vacant entry, then returns a mutable reference to the value.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::map::{TypedProjIndexMap, Entry, VacantEntry};
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// fn into_vacant<K: Any, V: Any>(entry: Entry<'_, K, V>) -> VacantEntry<'_, K, V> {
    ///     match entry {
    ///         Entry::Vacant(vacant_entry) => vacant_entry,
    ///         _ => panic!("This method only destructures occupied entries")
    ///     }
    /// }
    ///
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo", 1_i32),
    ///     ("bar", 2_i32),
    ///     ("baz", 3_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_full("foo"), Some((0, &"foo", &1_i32)));
    /// assert_eq!(proj_map.get_full("bar"), Some((1, &"bar", &2_i32)));
    /// assert_eq!(proj_map.get_full("baz"), Some((2, &"baz", &3_i32)));
    ///
    /// let occupied_entry = into_vacant(proj_map.entry("quux"));
    /// occupied_entry.shift_insert(1, i32::MAX);
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((0, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((1, &"quux", &i32::MAX)));
    /// assert_eq!(proj_map.get_full("bar"),  Some((2, &"bar",  &2_i32)));
    /// assert_eq!(proj_map.get_full("baz"),  Some((3, &"baz",  &3_i32)));
    /// ```
    pub fn shift_insert(self, index: usize, value: V) -> &'a mut V {
        self.inner.shift_insert(index, value)
    }
}

impl<K, V, A> fmt::Debug for VacantEntry<'_, K, V, A>
where
    K: any::Any + fmt::Debug,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
        formatter.debug_tuple("VacantEntry").field(self.key()).finish()
    }
}

/// A view into an occupied entry in an index map obtained by storage index.
///
/// Indexed entries are obtained from the [`TypedProjIndexMap::get_index_entry`] and
/// [`OpaqueIndexMap::get_index_entry`] methods.
///
/// # Examples
///
/// ```
/// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
/// # use opaque_index_map::TypedProjIndexMap;
/// # use opaque_hash::TypedProjBuildHasher;
/// # use opaque_alloc::TypedProjAlloc;
/// # use opaque_vec::TypedProjVec;
/// # use std::any::TypeId;
/// # use std::cmp::Ordering;
/// # use std::hash::RandomState;
/// #
/// # #[cfg(feature = "nightly")]
/// # use std::alloc::Global;
/// #
/// # #[cfg(not(feature = "nightly"))]
/// # use opaque_allocator_api::alloc::Global;
/// #
/// let mut proj_map = TypedProjIndexMap::from([
///     (1_usize, 10_i32),
///     (2_usize, 40_i32),
///     (3_usize, 30_i32),
/// ]);
///
/// assert!(proj_map.get_index_entry(0).is_some());
/// assert!(proj_map.get_index_entry(1).is_some());
/// assert!(proj_map.get_index_entry(2).is_some());
///
/// assert_eq!(proj_map.get_index_entry(0).unwrap().key(), &1_usize);
/// assert_eq!(proj_map.get_index_entry(0).unwrap().index(), 0);
/// assert_eq!(proj_map.get_index_entry(0).unwrap().get(), &10_i32);
///
/// assert_eq!(proj_map.get_index_entry(1).unwrap().key(), &2_usize);
/// assert_eq!(proj_map.get_index_entry(1).unwrap().index(), 1);
/// assert_eq!(proj_map.get_index_entry(1).unwrap().get(), &40_i32);
///
/// assert_eq!(proj_map.get_index_entry(2).unwrap().key(), &3_usize);
/// assert_eq!(proj_map.get_index_entry(2).unwrap().index(), 2);
/// assert_eq!(proj_map.get_index_entry(2).unwrap().get(), &30_i32);
///
/// assert!(proj_map.get_index_entry(3).is_none());
/// ```
pub struct IndexedEntry<'a, K, V, A = alloc::Global>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    inner: map_inner::IndexedEntry<'a, K, V, A>,
}

impl<'a, K, V, A> IndexedEntry<'a, K, V, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    /// Constructs a new indexed entry.
    pub(crate) fn new(inner: map_inner::IndexedEntry<'a, K, V, A>) -> Self
    where
        K: Ord,
    {
        Self {
            inner,
        }
    }

    /// Returns the storage index of the indexed entry in the index map.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  3_i32),
    ///     ("quux", 4_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_index_entry(0).unwrap().index(),  0);
    /// assert_eq!(proj_map.get_index_entry(1).unwrap().index(),  1);
    /// assert_eq!(proj_map.get_index_entry(2).unwrap().index(),  2);
    /// assert_eq!(proj_map.get_index_entry(3).unwrap().index(), 3);
    /// ```
    #[inline]
    pub fn index(&self) -> usize {
        self.inner.index()
    }

    /// Gets a reference to the key stored in the indexed entry in the index map.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  3_i32),
    ///     ("quux", 4_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_index_entry(0).unwrap().key(),  &"foo");
    /// assert_eq!(proj_map.get_index_entry(1).unwrap().key(),  &"bar");
    /// assert_eq!(proj_map.get_index_entry(2).unwrap().key(),  &"baz");
    /// assert_eq!(proj_map.get_index_entry(3).unwrap().key(), &"quux");
    /// ```
    pub fn key(&self) -> &K {
        self.inner.key()
    }

    /*
    pub(crate) fn key_mut(&mut self) -> &mut K {
        self.inner.key_mut()
    }
    */

    /// Gets a reference to the indexed entry's value in the index map.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  3_i32),
    ///     ("quux", 4_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_index_entry(0).unwrap().get(), &1_i32);
    /// assert_eq!(proj_map.get_index_entry(1).unwrap().get(), &2_i32);
    /// assert_eq!(proj_map.get_index_entry(2).unwrap().get(), &3_i32);
    /// assert_eq!(proj_map.get_index_entry(3).unwrap().get(), &4_i32);
    /// ```
    pub fn get(&self) -> &V {
        self.inner.get()
    }

    /// Gets a mutable reference to the indexed entry's value in the index map.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  3_i32),
    ///     ("quux", 4_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_index_entry(0).unwrap().get_mut(), &mut 1_i32);
    /// assert_eq!(proj_map.get_index_entry(1).unwrap().get_mut(), &mut 2_i32);
    /// assert_eq!(proj_map.get_index_entry(2).unwrap().get_mut(), &mut 3_i32);
    /// assert_eq!(proj_map.get_index_entry(3).unwrap().get_mut(), &mut 4_i32);
    /// ```
    pub fn get_mut(&mut self) -> &mut V {
        self.inner.get_mut()
    }

    /// Converts the [`IndexedEntry`] into a mutable reference to the value in the entry
    /// with a lifetime bound to the index map itself.
    ///
    /// Use [`get_mut`] to get multiple references to the occupied entry.
    ///
    /// [`get_mut`]: IndexedEntry::get_mut
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  3_i32),
    ///     ("quux", 4_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((0, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("bar"),  Some((1, &"bar",  &2_i32)));
    /// assert_eq!(proj_map.get_full("baz"),  Some((2, &"baz",  &3_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((3, &"quux", &4_i32)));
    /// {
    ///     let maybe_indexed_entry = proj_map.get_index_entry(1);
    ///
    ///     assert!(maybe_indexed_entry.is_some());
    ///
    ///     let indexed_entry = maybe_indexed_entry.unwrap();
    ///     let result = indexed_entry.into_mut();
    ///
    ///     assert_eq!(result, &2_i32);
    ///
    ///     *result = i32::MAX;
    /// }
    /// assert_eq!(proj_map.get_index_entry(1).unwrap().get(), &i32::MAX);
    /// ```
    pub fn into_mut(self) -> &'a mut V {
        self.inner.into_mut()
    }

    /// Sets the value of the indexed entry to a new value, and returns the old value.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  3_i32),
    ///     ("quux", 4_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((0, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("bar"),  Some((1, &"bar",  &2_i32)));
    /// assert_eq!(proj_map.get_full("baz"),  Some((2, &"baz",  &3_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((3, &"quux", &4_i32)));
    ///
    /// let maybe_indexed_entry = proj_map.get_index_entry(1);
    ///
    /// assert!(maybe_indexed_entry.is_some());
    ///
    /// let mut indexed_entry = maybe_indexed_entry.unwrap();
    /// let result = indexed_entry.insert(i32::MAX);
    ///
    /// assert_eq!(result, 2_i32);
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((0, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("bar"),  Some((1, &"bar",  &i32::MAX)));
    /// assert_eq!(proj_map.get_full("baz"),  Some((2, &"baz",  &3_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((3, &"quux", &4_i32)));
    /// ```
    pub fn insert(&mut self, value: V) -> V {
        self.inner.insert(value)
    }

    /// Removes the indexed entry from the index map, and returns the value of the entry.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  3_i32),
    ///     ("quux", 4_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((0, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("bar"),  Some((1, &"bar",  &2_i32)));
    /// assert_eq!(proj_map.get_full("baz"),  Some((2, &"baz",  &3_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((3, &"quux", &4_i32)));
    ///
    /// let maybe_indexed_entry = proj_map.get_index_entry(1);
    ///
    /// assert!(maybe_indexed_entry.is_some());
    ///
    /// let indexed_entry = maybe_indexed_entry.unwrap();
    /// let result = indexed_entry.swap_remove();
    ///
    /// assert_eq!(result, 2_i32);
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((0, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("baz"),  Some((2, &"baz",  &3_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((1, &"quux", &4_i32)));
    /// ```
    pub fn swap_remove(self) -> V {
        self.inner.swap_remove()
    }

    /// Removes the indexed entry from the index map, and returns the value of the entry.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  3_i32),
    ///     ("quux", 4_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((0, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("bar"),  Some((1, &"bar",  &2_i32)));
    /// assert_eq!(proj_map.get_full("baz"),  Some((2, &"baz",  &3_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((3, &"quux", &4_i32)));
    ///
    /// let maybe_indexed_entry = proj_map.get_index_entry(2);
    ///
    /// assert!(maybe_indexed_entry.is_some());
    ///
    /// let indexed_entry = maybe_indexed_entry.unwrap();
    /// let result = indexed_entry.shift_remove();
    ///
    /// assert_eq!(result, 3_i32);
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((0, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("bar"),  Some((1, &"bar",  &2_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((2, &"quux", &4_i32)));
    /// ```
    pub fn shift_remove(self) -> V {
        self.inner.shift_remove()
    }

    /// Removes the indexed entry from the index map, and returns the key-value pair for the entry.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  3_i32),
    ///     ("quux", 4_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((0, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("bar"),  Some((1, &"bar",  &2_i32)));
    /// assert_eq!(proj_map.get_full("baz"),  Some((2, &"baz",  &3_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((3, &"quux", &4_i32)));
    ///
    /// let maybe_indexed_entry = proj_map.get_index_entry(1);
    ///
    /// assert!(maybe_indexed_entry.is_some());
    ///
    /// let indexed_entry = maybe_indexed_entry.unwrap();
    /// let result = indexed_entry.swap_remove_entry();
    ///
    /// assert_eq!(result, ("bar", 2_i32));
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((0, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("baz"),  Some((2, &"baz",  &3_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((1, &"quux", &4_i32)));
    /// ```
    pub fn swap_remove_entry(self) -> (K, V) {
        self.inner.swap_remove_entry()
    }

    /// Removes the indexed entry from the index map, and returns the key-value pair for the entry.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  3_i32),
    ///     ("quux", 4_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((0, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("bar"),  Some((1, &"bar",  &2_i32)));
    /// assert_eq!(proj_map.get_full("baz"),  Some((2, &"baz",  &3_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((3, &"quux", &4_i32)));
    ///
    /// let maybe_indexed_entry = proj_map.get_index_entry(2);
    ///
    /// assert!(maybe_indexed_entry.is_some());
    ///
    /// let indexed_entry = maybe_indexed_entry.unwrap();
    /// let result = indexed_entry.shift_remove_entry();
    ///
    /// assert_eq!(result, ("baz", 3_i32));
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((0, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("bar"),  Some((1, &"bar",  &2_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((2, &"quux", &4_i32)));
    /// ```
    pub fn shift_remove_entry(self) -> (K, V) {
        self.inner.shift_remove_entry()
    }

    /// Moves the storage position of an indexed entry from one index to another by shifting all
    /// other pairs in between.
    ///
    /// This method behaves as follows:
    ///
    /// * If `self.index() < to`, the other pairs will shift up while the targeted pair moves down.
    /// * If `self.index() > to`, the other pairs will shift down while the targeted pair moves up.
    ///
    /// # Panics
    ///
    /// This method panics if `to` is out of bounds.
    ///
    /// # Examples
    ///
    /// Moving an entry to an index where `self.index() > to`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  3_i32),
    ///     ("quux", 4_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((0, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("bar"),  Some((1, &"bar",  &2_i32)));
    /// assert_eq!(proj_map.get_full("baz"),  Some((2, &"baz",  &3_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((3, &"quux", &4_i32)));
    ///
    /// let maybe_indexed_entry = proj_map.get_index_entry(0);
    ///
    /// assert!(maybe_indexed_entry.is_some());
    ///
    /// let indexed_entry = maybe_indexed_entry.unwrap();
    /// indexed_entry.move_index(3);
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((3, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("bar"),  Some((0, &"bar",  &2_i32)));
    /// assert_eq!(proj_map.get_full("baz"),  Some((1, &"baz",  &3_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((2, &"quux", &4_i32)));
    /// ```
    ///
    /// Moving an entry to an index where `self.index() < to`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  3_i32),
    ///     ("quux", 4_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((0, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("bar"),  Some((1, &"bar",  &2_i32)));
    /// assert_eq!(proj_map.get_full("baz"),  Some((2, &"baz",  &3_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((3, &"quux", &4_i32)));
    ///
    /// let maybe_indexed_entry = proj_map.get_index_entry(2);
    ///
    /// assert!(maybe_indexed_entry.is_some());
    ///
    /// let indexed_entry = maybe_indexed_entry.unwrap();
    /// indexed_entry.move_index(0);
    ///
    /// assert_eq!(proj_map.get_full("foo"),  Some((1, &"foo",  &1_i32)));
    /// assert_eq!(proj_map.get_full("bar"),  Some((2, &"bar",  &2_i32)));
    /// assert_eq!(proj_map.get_full("baz"),  Some((0, &"baz",  &3_i32)));
    /// assert_eq!(proj_map.get_full("quux"), Some((3, &"quux", &4_i32)));
    /// ```
    #[track_caller]
    pub fn move_index(self, to: usize) {
        self.inner.move_index(to);
    }

    /// Swaps the position of the indexed entry with the entry located at another storage index in
    /// the index map.
    ///
    /// # Panics
    ///
    /// This method panics if `other` is out of bounds.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::{Any, TypeId};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo", 1_i32),
    ///     ("bar", 2_i32),
    ///     ("baz", 3_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_full("foo"), Some((0, &"foo", &1_i32)));
    /// assert_eq!(proj_map.get_full("baz"), Some((2, &"baz", &3_i32)));
    ///
    /// let maybe_indexed_entry = proj_map.get_index_entry(0);
    ///
    /// assert!(maybe_indexed_entry.is_some());
    ///
    /// let indexed_entry = maybe_indexed_entry.unwrap();
    /// indexed_entry.swap_indices(2);
    ///
    /// assert_eq!(proj_map.get_full("foo"), Some((2, &"foo", &1_i32)));
    /// assert_eq!(proj_map.get_full("baz"), Some((0, &"baz", &3_i32)));
    /// ```
    #[track_caller]
    pub fn swap_indices(self, other: usize) {
        self.inner.swap_indices(other);
    }
}

impl<K, V, A> fmt::Debug for IndexedEntry<'_, K, V, A>
where
    K: any::Any + fmt::Debug,
    V: any::Any + fmt::Debug,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
        formatter.debug_struct("IndexedEntry")
            .field("index", &self.index())
            .field("key", self.key())
            .field("value", self.get())
            .finish()
    }
}

impl<'a, K, V, A> From<OccupiedEntry<'a, K, V, A>> for IndexedEntry<'a, K, V, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    fn from(other: OccupiedEntry<'a, K, V, A>) -> Self {
        Self {
            inner: map_inner::IndexedEntry::from(other.inner),
        }
    }
}

#[cfg(test)]
mod entry_assert_send_sync {
    use super::*;

    #[test]
    fn test_assert_send_sync() {
        fn assert_send_sync<T: Send + Sync>() {}

        assert_send_sync::<Entry<'_, i32, i32, alloc::Global>>();
        assert_send_sync::<OccupiedEntry<'_, i32, i32, alloc::Global>>();
        assert_send_sync::<VacantEntry<'_, i32, i32, alloc::Global>>();
        assert_send_sync::<IndexedEntry<'_, i32, i32, alloc::Global>>();
    }
}

/// A type-projected hash map where the order of the entries inside the map is independent of the
/// hash values of the keys.
///
/// The interface to this hash map tracks closely with the standard library's [`HashMap`] interface.
/// One feature this hash map has that the standard library one does not is that it is generic over
/// the choice of memory allocator. This type supports type-erasure of generic parameters. The main
/// difference is that a `TypedProjIndexMap` can be converted to an `OpaqueIndexMap` in constant
/// **O(1)** time, hiding its key type, value type, hash builder type, and allocator type, at
/// runtime.
///
/// # Ordering
///
/// The key-value pairs are stored in the map in their insertion order, rather than by their
/// hash value, provided no removal method have been called on an entry in the map. In particular,
/// inserting a new value into the map does not change the **storage order** of the other elements
/// in the map.
///
/// # Indices
///
/// The key-value pairs are stored in a packed range with no holes in the range `[0, self.len())`.
/// Thus, one can always use the [`get_index_of`] or [`get_index`] methods to interact with
/// key-value pairs inside the map by their storage index instead of their key.
///
/// # Type Erasure And Type Projection
///
/// This allows for more flexible and dynamic data handling, especially when working with
/// collections of unknown or dynamic types. Type-erasable collections allow for more efficient
/// runtime dynamic typing, since one has more control over the memory layout of the collection,
/// even for erased types. Some applications of this include implementing heterogeneous data
/// structures, plugin systems, and managing foreign function interface data. There are two data
/// types that are dual to each other: [`TypedProjIndexMap`] and [`OpaqueIndexMap`].
///
/// By laying out both data types identically, we can project the underlying types in **O(1)** time,
/// and erase the underlying types in **O(1)** time, though the conversion is often zero-cost.
///
/// # See Also
///
/// - [`OpaqueIndexMap`]: the type-erased counterpart to [`TypedProjIndexMap`].
///
/// # Examples
///
/// Basic usage of a type-projected index map.
///
/// ```
/// # use opaque_index_map::TypedProjIndexMap;
/// #
/// let mut party: TypedProjIndexMap<String, String> = TypedProjIndexMap::from([
///     (String::from("cloud"),     String::from("protagonist")),
///     (String::from("tifa"),      String::from("fighter")),
///     (String::from("aerith"),    String::from("mage")),
///     (String::from("barret"),    String::from("gunner")),
///     (String::from("cid"),       String::from("pilot")),
///     (String::from("vincent"),   String::from("mysterious brooding sable-clad kind of guy")),
///     (String::from("yuffie"),    String::from("ninja")),
///     (String::from("red xiii"),  String::from("scientist")),
///     (String::from("cait sith"), String::from("fortune teller")),
/// ]);
///
/// assert_eq!(party.get("cloud"),     Some(&String::from("protagonist")));
/// assert_eq!(party.get("tifa"),      Some(&String::from("fighter")));
/// assert_eq!(party.get("aerith"),    Some(&String::from("mage")));
/// assert_eq!(party.get("barret"),    Some(&String::from("gunner")));
/// assert_eq!(party.get("cid"),       Some(&String::from("pilot")));
/// assert_eq!(party.get("vincent"),   Some(&String::from("mysterious brooding sable-clad kind of guy")));
/// assert_eq!(party.get("yuffie"),    Some(&String::from("ninja")));
/// assert_eq!(party.get("red xiii"),  Some(&String::from("scientist")));
/// assert_eq!(party.get("cait sith"), Some(&String::from("fortune teller")));
///
/// assert!(!party.contains_key("sephiroth"));
/// assert!(!party.contains_key("jenova"));
/// assert!(!party.contains_key("emerald weapon"));
///
/// // Elements of an index map are stored in their insertion order, independent of their keys.
/// assert_eq!(party.get_index_of("cloud"),     Some(0));
/// assert_eq!(party.get_index_of("tifa"),      Some(1));
/// assert_eq!(party.get_index_of("aerith"),    Some(2));
/// assert_eq!(party.get_index_of("barret"),    Some(3));
/// assert_eq!(party.get_index_of("cid"),       Some(4));
/// assert_eq!(party.get_index_of("vincent"),   Some(5));
/// assert_eq!(party.get_index_of("yuffie"),    Some(6));
/// assert_eq!(party.get_index_of("red xiii"),  Some(7));
/// assert_eq!(party.get_index_of("cait sith"), Some(8));
///
/// assert_eq!(party.get_index_of("sephiroth"),      None);
/// assert_eq!(party.get_index_of("jenova"),         None);
/// assert_eq!(party.get_index_of("emerald weapon"), None);
///
/// party.insert(String::from("sephiroth"), String::from("one-winged angel"));
///
/// assert!(party.contains_key("sephiroth"));
///
/// // Elements of an index map are stored in their insertion order, independent of their keys.
/// assert_eq!(party.get_index_of("cloud"),     Some(0));
/// assert_eq!(party.get_index_of("tifa"),      Some(1));
/// assert_eq!(party.get_index_of("aerith"),    Some(2));
/// assert_eq!(party.get_index_of("barret"),    Some(3));
/// assert_eq!(party.get_index_of("cid"),       Some(4));
/// assert_eq!(party.get_index_of("vincent"),   Some(5));
/// assert_eq!(party.get_index_of("yuffie"),    Some(6));
/// assert_eq!(party.get_index_of("red xiii"),  Some(7));
/// assert_eq!(party.get_index_of("cait sith"), Some(8));
/// assert_eq!(party.get_index_of("sephiroth"), Some(9));
///
/// assert_eq!(party.get("sephiroth"), Some(&String::from("one-winged angel")));
///
/// party["sephiroth"] = String::from("nevermind");
///
/// assert_eq!(party.get("sephiroth"), Some(&String::from("nevermind")));
///
/// party.shift_remove("sephiroth");
///
/// assert!(!party.contains_key("sephiroth"));
/// ```
#[cfg(feature = "std")]
#[repr(transparent)]
pub struct TypedProjIndexMap<K, V, S = hash::RandomState, A = alloc::Global>
where
    K: any::Any,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    inner: TypedProjIndexMapInner<K, V, S, A>,
}

#[cfg(not(feature = "std"))]
#[repr(transparent)]
pub struct TypedProjIndexMap<K, V, S, A = alloc::Global>
where
    K: any::Any,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    inner: TypedProjIndexMapInner<K, V, S, A>,
}

impl<K, V, S, A> TypedProjIndexMap<K, V, S, A>
where
    K: any::Any,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    /// Returns the [`TypeId`] of the keys contained in the type-projected index map.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<usize, isize, RandomState, Global> = TypedProjIndexMap::new();
    ///
    /// assert_eq!(proj_map.key_type_id(), TypeId::of::<usize>());
    /// ```
    #[inline]
    pub const fn key_type_id(&self) -> any::TypeId {
        self.inner.key_type_id()
    }

    /// Returns the [`TypeId`] of the values contained in the type-projected index map.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<usize, isize, RandomState, Global> = TypedProjIndexMap::new();
    ///
    /// assert_eq!(proj_map.value_type_id(), TypeId::of::<isize>());
    /// ```
    #[inline]
    pub const fn value_type_id(&self) -> any::TypeId {
        self.inner.value_type_id()
    }

    /// Returns the [`TypeId`] of the hash builder for the type-projected index map.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<usize, isize, RandomState, Global> = TypedProjIndexMap::new();
    ///
    /// assert_eq!(proj_map.build_hasher_type_id(), TypeId::of::<RandomState>());
    /// ```
    #[inline]
    pub const fn build_hasher_type_id(&self) -> any::TypeId {
        self.inner.build_hasher_type_id()
    }

    /// Returns the [`TypeId`] of the memory allocator for the type-projected index map.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<usize, isize, RandomState, Global> = TypedProjIndexMap::new();
    ///
    /// assert_eq!(proj_map.allocator_type_id(), TypeId::of::<Global>());
    /// ```
    #[inline]
    pub const fn allocator_type_id(&self) -> any::TypeId {
        self.inner.allocator_type_id()
    }
}

impl<K, V, S, A> TypedProjIndexMap<K, V, S, A>
where
    K: any::Any,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    /// Constructs a new index map with the given type-projected hash builder and type-projected
    /// memory allocator.
    ///
    /// This method **does not** allocate memory. In particular, the index map has zero capacity
    /// and will not allocate memory until key-value pairs are inserted into it. The index map will
    /// have length zero until elements are inserted into it.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_alloc = TypedProjAlloc::new(Global);
    /// let proj_build_hasher = TypedProjBuildHasher::new(RandomState::new());
    /// let proj_map: TypedProjIndexMap<usize, f64, RandomState, Global> = TypedProjIndexMap::with_hasher_proj_in(
    ///     proj_build_hasher,
    ///     proj_alloc
    /// );
    ///
    /// assert!(proj_map.is_empty());
    /// assert_eq!(proj_map.capacity(), 0);
    /// ```
    #[inline]
    pub fn with_hasher_proj_in(proj_build_hasher: TypedProjBuildHasher<S>, proj_alloc: TypedProjAlloc<A>) -> Self {
        let proj_inner = TypedProjIndexMapInner::<K, V, S, A>::with_hasher_proj_in(proj_build_hasher, proj_alloc);

        Self {
            inner: proj_inner,
        }
    }

    /// Constructs a new index map with the given capacity, type-projected hash builder, and
    /// type-projected memory allocator.
    ///
    /// This method **does** allocate memory if the capacity `capacity` is non-zero. In particular,
    /// the index map has capacity at least `capacity`, and will allocate enough memory to store at
    /// least `capacity` keys and values. The index map will have length zero until elements are
    /// inserted into it.
    ///
    /// # Examples
    ///
    /// Creating a type-projected index map with capacity `capacity > 0`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let capacity = 10;
    /// let proj_alloc = TypedProjAlloc::new(Global);
    /// let proj_build_hasher = TypedProjBuildHasher::new(RandomState::new());
    /// let proj_map: TypedProjIndexMap<usize, f64, RandomState, Global> = TypedProjIndexMap::with_capacity_and_hasher_proj_in(
    ///     capacity,
    ///     proj_build_hasher,
    ///     proj_alloc
    /// );
    ///
    /// assert!(proj_map.is_empty());
    /// assert!(proj_map.capacity() >= capacity);
    /// ```
    ///
    /// Creating a type-projected index map with capacity `capacity == 0`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_alloc = TypedProjAlloc::new(Global);
    /// let proj_build_hasher = TypedProjBuildHasher::new(RandomState::new());
    /// let proj_map: TypedProjIndexMap<usize, f64, RandomState, Global> = TypedProjIndexMap::with_capacity_and_hasher_proj_in(
    ///     0,
    ///     proj_build_hasher,
    ///     proj_alloc
    /// );
    ///
    /// assert!(proj_map.is_empty());
    /// assert_eq!(proj_map.capacity(), 0);
    /// ```
    #[inline]
    pub fn with_capacity_and_hasher_proj_in(capacity: usize, proj_build_hasher: TypedProjBuildHasher<S>, proj_alloc: TypedProjAlloc<A>) -> Self {
        if capacity == 0 {
            Self::with_hasher_proj_in(proj_build_hasher, proj_alloc)
        } else {
            let proj_inner = TypedProjIndexMapInner::<K, V, S, A>::with_capacity_and_hasher_proj_in(capacity, proj_build_hasher, proj_alloc);

            Self {
                inner: proj_inner,
            }
        }
    }
}

#[cfg(feature = "std")]
impl<K, V, A> TypedProjIndexMap<K, V, hash::RandomState, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    /// Constructs a new index map with the given type-projected memory allocator.
    ///
    /// This method **does not** allocate memory. In particular, the index map has zero capacity and
    /// will not allocate memory until key-value pairs are inserted into it. The index map will have
    /// length zero until elements are inserted into it.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_alloc = TypedProjAlloc::new(Global);
    /// let proj_map: TypedProjIndexMap<usize, f64, RandomState, Global> = TypedProjIndexMap::new_proj_in(proj_alloc);
    ///
    /// assert!(proj_map.is_empty());
    /// assert_eq!(proj_map.capacity(), 0);
    /// ```
    #[inline]
    pub fn new_proj_in(proj_alloc: TypedProjAlloc<A>) -> Self {
        let proj_inner = TypedProjIndexMapInner::<K, V, hash::RandomState, A>::new_proj_in(proj_alloc);

        Self {
            inner : proj_inner,
        }
    }

    /// Constructs a new index map with the given capacity and type-projected memory allocator.
    ///
    /// This method **does** allocate memory if the capacity `capacity` is non-zero. In particular,
    /// the index map has capacity at least `capacity`, and will allocate enough memory to store at
    /// least `capacity` keys and values. The index map will have length zero until elements are
    /// inserted into it.
    ///
    /// # Examples
    ///
    /// Creating a type-projected index map with capacity `capacity > 0`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let capacity = 10;
    /// let proj_alloc = TypedProjAlloc::new(Global);
    /// let proj_map: TypedProjIndexMap<usize, f64, RandomState, Global> = TypedProjIndexMap::with_capacity_proj_in(
    ///     capacity,
    ///     proj_alloc
    /// );
    ///
    /// assert!(proj_map.is_empty());
    /// assert!(proj_map.capacity() >= capacity);
    /// ```
    ///
    /// Creating a type-projected index map with capacity `capacity == 0`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_alloc = TypedProjAlloc::new(Global);
    /// let proj_map: TypedProjIndexMap<usize, f64, RandomState, Global> = TypedProjIndexMap::with_capacity_proj_in(
    ///     0,
    ///     proj_alloc
    /// );
    ///
    /// assert!(proj_map.is_empty());
    /// assert_eq!(proj_map.capacity(), 0);
    /// ```
    #[inline]
    pub fn with_capacity_proj_in(capacity: usize, proj_alloc: TypedProjAlloc<A>) -> Self {
        let proj_inner = TypedProjIndexMapInner::<K, V, hash::RandomState, A>::with_capacity_proj_in(capacity, proj_alloc);

        Self {
            inner: proj_inner,
        }
    }
}

impl<K, V, S, A> TypedProjIndexMap<K, V, S, A>
where
    K: any::Any,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    /// Constructs a new index map with the given hash builder and memory allocator.
    ///
    /// This method **does not** allocate memory. In particular, the index map has zero capacity and
    /// will not allocate memory until key-value pairs are inserted into it. The index map will have
    /// length zero until elements are inserted into it.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<usize, f64, RandomState, Global> = TypedProjIndexMap::with_hasher_in(
    ///     RandomState::new(),
    ///     Global
    /// );
    ///
    /// assert!(proj_map.is_empty());
    /// assert_eq!(proj_map.capacity(), 0);
    /// ```
    #[inline]
    pub fn with_hasher_in(build_hasher: S, alloc: A) -> Self {
        let proj_inner = TypedProjIndexMapInner::<K, V, S, A>::with_hasher_in(build_hasher, alloc);

        Self {
            inner: proj_inner,
        }
    }

    /// Constructs a new index map with the given capacity, hash builder, and memory allocator.
    ///
    /// This method **does** allocate memory if the capacity `capacity` is non-zero. In particular,
    /// the index map has capacity at least `capacity`, and will allocate enough memory to store at
    /// least `capacity` keys and values. The index map will have length zero until elements are
    /// inserted into it.
    ///
    /// # Examples
    ///
    /// Creating a type-projected index map with capacity `capacity > 0`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let capacity = 10;
    /// let proj_map: TypedProjIndexMap<usize, f64, RandomState, Global> = TypedProjIndexMap::with_capacity_and_hasher_in(
    ///     capacity,
    ///     RandomState::new(),
    ///     Global
    /// );
    ///
    /// assert!(proj_map.is_empty());
    /// assert!(proj_map.capacity() >= capacity);
    /// ```
    ///
    /// Creating a type-projected index map with capacity `capacity == 0`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<usize, f64, RandomState, Global> = TypedProjIndexMap::with_capacity_and_hasher_in(
    ///     0,
    ///     RandomState::new(),
    ///     Global
    /// );
    ///
    /// assert!(proj_map.is_empty());
    /// assert_eq!(proj_map.capacity(), 0);
    /// ```
    #[inline]
    pub fn with_capacity_and_hasher_in(capacity: usize, build_hasher: S, alloc: A) -> Self {
        if capacity == 0 {
            Self::with_hasher_in(build_hasher, alloc)
        } else {
            let proj_inner = TypedProjIndexMapInner::<K, V, S, A>::with_capacity_and_hasher_in(capacity, build_hasher, alloc);

            Self {
                inner: proj_inner,
            }
        }
    }
}

#[cfg(feature = "std")]
impl<K, V, A> TypedProjIndexMap<K, V, hash::RandomState, A>
where
    K: any::Any,
    V: any::Any,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    /// Constructs a new index map with the given memory allocator.
    ///
    /// This method **does not** allocate memory. In particular, the index map has zero capacity and
    /// will not allocate memory until key-value pairs are inserted into it. The index map will have
    /// length zero until elements are inserted into it.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<usize, f64, RandomState, Global> = TypedProjIndexMap::new_in(Global);
    ///
    /// assert!(proj_map.is_empty());
    /// assert_eq!(proj_map.capacity(), 0);
    /// ```
    #[inline]
    pub fn new_in(alloc: A) -> Self {
        let proj_inner = TypedProjIndexMapInner::<K, V, hash::RandomState, A>::new_in(alloc);

        Self {
            inner : proj_inner,
        }
    }

    /// Constructs a new index map with the given capacity and memory allocator.
    ///
    /// This method **does** allocate memory if the capacity `capacity` is non-zero. In particular,
    /// the index map has capacity at least `capacity`, and will allocate enough memory to store at
    /// least `capacity` keys and values. The index map will have length zero until elements are
    /// inserted into it.
    ///
    /// # Examples
    ///
    /// Creating a type-projected index map with capacity `capacity > 0`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let capacity = 10;
    /// let proj_map: TypedProjIndexMap<usize, f64, RandomState, Global> = TypedProjIndexMap::with_capacity_in(
    ///     capacity,
    ///     Global
    /// );
    ///
    /// assert!(proj_map.is_empty());
    /// assert!(proj_map.capacity() >= capacity);
    /// ```
    ///
    /// Creating a type-projected index map with capacity `capacity == 0`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<usize, f64, RandomState, Global> = TypedProjIndexMap::with_capacity_in(
    ///     0,
    ///     Global
    /// );
    ///
    /// assert!(proj_map.is_empty());
    /// assert_eq!(proj_map.capacity(), 0);
    /// ```
    #[inline]
    pub fn with_capacity_in(capacity: usize, alloc: A) -> Self {
        let proj_inner = TypedProjIndexMapInner::<K, V, hash::RandomState, A>::with_capacity_in(capacity, alloc);

        Self {
            inner: proj_inner,
        }
    }
}

impl<K, V, S> TypedProjIndexMap<K, V, S, alloc::Global>
where
    K: any::Any,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
{
    /// Constructs a new index map with the given hash builder.
    ///
    /// This method **does not** allocate memory. In particular, the index map has zero capacity and
    /// will not allocate memory until key-value pairs are inserted into it. The index map will have
    /// length zero until elements are inserted into it.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<usize, f64, RandomState, Global> = TypedProjIndexMap::with_hasher(RandomState::new());
    ///
    /// assert!(proj_map.is_empty());
    /// assert_eq!(proj_map.capacity(), 0);
    /// ```
    #[inline]
    pub fn with_hasher(build_hasher: S) -> Self {
        Self::with_hasher_in(build_hasher, alloc::Global)
    }

    /// Constructs a new index map with the given capacity and hash builder.
    ///
    /// This method **does** allocate memory if the capacity `capacity` is non-zero. In particular,
    /// the index map has capacity at least `capacity`, and will allocate enough memory to store at
    /// least `capacity` keys and values. The index map will have length zero until elements are
    /// inserted into it.
    ///
    /// # Examples
    ///
    /// Creating a type-projected index map with capacity `capacity > 0`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let capacity = 10;
    /// let proj_map: TypedProjIndexMap<usize, f64, RandomState, Global> = TypedProjIndexMap::with_capacity_and_hasher(
    ///     capacity,
    ///     RandomState::new(),
    /// );
    ///
    /// assert!(proj_map.is_empty());
    /// assert!(proj_map.capacity() >= capacity);
    /// ```
    ///
    /// Creating a type-projected index map with capacity `capacity == 0`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<usize, f64, RandomState, Global> = TypedProjIndexMap::with_capacity_and_hasher(
    ///     0,
    ///     RandomState::new(),
    /// );
    ///
    /// assert!(proj_map.is_empty());
    /// assert_eq!(proj_map.capacity(), 0);
    /// ```
    #[inline]
    pub fn with_capacity_and_hasher(capacity: usize, build_hasher: S) -> Self {
        Self::with_capacity_and_hasher_in(capacity, build_hasher, alloc::Global)
    }
}

#[cfg(feature = "std")]
impl<K, V> TypedProjIndexMap<K, V, hash::RandomState, alloc::Global>
where
    K: any::Any,
    V: any::Any,
{
    /// Constructs a new index map.
    ///
    /// This method **does not** allocate memory. In particular, the index map has zero capacity and
    /// will not allocate memory until key-value pairs are inserted into it. The index map will have
    /// length zero until elements are inserted into it.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<usize, f64, RandomState, Global> = TypedProjIndexMap::new();
    ///
    /// assert!(proj_map.is_empty());
    /// assert_eq!(proj_map.capacity(), 0);
    /// ```
    #[inline]
    pub fn new() -> Self {
        let proj_inner = TypedProjIndexMapInner::new();

        Self {
            inner : proj_inner,
        }
    }

    /// Constructs a new index map with the given capacity.
    ///
    /// This method **does** allocate memory if the capacity `capacity` is non-zero. In particular,
    /// the index map has capacity at least `capacity`, and will allocate enough memory to store at
    /// least `capacity` keys and values. The index map will have length zero until elements are
    /// inserted into it.
    ///
    /// # Examples
    ///
    /// Creating a type-projected index map with capacity `capacity > 0`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let capacity = 10;
    /// let proj_map: TypedProjIndexMap<usize, f64, RandomState, Global> = TypedProjIndexMap::with_capacity(
    ///     capacity,
    /// );
    ///
    /// assert!(proj_map.is_empty());
    /// assert!(proj_map.capacity() >= capacity);
    /// ```
    ///
    /// Creating a type-projected index map with capacity `capacity == 0`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<usize, f64, RandomState, Global> = TypedProjIndexMap::with_capacity(
    ///     0,
    /// );
    ///
    /// assert!(proj_map.is_empty());
    /// assert_eq!(proj_map.capacity(), 0);
    /// ```
    #[inline]
    pub fn with_capacity(capacity: usize) -> Self {
        let proj_inner = TypedProjIndexMapInner::with_capacity(capacity);

        Self {
            inner : proj_inner,
        }
    }
}

impl<K, V, S, A> TypedProjIndexMap<K, V, S, A>
where
    K: any::Any,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    /// Returns the capacity of the type-projected index map.
    ///
    /// The **capacity** of a type-projected index map is the number of key-value pairs the index
    /// map can hold without reallocating memory.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let capacity = 32;
    /// let mut proj_map: TypedProjIndexMap<usize, f64, RandomState, Global> = TypedProjIndexMap::with_capacity_in(
    ///     capacity,
    ///     Global,
    /// );
    ///
    /// assert_eq!(proj_map.len(), 0);
    /// assert!(proj_map.capacity() >= capacity);
    ///
    /// for i in 0..capacity {
    ///     proj_map.insert(i, i as f64);
    /// }
    ///
    /// assert_eq!(proj_map.len(), capacity);
    /// assert!(proj_map.capacity() >= capacity);
    /// ```
    #[inline]
    pub fn capacity(&self) -> usize {
        self.inner.capacity()
    }

    /// Returns the length of the type-projected index map.
    ///
    /// The **length** of a type-projected index map is the number of key-value pairs stored inside
    /// it. The length satisfies the following. Given an index map `map`
    ///
    /// ```text
    /// map.len() ≤ map.capacity().
    /// ```
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let len = 32;
    /// let mut proj_map: TypedProjIndexMap<usize, f64, RandomState, Global> = TypedProjIndexMap::with_capacity_in(
    ///     len,
    ///     Global,
    /// );
    ///
    /// assert_eq!(proj_map.len(), 0);
    ///
    /// for i in 0..len {
    ///     proj_map.insert(i, i as f64);
    /// }
    ///
    /// assert_eq!(proj_map.len(), len);
    /// ```
    #[inline]
    pub fn len(&self) -> usize {
        self.inner.len()
    }

    /// Determines whether the type-projected index map is empty.
    ///
    /// A type-projected index map is **empty** if it contains no key-value pairs, i.e. its length
    /// is zero. This method satisfies the following. Given an index map `map`
    ///
    /// ```text
    /// map.is_empty() ⇔ map.len() = 0.
    /// ```
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<usize, f64, RandomState, Global> = TypedProjIndexMap::with_capacity_in(
    ///     1,
    ///     Global,
    /// );
    ///
    /// assert!(proj_map.is_empty());
    ///
    /// proj_map.insert(1, 1_f64);
    ///
    /// assert!(!proj_map.is_empty());
    /// ```
    #[inline]
    pub fn is_empty(&self) -> bool {
        self.inner.is_empty()
    }
}

impl<K, V, S, A> TypedProjIndexMap<K, V, S, A>
where
    K: any::Any,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    /// Returns a reference to the type-projected hash builder used by the index map.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::new();
    ///
    /// assert!(proj_map.is_empty());
    ///
    /// let build_hasher: &TypedProjBuildHasher<RandomState> = proj_map.hasher();
    /// ```
    #[inline]
    pub const fn hasher(&self) -> &TypedProjBuildHasher<S> {
        self.inner.hasher()
    }

    /// Returns a reference to the type-projected memory allocator from the index map.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::new();
    ///
    /// assert!(proj_map.is_empty());
    ///
    /// let alloc: &TypedProjAlloc<Global> = proj_map.allocator();
    /// ```
    #[inline]
    pub fn allocator(&self) -> &TypedProjAlloc<A> {
        self.inner.allocator()
    }
}

impl<K, V, S, A> TypedProjIndexMap<K, V, S, A>
where
    K: any::Any,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    /// Returns the storage index of the key-value pair with the given lookup key, if it exists
    /// in the index map.
    ///
    /// This method returns `Some(index)`, where `index` is the storage index of the key-value pair,
    /// if the equivalent key to `key` exists in `self`. This method returns `None` if the lookup
    /// key `key` does not exist in `self`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with keys of type `K` and values of type `V`.
    ///
    /// ## Hashing And Equivalence
    ///
    /// A **hashing type** is a triple `(X, ~, h)` where `~` is an equivalence relation on
    /// `X`, and `h` is a hash function such that
    ///
    /// ```text
    /// ∀ a :: X. ∀ b :: X. a ~ b ⇒ h(a) = h(b).
    /// ```
    ///
    /// A type `X` is a **hashable type** if there is an equivalence relation `~` and a hashing
    /// function `h` such that `(X, ~, h)` is a hashing type.
    ///
    /// Let `K` be the type of the keys of the index map `map`. Let `Q` be a data type. Let
    /// `q :: Q` be a value of type `Q`, and let `k :: K` be a key. let `X` be a hashable type. Let
    /// `f: Q → X` and `g: K → X` be functions. We say that
    /// **`q` is equivalent to `k` using `f` and `g`** if and only if
    ///
    /// ```test
    /// equiv(X, f, g)(q, k) := f(q) ∼ g(k).
    /// ```
    ///
    /// Note that by the definition of `~`
    ///
    /// ```text
    /// ∀ q :: Q. ∀ k :: K. f(q) ∼ g(k) ⇒ h(f(q)) = h(g(k)).
    /// ```
    ///
    /// This is an implication, not an equivalence, because practical hashing functions can have
    /// collisions, i.e. for a practical hashing function `h`,
    /// `∃ a, b :: X. ¬(a ~ b) ∧ h(a) = h(b)`. We say that the type
    /// **`Q` is equivalent to `K` using `f` and `g`** if and only if
    ///
    /// ```text
    /// equiv(X, f, g)(Q, K) :=
    ///     (∀ q :: Q. ∃ k :: K. equiv(X, f, g)(q, k))
    ///     ∧ (∀ k :: K. ∃ q :: Q. equiv(X, f, g)(q, k)).
    /// ```
    ///
    /// Let `X` be a hashable type. Then the type **`Q` is equivalent to the type `K` using `X`**
    /// if and only if
    ///
    /// ```text
    /// equiv(X, Q, K) := ∃ f: Q → X. ∃ g: K → X. equiv(X, f, g)(Q, K).
    /// ```
    ///
    /// Key equality is a special case of key equivalence. Let `K` be a hashable data type. Let
    /// `Q = K`, and `f = g = id`. Then
    ///
    /// ```text
    /// ∀ k1, k2 :: K. k1 = k2 = id(k1) = id(k2) ⇒ h(id(k1)) = h(id(k2)) = h(k1) = h(k2)
    /// ```
    ///
    /// so that we have `equiv(K, id, id)(K, K)` which implies `equiv(K, K, K)`, i.e. `K` is
    /// equivalent to `K` using `K` when `K` is a hashable type.
    ///
    /// Let `Q` be a type equivalent to the key type `K` using `K`. Let `f: Q → K` and `id: K → K`
    /// be the identity. We say that **`q` is equivalent to `k`** if and only if
    ///
    /// ```text
    /// equiv(q, k) := equiv(K, f, id)(q, k).
    /// ```
    ///
    /// Let `Q` be a data type equivalent to key type `K` using `K`. We say that `q` is an
    /// **equivalent element of** the map `map`, or that **`map` equivalently contains `q`** if and
    /// only if
    ///
    /// ```text
    /// q ~∈ map ⇔ ∃ i ∈ [0, map.len()). equiv(q, map[i].key()).
    /// ```
    ///
    /// If `q` is not an equivalent element of `map`, we write `q ~∉ map`.
    ///
    /// When `K` is a hashable type, we see that `k ~∈ map ⇔ k ∈ map`, so that equivalent
    /// containment indeed generalizes containment.
    ///
    /// ## Specification Definitions
    ///
    /// The **index** of an equivalent key `q :: Q` in `map` is defined by
    ///
    /// ```text
    /// index(map, q) := i such that equiv(q, map[i].key()).
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ~∈ map }
    /// map.get_index_of(key)
    /// { result = Some(index(map, key)) }
    ///
    /// { key ~∉ map }
    /// map.get_index_of(key)
    /// { result = None }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_index_of(&1_usize), Some(0));
    /// assert_eq!(proj_map.get_index_of(&2_usize), Some(1));
    /// assert_eq!(proj_map.get_index_of(&3_usize), Some(2));
    /// assert_eq!(proj_map.get_index_of(&4_usize), None);
    /// assert_eq!(proj_map.get_index_of(&usize::MAX), None);
    /// ```
    pub fn get_index_of<Q>(&self, key: &Q) -> Option<usize>
    where
        Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    {
        self.inner.get_index_of(key)
    }

    /// Determines whether a given lookup key exists in the index map.
    ///
    /// This method returns `true` if the equivalent key to `key` exists in `self`. This method
    /// returns `false` if the equivalent key to `key` does not exist in `self`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with keys of type `K` and values of type `V`.
    ///
    /// ## Hashing And Equivalence
    ///
    /// A **hashing type** is a triple `(X, ~, h)` where `~` is an equivalence relation on
    /// `X`, and `h` is a hash function such that
    ///
    /// ```text
    /// ∀ a :: X. ∀ b :: X. a ~ b ⇒ h(a) = h(b).
    /// ```
    ///
    /// A type `X` is a **hashable type** if there is an equivalence relation `~` and a hashing
    /// function `h` such that `(X, ~, h)` is a hashing type.
    ///
    /// Let `K` be the type of the keys of the index map `map`. Let `Q` be a data type. Let
    /// `q :: Q` be a value of type `Q`, and let `k :: K` be a key. let `X` be a hashable type. Let
    /// `f: Q → X` and `g: K → X` be functions. We say that
    /// **`q` is equivalent to `k` using `f` and `g`** if and only if
    ///
    /// ```test
    /// equiv(X, f, g)(q, k) := f(q) ∼ g(k).
    /// ```
    ///
    /// Note that by the definition of `~`
    ///
    /// ```text
    /// ∀ q :: Q. ∀ k :: K. f(q) ∼ g(k) ⇒ h(f(q)) = h(g(k)).
    /// ```
    ///
    /// This is an implication, not an equivalence, because practical hashing functions can have
    /// collisions, i.e. for a practical hashing function `h`,
    /// `∃ a, b :: X. ¬(a ~ b) ∧ h(a) = h(b)`. We say that the type
    /// **`Q` is equivalent to `K` using `f` and `g`** if and only if
    ///
    /// ```text
    /// equiv(X, f, g)(Q, K) :=
    ///     (∀ q :: Q. ∃ k :: K. equiv(X, f, g)(q, k))
    ///     ∧ (∀ k :: K. ∃ q :: Q. equiv(X, f, g)(q, k)).
    /// ```
    ///
    /// Let `X` be a hashable type. Then the type **`Q` is equivalent to the type `K` using `X`**
    /// if and only if
    ///
    /// ```text
    /// equiv(X, Q, K) := ∃ f: Q → X. ∃ g: K → X. equiv(X, f, g)(Q, K).
    /// ```
    ///
    /// Key equality is a special case of key equivalence. Let `K` be a hashable data type. Let
    /// `Q = K`, and `f = g = id`. Then
    ///
    /// ```text
    /// ∀ k1, k2 :: K. k1 = k2 = id(k1) = id(k2) ⇒ h(id(k1)) = h(id(k2)) = h(k1) = h(k2)
    /// ```
    ///
    /// so that we have `equiv(K, id, id)(K, K)` which implies `equiv(K, K, K)`, i.e. `K` is
    /// equivalent to `K` using `K` when `K` is a hashable type.
    ///
    /// Let `Q` be a type equivalent to the key type `K` using `K`. Let `f: Q → K` and `id: K → K`
    /// be the identity. We say that **`q` is equivalent to `k`** if and only if
    ///
    /// ```text
    /// equiv(q, k) := equiv(K, f, id)(q, k).
    /// ```
    ///
    /// Let `Q` be a data type equivalent to key type `K` using `K`. We say that `q` is an
    /// **equivalent element of** the map `map`, or that **`map` equivalently contains `q`** if and
    /// only if
    ///
    /// ```text
    /// q ~∈ map ⇔ ∃ i ∈ [0, map.len()). equiv(q, map[i].key()).
    /// ```
    ///
    /// If `q` is not an equivalent element of `map`, we write `q ~∉ map`.
    ///
    /// When `K` is a hashable type, we see that `k ~∈ map ⇔ k ∈ map`, so that equivalent
    /// containment indeed generalizes containment.
    ///
    /// ## Specification Definitions
    ///
    /// Let `e :: (K, V)` be an entry of type `(K, V)`. We say that `map` **contains** a key-value
    /// pair `e :: (K, V)`, or that `e` is an **entry of** `map` if the following holds:
    ///
    /// ```text
    /// ∀ e :: (K, V). (e ∈ map) ⇔ (∃ i ∈ [0, map.len()). map[i] = e ∧ map[e.key()] = e.value())
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies the following:
    ///
    /// ```text
    /// { key ~∈ map }
    /// map.contains_key(key)
    /// { result = true }
    ///
    /// { key ~∉ map }
    /// map.contains_key(key)
    /// { result = false }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    ///
    /// assert!(proj_map.contains_key(&1_usize));
    /// assert!(proj_map.contains_key(&2_usize));
    /// assert!(proj_map.contains_key(&3_usize));
    /// assert!(!proj_map.contains_key(&4_usize));
    /// assert!(!proj_map.contains_key(&usize::MAX));
    /// ```
    pub fn contains_key<Q>(&self, key: &Q) -> bool
    where
        Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    {
        self.inner.contains_key(key)
    }

    /// Returns a reference to the value corresponding to a key-value pair with the given lookup
    /// key, if it exists in the index map.
    ///
    /// This method returns `Some(&value)` where `value` is the value corresponding to the
    /// equivalent key to `key` in `self` if the equivalent key to key exists in `self`. This
    /// method returns `None` if the equivalent key to `key` does not exist in `self`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with keys of type `K` and values of type `V`.
    ///
    /// ## Hashing And Equivalence
    ///
    /// A **hashing type** is a triple `(X, ~, h)` where `~` is an equivalence relation on
    /// `X`, and `h` is a hash function such that
    ///
    /// ```text
    /// ∀ a :: X. ∀ b :: X. a ~ b ⇒ h(a) = h(b).
    /// ```
    ///
    /// A type `X` is a **hashable type** if there is an equivalence relation `~` and a hashing
    /// function `h` such that `(X, ~, h)` is a hashing type.
    ///
    /// Let `K` be the type of the keys of the index map `map`. Let `Q` be a data type. Let
    /// `q :: Q` be a value of type `Q`, and let `k :: K` be a key. let `X` be a hashable type. Let
    /// `f: Q → X` and `g: K → X` be functions. We say that
    /// **`q` is equivalent to `k` using `f` and `g`** if and only if
    ///
    /// ```test
    /// equiv(X, f, g)(q, k) := f(q) ∼ g(k).
    /// ```
    ///
    /// Note that by the definition of `~`
    ///
    /// ```text
    /// ∀ q :: Q. ∀ k :: K. f(q) ∼ g(k) ⇒ h(f(q)) = h(g(k)).
    /// ```
    ///
    /// This is an implication, not an equivalence, because practical hashing functions can have
    /// collisions, i.e. for a practical hashing function `h`,
    /// `∃ a, b :: X. ¬(a ~ b) ∧ h(a) = h(b)`. We say that the type
    /// **`Q` is equivalent to `K` using `f` and `g`** if and only if
    ///
    /// ```text
    /// equiv(X, f, g)(Q, K) :=
    ///     (∀ q :: Q. ∃ k :: K. equiv(X, f, g)(q, k))
    ///     ∧ (∀ k :: K. ∃ q :: Q. equiv(X, f, g)(q, k)).
    /// ```
    ///
    /// Let `X` be a hashable type. Then the type **`Q` is equivalent to the type `K` using `X`**
    /// if and only if
    ///
    /// ```text
    /// equiv(X, Q, K) := ∃ f: Q → X. ∃ g: K → X. equiv(X, f, g)(Q, K).
    /// ```
    ///
    /// Key equality is a special case of key equivalence. Let `K` be a hashable data type. Let
    /// `Q = K`, and `f = g = id`. Then
    ///
    /// ```text
    /// ∀ k1, k2 :: K. k1 = k2 = id(k1) = id(k2) ⇒ h(id(k1)) = h(id(k2)) = h(k1) = h(k2)
    /// ```
    ///
    /// so that we have `equiv(K, id, id)(K, K)` which implies `equiv(K, K, K)`, i.e. `K` is
    /// equivalent to `K` using `K` when `K` is a hashable type.
    ///
    /// Let `Q` be a type equivalent to the key type `K` using `K`. Let `f: Q → K` and `id: K → K`
    /// be the identity. We say that **`q` is equivalent to `k`** if and only if
    ///
    /// ```text
    /// equiv(q, k) := equiv(K, f, id)(q, k).
    /// ```
    ///
    /// Let `Q` be a data type equivalent to key type `K` using `K`. We say that `q` is an
    /// **equivalent element of** the map `map`, or that **`map` equivalently contains `q`** if and
    /// only if
    ///
    /// ```text
    /// q ~∈ map ⇔ ∃ i ∈ [0, map.len()). equiv(q, map[i].key()).
    /// ```
    ///
    /// If `q` is not an equivalent element of `map`, we write `q ~∉ map`.
    ///
    /// When `K` is a hashable type, we see that `k ~∈ map ⇔ k ∈ map`, so that equivalent
    /// containment indeed generalizes containment.
    ///
    /// ## Specification Definitions
    ///
    /// The **index** of an equivalent key `q :: Q` in `map` is defined by
    ///
    /// ```text
    /// index(map, q) := i such that equiv(q, map[i].key()).
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ~∈ map }
    /// map.get(key)
    /// { result = Some(map[index(map, key)]) }
    ///
    /// { key ~∉ map }
    /// map.get(key)
    /// { result = None }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    ///
    /// assert_eq!(proj_map.get(&1_usize), Some(&2_f64));
    /// assert_eq!(proj_map.get(&2_usize), Some(&3_f64));
    /// assert_eq!(proj_map.get(&3_usize), Some(&4_f64));
    /// assert_eq!(proj_map.get(&4_usize), None);
    /// assert_eq!(proj_map.get(&usize::MAX), None);
    /// ```
    pub fn get<Q>(&self, key: &Q) -> Option<&V>
    where
        Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    {
        self.inner.get(key)
    }

    /// Returns a reference to the key and a reference to the value, of the key-value pair with the
    /// given lookup key, if it exists in the index map.
    ///
    /// This method returns `Some((&eq_key, &value))` where `eq_key` is the equivalent key to `key`
    /// stored in the map, and `value` is the value corresponding to the key `eq_key` in `self`,
    /// if the equivalent key `eq_key` to `key` exists in `self`. This method returns `None` if the
    /// equivalent key to `key` does not exist in `self`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with keys of type `K` and values of type `V`.
    ///
    /// ## Hashing And Equivalence
    ///
    /// A **hashing type** is a triple `(X, ~, h)` where `~` is an equivalence relation on
    /// `X`, and `h` is a hash function such that
    ///
    /// ```text
    /// ∀ a :: X. ∀ b :: X. a ~ b ⇒ h(a) = h(b).
    /// ```
    ///
    /// A type `X` is a **hashable type** if there is an equivalence relation `~` and a hashing
    /// function `h` such that `(X, ~, h)` is a hashing type.
    ///
    /// Let `K` be the type of the keys of the index map `map`. Let `Q` be a data type. Let
    /// `q :: Q` be a value of type `Q`, and let `k :: K` be a key. let `X` be a hashable type. Let
    /// `f: Q → X` and `g: K → X` be functions. We say that
    /// **`q` is equivalent to `k` using `f` and `g`** if and only if
    ///
    /// ```test
    /// equiv(X, f, g)(q, k) := f(q) ∼ g(k).
    /// ```
    ///
    /// Note that by the definition of `~`
    ///
    /// ```text
    /// ∀ q :: Q. ∀ k :: K. f(q) ∼ g(k) ⇒ h(f(q)) = h(g(k)).
    /// ```
    ///
    /// This is an implication, not an equivalence, because practical hashing functions can have
    /// collisions, i.e. for a practical hashing function `h`,
    /// `∃ a, b :: X. ¬(a ~ b) ∧ h(a) = h(b)`. We say that the type
    /// **`Q` is equivalent to `K` using `f` and `g`** if and only if
    ///
    /// ```text
    /// equiv(X, f, g)(Q, K) :=
    ///     (∀ q :: Q. ∃ k :: K. equiv(X, f, g)(q, k))
    ///     ∧ (∀ k :: K. ∃ q :: Q. equiv(X, f, g)(q, k)).
    /// ```
    ///
    /// Let `X` be a hashable type. Then the type **`Q` is equivalent to the type `K` using `X`**
    /// if and only if
    ///
    /// ```text
    /// equiv(X, Q, K) := ∃ f: Q → X. ∃ g: K → X. equiv(X, f, g)(Q, K).
    /// ```
    ///
    /// Key equality is a special case of key equivalence. Let `K` be a hashable data type. Let
    /// `Q = K`, and `f = g = id`. Then
    ///
    /// ```text
    /// ∀ k1, k2 :: K. k1 = k2 = id(k1) = id(k2) ⇒ h(id(k1)) = h(id(k2)) = h(k1) = h(k2)
    /// ```
    ///
    /// so that we have `equiv(K, id, id)(K, K)` which implies `equiv(K, K, K)`, i.e. `K` is
    /// equivalent to `K` using `K` when `K` is a hashable type.
    ///
    /// Let `Q` be a type equivalent to the key type `K` using `K`. Let `f: Q → K` and `id: K → K`
    /// be the identity. We say that **`q` is equivalent to `k`** if and only if
    ///
    /// ```text
    /// equiv(q, k) := equiv(K, f, id)(q, k).
    /// ```
    ///
    /// Let `Q` be a data type equivalent to key type `K` using `K`. We say that `q` is an
    /// **equivalent element of** the map `map`, or that **`map` equivalently contains `q`** if and
    /// only if
    ///
    /// ```text
    /// q ~∈ map ⇔ ∃ i ∈ [0, map.len()). equiv(q, map[i].key()).
    /// ```
    ///
    /// If `q` is not an equivalent element of `map`, we write `q ~∉ map`.
    ///
    /// When `K` is a hashable type, we see that `k ~∈ map ⇔ k ∈ map`, so that equivalent
    /// containment indeed generalizes containment.
    ///
    /// ## Specification Definitions
    ///
    /// The **index** of an equivalent key `q :: Q` in `map` is defined by
    ///
    /// ```text
    /// index(map, q) := i such that equiv(q, map[i].key()).
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ~∈ map }
    /// map.get_key_value(key)
    /// { result = Some(map[index(map, key)]) }
    ///
    /// { key ~∉ map }
    /// map.get_key_value(key)
    /// { result = None }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_key_value(&1_usize), Some((&1_usize, &2_f64)));
    /// assert_eq!(proj_map.get_key_value(&2_usize), Some((&2_usize, &3_f64)));
    /// assert_eq!(proj_map.get_key_value(&3_usize), Some((&3_usize, &4_f64)));
    /// assert_eq!(proj_map.get_key_value(&4_usize), None);
    /// assert_eq!(proj_map.get_key_value(&usize::MAX), None);
    /// ```
    pub fn get_key_value<Q>(&self, key: &Q) -> Option<(&K, &V)>
    where
        Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    {
        self.inner.get_key_value(key)
    }

    /// Returns the storage index, a reference to the key and a reference to the value, of the
    /// key-value pair with the given lookup key, if it exists in the index map.
    ///
    /// This method returns `Some((index, &eq_key, &value))` where `index` is the storage index of
    /// the key-value pair, `eq_key` is the equivalent key to `key` stored in the map, and `value`
    /// is the value corresponding to the key `eq_key` in `self`, if the equivalent key `eq_key`
    /// to `key` exists in `self`. This method returns `None` if the equivalent key to `key` does
    /// not exist in `self`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with keys of type `K` and values of type `V`.
    ///
    /// ## Hashing And Equivalence
    ///
    /// A **hashing type** is a triple `(X, ~, h)` where `~` is an equivalence relation on
    /// `X`, and `h` is a hash function such that
    ///
    /// ```text
    /// ∀ a :: X. ∀ b :: X. a ~ b ⇒ h(a) = h(b).
    /// ```
    ///
    /// A type `X` is a **hashable type** if there is an equivalence relation `~` and a hashing
    /// function `h` such that `(X, ~, h)` is a hashing type.
    ///
    /// Let `K` be the type of the keys of the index map `map`. Let `Q` be a data type. Let
    /// `q :: Q` be a value of type `Q`, and let `k :: K` be a key. let `X` be a hashable type. Let
    /// `f: Q → X` and `g: K → X` be functions. We say that
    /// **`q` is equivalent to `k` using `f` and `g`** if and only if
    ///
    /// ```test
    /// equiv(X, f, g)(q, k) := f(q) ∼ g(k).
    /// ```
    ///
    /// Note that by the definition of `~`
    ///
    /// ```text
    /// ∀ q :: Q. ∀ k :: K. f(q) ∼ g(k) ⇒ h(f(q)) = h(g(k)).
    /// ```
    ///
    /// This is an implication, not an equivalence, because practical hashing functions can have
    /// collisions, i.e. for a practical hashing function `h`,
    /// `∃ a, b :: X. ¬(a ~ b) ∧ h(a) = h(b)`. We say that the type
    /// **`Q` is equivalent to `K` using `f` and `g`** if and only if
    ///
    /// ```text
    /// equiv(X, f, g)(Q, K) :=
    ///     (∀ q :: Q. ∃ k :: K. equiv(X, f, g)(q, k))
    ///     ∧ (∀ k :: K. ∃ q :: Q. equiv(X, f, g)(q, k)).
    /// ```
    ///
    /// Let `X` be a hashable type. Then the type **`Q` is equivalent to the type `K` using `X`**
    /// if and only if
    ///
    /// ```text
    /// equiv(X, Q, K) := ∃ f: Q → X. ∃ g: K → X. equiv(X, f, g)(Q, K).
    /// ```
    ///
    /// Key equality is a special case of key equivalence. Let `K` be a hashable data type. Let
    /// `Q = K`, and `f = g = id`. Then
    ///
    /// ```text
    /// ∀ k1, k2 :: K. k1 = k2 = id(k1) = id(k2) ⇒ h(id(k1)) = h(id(k2)) = h(k1) = h(k2)
    /// ```
    ///
    /// so that we have `equiv(K, id, id)(K, K)` which implies `equiv(K, K, K)`, i.e. `K` is
    /// equivalent to `K` using `K` when `K` is a hashable type.
    ///
    /// Let `Q` be a type equivalent to the key type `K` using `K`. Let `f: Q → K` and `id: K → K`
    /// be the identity. We say that **`q` is equivalent to `k`** if and only if
    ///
    /// ```text
    /// equiv(q, k) := equiv(K, f, id)(q, k).
    /// ```
    ///
    /// Let `Q` be a data type equivalent to key type `K` using `K`. We say that `q` is an
    /// **equivalent element of** the map `map`, or that **`map` equivalently contains `q`** if and
    /// only if
    ///
    /// ```text
    /// q ~∈ map ⇔ ∃ i ∈ [0, map.len()). equiv(q, map[i].key()).
    /// ```
    ///
    /// If `q` is not an equivalent element of `map`, we write `q ~∉ map`.
    ///
    /// When `K` is a hashable type, we see that `k ~∈ map ⇔ k ∈ map`, so that equivalent
    /// containment indeed generalizes containment.
    ///
    /// ## Specification Definitions
    ///
    /// The **index** of an equivalent key `q :: Q` in `map` is defined by
    ///
    /// ```text
    /// index(map, q) := i such that equiv(q, map[i].key()).
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ~∈ map }
    /// map.get_full(key)
    /// { result = Some((index(map, key), map[index(map, key)])) }
    ///
    /// { key ~∉ map }
    /// map.get_full(key)
    /// { result = None }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_full(&1_usize), Some((0, &1_usize, &2_f64)));
    /// assert_eq!(proj_map.get_full(&2_usize), Some((1, &2_usize, &3_f64)));
    /// assert_eq!(proj_map.get_full(&3_usize), Some((2, &3_usize, &4_f64)));
    /// assert_eq!(proj_map.get_full(&4_usize), None);
    /// assert_eq!(proj_map.get_full(&usize::MAX), None);
    /// ```
    pub fn get_full<Q>(&self, key: &Q) -> Option<(usize, &K, &V)>
    where
        Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    {
        self.inner.get_full(key)
    }

    /// Returns a mutable reference to the value corresponding to a key-value pair with the given
    /// lookup key, if it exists in the index map.
    ///
    /// This method returns `Some(&mut value)` where `value` is the value corresponding to the
    /// equivalent key to `key` in `self`. This method returns `None` if the equivalent key to
    /// `key` does not exist in `self`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with keys of type `K` and values of type `V`.
    ///
    /// ## Hashing And Equivalence
    ///
    /// A **hashing type** is a triple `(X, ~, h)` where `~` is an equivalence relation on
    /// `X`, and `h` is a hash function such that
    ///
    /// ```text
    /// ∀ a :: X. ∀ b :: X. a ~ b ⇒ h(a) = h(b).
    /// ```
    ///
    /// A type `X` is a **hashable type** if there is an equivalence relation `~` and a hashing
    /// function `h` such that `(X, ~, h)` is a hashing type.
    ///
    /// Let `K` be the type of the keys of the index map `map`. Let `Q` be a data type. Let
    /// `q :: Q` be a value of type `Q`, and let `k :: K` be a key. let `X` be a hashable type. Let
    /// `f: Q → X` and `g: K → X` be functions. We say that
    /// **`q` is equivalent to `k` using `f` and `g`** if and only if
    ///
    /// ```test
    /// equiv(X, f, g)(q, k) := f(q) ∼ g(k).
    /// ```
    ///
    /// Note that by the definition of `~`
    ///
    /// ```text
    /// ∀ q :: Q. ∀ k :: K. f(q) ∼ g(k) ⇒ h(f(q)) = h(g(k)).
    /// ```
    ///
    /// This is an implication, not an equivalence, because practical hashing functions can have
    /// collisions, i.e. for a practical hashing function `h`,
    /// `∃ a, b :: X. ¬(a ~ b) ∧ h(a) = h(b)`. We say that the type
    /// **`Q` is equivalent to `K` using `f` and `g`** if and only if
    ///
    /// ```text
    /// equiv(X, f, g)(Q, K) :=
    ///     (∀ q :: Q. ∃ k :: K. equiv(X, f, g)(q, k))
    ///     ∧ (∀ k :: K. ∃ q :: Q. equiv(X, f, g)(q, k)).
    /// ```
    ///
    /// Let `X` be a hashable type. Then the type **`Q` is equivalent to the type `K` using `X`**
    /// if and only if
    ///
    /// ```text
    /// equiv(X, Q, K) := ∃ f: Q → X. ∃ g: K → X. equiv(X, f, g)(Q, K).
    /// ```
    ///
    /// Key equality is a special case of key equivalence. Let `K` be a hashable data type. Let
    /// `Q = K`, and `f = g = id`. Then
    ///
    /// ```text
    /// ∀ k1, k2 :: K. k1 = k2 = id(k1) = id(k2) ⇒ h(id(k1)) = h(id(k2)) = h(k1) = h(k2)
    /// ```
    ///
    /// so that we have `equiv(K, id, id)(K, K)` which implies `equiv(K, K, K)`, i.e. `K` is
    /// equivalent to `K` using `K` when `K` is a hashable type.
    ///
    /// Let `Q` be a type equivalent to the key type `K` using `K`. Let `f: Q → K` and `id: K → K`
    /// be the identity. We say that **`q` is equivalent to `k`** if and only if
    ///
    /// ```text
    /// equiv(q, k) := equiv(K, f, id)(q, k).
    /// ```
    ///
    /// Let `Q` be a data type equivalent to key type `K` using `K`. We say that `q` is an
    /// **equivalent element of** the map `map`, or that **`map` equivalently contains `q`** if and
    /// only if
    ///
    /// ```text
    /// q ~∈ map ⇔ ∃ i ∈ [0, map.len()). equiv(q, map[i].key()).
    /// ```
    ///
    /// If `q` is not an equivalent element of `map`, we write `q ~∉ map`.
    ///
    /// When `K` is a hashable type, we see that `k ~∈ map ⇔ k ∈ map`, so that equivalent
    /// containment indeed generalizes containment.
    ///
    /// ## Specification Definitions
    ///
    /// The **index** of an equivalent key `q :: Q` in `map` is defined by
    ///
    /// ```text
    /// index(map, q) := i such that equiv(q, map[i].key()).
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ~∈ map }
    /// map.get_mut(key)
    /// { result = Some(map[index(map, key)]) }
    ///
    /// { key ~∉ map }
    /// map.get_mut(key)
    /// { result = None }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_mut(&1_usize), Some(&mut 2_f64));
    /// assert_eq!(proj_map.get_mut(&2_usize), Some(&mut 3_f64));
    /// assert_eq!(proj_map.get_mut(&3_usize), Some(&mut 4_f64));
    /// assert_eq!(proj_map.get_mut(&4_usize), None);
    /// assert_eq!(proj_map.get_mut(&usize::MAX), None);
    /// ```
    pub fn get_mut<Q>(&mut self, key: &Q) -> Option<&mut V>
    where
        Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    {
        self.inner.get_mut(key)
    }

    /// Returns the storage index, a reference to the key and a mutable reference to the value, of
    /// the key-value pair with the given lookup key, if it exists in the index map.
    ///
    /// This method returns `Some((index, &eq_key, &mut value))` where `index` is the storage index
    /// of the key-value pair, `eq_key` is the equivalent key to `key` stored in the map and
    /// `value` is the value corresponding to the key `eq_key` in `self`, if the equivalent key to
    /// `key` exists in `self`. This method returns `None` if the equivalent key to `key` does
    /// not exist in `self`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with keys of type `K` and values of type `V`.
    ///
    /// ## Hashing And Equivalence
    ///
    /// A **hashing type** is a triple `(X, ~, h)` where `~` is an equivalence relation on
    /// `X`, and `h` is a hash function such that
    ///
    /// ```text
    /// ∀ a :: X. ∀ b :: X. a ~ b ⇒ h(a) = h(b).
    /// ```
    ///
    /// A type `X` is a **hashable type** if there is an equivalence relation `~` and a hashing
    /// function `h` such that `(X, ~, h)` is a hashing type.
    ///
    /// Let `K` be the type of the keys of the index map `map`. Let `Q` be a data type. Let
    /// `q :: Q` be a value of type `Q`, and let `k :: K` be a key. let `X` be a hashable type. Let
    /// `f: Q → X` and `g: K → X` be functions. We say that
    /// **`q` is equivalent to `k` using `f` and `g`** if and only if
    ///
    /// ```test
    /// equiv(X, f, g)(q, k) := f(q) ∼ g(k).
    /// ```
    ///
    /// Note that by the definition of `~`
    ///
    /// ```text
    /// ∀ q :: Q. ∀ k :: K. f(q) ∼ g(k) ⇒ h(f(q)) = h(g(k)).
    /// ```
    ///
    /// This is an implication, not an equivalence, because practical hashing functions can have
    /// collisions, i.e. for a practical hashing function `h`,
    /// `∃ a, b :: X. ¬(a ~ b) ∧ h(a) = h(b)`. We say that the type
    /// **`Q` is equivalent to `K` using `f` and `g`** if and only if
    ///
    /// ```text
    /// equiv(X, f, g)(Q, K) :=
    ///     (∀ q :: Q. ∃ k :: K. equiv(X, f, g)(q, k))
    ///     ∧ (∀ k :: K. ∃ q :: Q. equiv(X, f, g)(q, k)).
    /// ```
    ///
    /// Let `X` be a hashable type. Then the type **`Q` is equivalent to the type `K` using `X`**
    /// if and only if
    ///
    /// ```text
    /// equiv(X, Q, K) := ∃ f: Q → X. ∃ g: K → X. equiv(X, f, g)(Q, K).
    /// ```
    ///
    /// Key equality is a special case of key equivalence. Let `K` be a hashable data type. Let
    /// `Q = K`, and `f = g = id`. Then
    ///
    /// ```text
    /// ∀ k1, k2 :: K. k1 = k2 = id(k1) = id(k2) ⇒ h(id(k1)) = h(id(k2)) = h(k1) = h(k2)
    /// ```
    ///
    /// so that we have `equiv(K, id, id)(K, K)` which implies `equiv(K, K, K)`, i.e. `K` is
    /// equivalent to `K` using `K` when `K` is a hashable type.
    ///
    /// Let `Q` be a type equivalent to the key type `K` using `K`. Let `f: Q → K` and `id: K → K`
    /// be the identity. We say that **`q` is equivalent to `k`** if and only if
    ///
    /// ```text
    /// equiv(q, k) := equiv(K, f, id)(q, k).
    /// ```
    ///
    /// Let `Q` be a data type equivalent to key type `K` using `K`. We say that `q` is an
    /// **equivalent element of** the map `map`, or that **`map` equivalently contains `q`** if and
    /// only if
    ///
    /// ```text
    /// q ~∈ map ⇔ ∃ i ∈ [0, map.len()). equiv(q, map[i].key()).
    /// ```
    ///
    /// If `q` is not an equivalent element of `map`, we write `q ~∉ map`.
    ///
    /// When `K` is a hashable type, we see that `k ~∈ map ⇔ k ∈ map`, so that equivalent
    /// containment indeed generalizes containment.
    ///
    /// ## Specification Definitions
    ///
    /// The **index** of an equivalent key `q :: Q` in `map` is defined by
    ///
    /// ```text
    /// index(map, q) := i such that equiv(q, map[i].key()).
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ~∈ map }
    /// map.get_full_mut(key)
    /// { result = Some((index(map, key), map[index(map, key)])) }
    ///
    /// { key ~∉ map }
    /// map.get_full_mut(key)
    /// { result = None }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_full_mut(&1_usize), Some((0, &1_usize, &mut 2_f64)));
    /// assert_eq!(proj_map.get_full_mut(&2_usize), Some((1, &2_usize, &mut 3_f64)));
    /// assert_eq!(proj_map.get_full_mut(&3_usize), Some((2, &3_usize, &mut 4_f64)));
    /// assert_eq!(proj_map.get_full_mut(&4_usize), None);
    /// assert_eq!(proj_map.get_full_mut(&usize::MAX), None);
    /// ```
    pub fn get_full_mut<Q>(&mut self, key: &Q) -> Option<(usize, &K, &mut V)>
    where
        Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    {
        self.inner.get_full_mut(key)
    }

    /// Returns multiple references to the values of multiple lookup keys at once.
    ///
    /// # Panics
    ///
    /// This method panics if there are any duplicate lookup keys.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (1_isize, 'a'),
    ///     (3_isize, 'b'),
    ///     (2_isize, 'c'),
    ///     (6_isize, 'e'),
    ///     (4_isize, 'f'),
    ///     (5_isize, '@'),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_disjoint_mut([&2, &1, &5]), [Some(&mut 'c'), Some(&mut 'a'), Some(&mut '@')]);
    /// ```
    #[track_caller]
    pub fn get_disjoint_mut<Q, const N: usize>(&mut self, keys: [&Q; N]) -> [Option<&mut V>; N]
    where
        Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    {
        self.inner.get_disjoint_mut(keys)
    }

    /// Returns an iterator over the keys in the index map.
    ///
    /// The iterator returns the keys in the storage order of the entries in the index map.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    ///
    /// let keys: TypedProjVec<usize> = proj_map
    ///     .keys()
    ///     .cloned()
    ///     .collect();
    ///
    /// assert_eq!(keys.as_slice(), &[1_usize, 2_usize, 3_usize]);
    ///
    /// // The keys come back in storage or insertion order from the index map.
    /// for i in 0..keys.len() {
    ///     let expected = i;
    ///     let result = proj_map.get_index_of(&keys[i]).unwrap();
    ///     assert_eq!(result, expected);
    /// }
    /// ```
    pub fn keys(&self) -> Keys<'_, K, V> {
        Keys::new(self.inner.keys())
    }

    /// Returns a moving iterator over the keys in the index map.
    ///
    /// The iterator returns the keys in the storage order of the entries in the index map.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    ///
    /// let keys: TypedProjVec<usize> = proj_map
    ///     .clone()
    ///     .into_keys()
    ///     .collect();
    ///
    /// assert_eq!(keys.as_slice(), &[1_usize, 2_usize, 3_usize]);
    ///
    /// // The keys come back in storage or insertion order from the index map.
    /// for i in 0..keys.len() {
    ///     let expected = i;
    ///     let result = proj_map.get_index_of(&keys[i]).unwrap();
    ///     assert_eq!(result, expected);
    /// }
    /// ```
    pub fn into_keys(self) -> IntoKeys<K, V, A> {
        IntoKeys::new(self.inner.into_keys())
    }

    /// Returns an iterator over the entries in the index map.
    ///
    /// The iterator returns the entries in their storage order in the index map.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    ///
    /// let entries: TypedProjVec<(usize, f64)> = proj_map
    ///     .iter()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(entries.as_slice(), &[(1_usize, 2_f64), (2_usize, 3_f64), (3_usize, 4_f64)]);
    ///
    /// // The entries come back in storage or insertion order from the index map.
    /// for i in 0..entries.len() {
    ///     let expected = i;
    ///     let result = proj_map.get_index_of(&entries[i].0).unwrap();
    ///     assert_eq!(result, expected);
    /// }
    /// ```
    pub fn iter(&self) -> Iter<'_, K, V> {
        Iter::new(self.inner.iter())
    }

    /// Returns a mutable iterator over the keys/value pairs in the index map.
    ///
    /// The iterator returns the entries in their storage order in the index map.
    ///
    /// # Examples
    ///
    /// Iterating over the entries of a type-projected index map without mutating them.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    ///
    /// let entries: TypedProjVec<(usize, f64)> = proj_map
    ///     .iter_mut()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(entries.as_slice(), &[(1_usize, 2_f64), (2_usize, 3_f64), (3_usize, 4_f64)]);
    ///
    /// // The entries come back in storage or insertion order from the index map.
    /// for i in 0..entries.len() {
    ///     let expected = i;
    ///     let result = proj_map.get_index_of(&entries[i].0).unwrap();
    ///     assert_eq!(result, expected);
    /// }
    /// ```
    ///
    /// Iterating over the entries of a type-projected index map while mutating them.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    ///
    /// let entries: TypedProjVec<(usize, f64)> = proj_map
    ///     .iter_mut()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(entries.as_slice(), &[(1_usize, 2_f64), (2_usize, 3_f64), (3_usize, 4_f64)]);
    ///
    /// for (key, value) in proj_map.iter_mut() {
    ///     *value *= 2_f64;
    /// }
    ///
    /// let new_entries: TypedProjVec<(usize, f64)> = proj_map
    ///     .iter_mut()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(new_entries.as_slice(), &[(1_usize, 4_f64), (2_usize, 6_f64), (3_usize, 8_f64)]);
    /// ```
    pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {
        IterMut::new(self.inner.iter_mut())
    }

    /// Returns an iterator over the values in the index map.
    ///
    /// The iterator returns the values in the storage order of the entries in the index map.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    ///
    /// let values: TypedProjVec<f64> = proj_map
    ///     .values()
    ///     .cloned()
    ///     .collect();
    ///
    /// assert_eq!(values.as_slice(), &[2_f64, 3_f64, 4_f64]);
    ///
    /// // The keys come back in storage or insertion order from the index map.
    /// for key in proj_map.keys() {
    ///     let (index, _, value) = proj_map.get_full(key).unwrap();
    ///     assert_eq!(&values[index], value);
    /// }
    /// ```
    pub fn values(&self) -> Values<'_, K, V> {
        Values::new(self.inner.values())
    }

    /// Returns a mutable iterator over the values in the index map.
    ///
    /// The iterator returns the values in the storage order of the entries in the index map.
    ///
    /// # Examples
    ///
    /// Iterating over the entries of a type-projected index map without mutating them.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    ///
    /// let values: TypedProjVec<f64> = proj_map
    ///     .values_mut()
    ///     .map(|v| v.clone())
    ///     .collect();
    ///
    /// assert_eq!(values.as_slice(), &[2_f64, 3_f64, 4_f64]);
    ///
    /// // The keys come back in storage or insertion order from the index map.
    /// for key in proj_map.keys() {
    ///     let (index, _, value) = proj_map.get_full(key).unwrap();
    ///     assert_eq!(&values[index], value);
    /// }
    /// ```
    ///
    /// Iterating over the entries of a type-projected index map while mutating them.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    ///
    /// let values: TypedProjVec<f64> = proj_map
    ///     .values_mut()
    ///     .map(|v| v.clone())
    ///     .collect();
    ///
    /// assert_eq!(values.as_slice(), &[2_f64, 3_f64, 4_f64]);
    ///
    /// for value in proj_map.values_mut() {
    ///     *value *= 2_f64;
    /// }
    ///
    /// let new_values: TypedProjVec<f64> = proj_map
    ///     .values_mut()
    ///     .map(|v| v.clone())
    ///     .collect();
    ///
    /// assert_eq!(new_values.as_slice(), &[4_f64, 6_f64, 8_f64]);
    /// ```
    pub fn values_mut(&mut self) -> ValuesMut<'_, K, V> {
        ValuesMut::new(self.inner.values_mut())
    }

    /// Returns a moving iterator over the values in the index map.
    ///
    /// The iterator returns the values in the storage order of the entries in the index map.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    ///
    /// let values: TypedProjVec<f64> = proj_map
    ///     .clone()
    ///     .into_values()
    ///     .collect();
    ///
    /// assert_eq!(values.as_slice(), &[2_f64, 3_f64, 4_f64]);
    ///
    /// // The keys come back in storage or insertion order from the index map.
    /// for key in proj_map.keys() {
    ///     let (index, _, value) = proj_map.get_full(key).unwrap();
    ///     assert_eq!(&values[index], value);
    /// }
    /// ```
    pub fn into_values(self) -> IntoValues<K, V, A> {
        IntoValues::new(self.inner.into_values())
    }

    /// Removes all the entries from the index map.
    ///
    /// After calling this method, the collection will be empty. This method does not change the
    /// allocated capacity of the type-projected index map.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, and `map_after` be the state of `map` after
    /// this method completes.
    ///
    /// ## Specification Definitions
    ///
    /// We say that a key-value pair `e :: (K, V)` is an **entry** in the map `map` if and only if
    ///
    /// ```text
    /// ∀ e :: (K, V). e ∈ map ⇔ (∃ i ∈ [0, map.len()). map[i] = e).
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { true }
    /// map.clear()
    /// { map_after.len() = 0 ∧ (∀ e ∈ map_before. e ∉ map_after) }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let capacity = 10;
    /// let mut proj_map: TypedProjIndexMap<String, isize> = TypedProjIndexMap::with_capacity(10);
    ///
    /// assert!(proj_map.is_empty());
    ///
    /// proj_map.extend([
    ///     (String::from("foo"), -1_isize),
    ///     (String::from("bar"),  0_isize),
    ///     (String::from("baz"),  1_isize),
    /// ]);
    ///
    /// assert!(!proj_map.is_empty());
    /// assert_eq!(proj_map.len(), 3);
    ///
    /// let old_capacity = proj_map.capacity();
    ///
    /// proj_map.clear();
    ///
    /// assert!(proj_map.is_empty());
    /// assert_eq!(proj_map.capacity(), old_capacity);
    /// ```
    pub fn clear(&mut self) {
        self.inner.clear();
    }

    /// Shortens an index map to the supplied length, dropping the remaining elements.
    ///
    /// This method keeps the entries of `self` in the range `[0, len)`. In particular,
    /// this method drops every entry with storage index in the range `[len, self.len())`.
    /// This method does nothing when `self.len() <= len`.
    ///
    /// # Examples
    ///
    /// Truncating a type-projected index map when `len < self.len()`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    ///     (4_usize, 5_f64),
    ///     (5_usize, 6_f64),
    ///     (6_usize, 7_f64),
    /// ]);
    ///
    /// proj_map.truncate(2);
    ///
    /// assert_eq!(proj_map.len(), 2);
    ///
    /// let expected = TypedProjVec::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    /// ]);
    /// let result: TypedProjVec<(usize, f64)> = proj_map
    ///     .iter()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result, expected);
    /// ```
    ///
    /// No truncation occurs when `len == self.len()`
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    ///     (4_usize, 5_f64),
    ///     (5_usize, 6_f64),
    ///     (6_usize, 7_f64),
    /// ]);
    ///
    /// proj_map.truncate(6);
    ///
    /// assert_eq!(proj_map.len(), 6);
    ///
    /// let expected = TypedProjVec::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    ///     (4_usize, 5_f64),
    ///     (5_usize, 6_f64),
    ///     (6_usize, 7_f64),
    /// ]);
    /// let result: TypedProjVec<(usize, f64)> = proj_map
    ///     .iter()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result, expected);
    /// ```
    ///
    /// No truncation occurs when `len > self.len()`
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    ///     (4_usize, 5_f64),
    ///     (5_usize, 6_f64),
    ///     (6_usize, 7_f64),
    /// ]);
    ///
    /// proj_map.truncate(7);
    ///
    /// assert_eq!(proj_map.len(), 6);
    ///
    /// let expected = TypedProjVec::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    ///     (4_usize, 5_f64),
    ///     (5_usize, 6_f64),
    ///     (6_usize, 7_f64),
    /// ]);
    /// let result: TypedProjVec<(usize, f64)> = proj_map
    ///     .iter()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result, expected);
    /// ```
    ///
    /// Truncating when `len == 0` is equivalent to calling the [`clear`] method.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    ///     (4_usize, 5_f64),
    ///     (5_usize, 6_f64),
    ///     (6_usize, 7_f64),
    /// ]);
    ///
    /// proj_map.truncate(0);
    ///
    /// assert_eq!(proj_map.len(), 0);
    ///
    /// let expected = TypedProjVec::from([]);
    /// let result: TypedProjVec<(usize, f64)> = proj_map
    ///     .iter()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result, expected);
    /// ```
    ///
    /// [`clear`]: TypedProjIndexMap::clear
    pub fn truncate(&mut self, len: usize) {
        self.inner.truncate(len);
    }

    /// Removes the subslice indicated by the given range from the index map,
    /// returning a double-ended iterator over the removed subslice.
    ///
    /// If the iterator is dropped before being fully consumed, it drops the remaining removed
    /// elements. The draining iterator shifts the remaining entries in the index map above the
    /// range down to fill in the removed entries.
    ///
    /// The returned iterator keeps a mutable borrow on the index map to optimize its
    /// implementation.
    ///
    /// # Panics
    ///
    /// This method panics if the range of the subslice falls outside the bounds of the collection.
    /// That is, if the starting point of the subslice being removed starts after the end of `self`,
    /// or if the ending point is larger than the length of the index map.
    ///
    /// # Leaking
    ///
    /// If the returned iterator goes out of scope without being dropped (due to
    /// [`mem::forget`], for example), the index map may have lost and leaked
    /// elements arbitrarily, including elements outside the range.
    ///
    /// # Examples
    ///
    /// Draining part of a type-projected index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    ///     (4_usize, 5_f64),
    ///     (5_usize, 6_f64),
    ///     (6_usize, 7_f64),
    /// ]);
    ///
    /// assert_eq!(proj_map.len(), 6);
    ///
    /// let drained_entries: TypedProjVec<(usize, f64)> = proj_map.drain(2..).collect();
    ///
    /// assert_eq!(proj_map.len(), 2);
    /// assert_eq!(drained_entries.len(), 4);
    ///
    /// let expected_map_entries = TypedProjVec::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    /// ]);
    /// let result_map_entries: TypedProjVec<(usize, f64)> = proj_map
    ///     .iter()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result_map_entries, expected_map_entries);
    ///
    /// let expected_drained_entries: TypedProjVec<(usize, f64)> = TypedProjVec::from([
    ///     (3_usize, 4_f64),
    ///     (4_usize, 5_f64),
    ///     (5_usize, 6_f64),
    ///     (6_usize, 7_f64),
    /// ]);
    ///
    /// assert_eq!(drained_entries.as_slice(), expected_drained_entries.as_slice());
    /// ```
    ///
    /// Draining an entire type-projected index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    ///     (4_usize, 5_f64),
    ///     (5_usize, 6_f64),
    ///     (6_usize, 7_f64),
    /// ]);
    ///
    /// assert_eq!(proj_map.len(), 6);
    ///
    /// let drained_entries: TypedProjVec<(usize, f64)> = proj_map.drain(..).collect();
    ///
    /// assert_eq!(proj_map.len(), 0);
    /// assert_eq!(drained_entries.len(), 6);
    ///
    /// let expected_map_entries = TypedProjVec::from([]);
    /// let result_map_entries: TypedProjVec<(usize, f64)> = proj_map
    ///     .iter()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result_map_entries, expected_map_entries);
    ///
    /// let expected_drained_entries: TypedProjVec<(usize, f64)> = TypedProjVec::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    ///     (4_usize, 5_f64),
    ///     (5_usize, 6_f64),
    ///     (6_usize, 7_f64),
    /// ]);
    ///
    /// assert_eq!(drained_entries.as_slice(), expected_drained_entries.as_slice());
    /// ```
    ///
    /// Draining no part of a type-projected index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    ///     (4_usize, 5_f64),
    ///     (5_usize, 6_f64),
    ///     (6_usize, 7_f64),
    /// ]);
    ///
    /// assert_eq!(proj_map.len(), 6);
    ///
    /// let drained_entries: TypedProjVec<(usize, f64)> = proj_map.drain(0..0).collect();
    ///
    /// assert_eq!(proj_map.len(), 6);
    /// assert_eq!(drained_entries.len(), 0);
    ///
    /// let expected_map_entries: TypedProjVec<(usize, f64)> = TypedProjVec::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    ///     (4_usize, 5_f64),
    ///     (5_usize, 6_f64),
    ///     (6_usize, 7_f64),
    /// ]);
    /// let result_map_entries: TypedProjVec<(usize, f64)> = proj_map
    ///     .iter()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result_map_entries, expected_map_entries);
    ///
    /// let expected_drained_entries: TypedProjVec<(usize, f64)> = TypedProjVec::from([]);
    ///
    /// assert_eq!(drained_entries.as_slice(), expected_drained_entries.as_slice());
    /// ```
    #[track_caller]
    pub fn drain<R>(&mut self, range: R) -> Drain<'_, K, V, A>
    where
        R: ops::RangeBounds<usize>,
    {
        Drain::new(self.inner.drain(range))
    }

    /// Splits a type-projected index map into two type-projected index maps at the given index.
    ///
    /// This method returns a newly allocated type-projected index map consisting of every entry
    /// from the original type-projected index map in the storage range `[at, len)`. The original
    /// type-projected index map will consist of the entries in the range `[0, at)` with its
    /// capacity unchanged.
    ///
    /// # Panics
    ///
    /// This method panics if `at > self.len()`.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<usize, f64> = TypedProjIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    ///     (4_usize, 5_f64),
    ///     (5_usize, 6_f64),
    ///     (6_usize, 7_f64),
    /// ]);
    ///
    /// assert_eq!(proj_map.len(), 6);
    ///
    /// let old_capacity = proj_map.capacity();
    /// let proj_split_map = proj_map.split_off(4);
    ///
    /// assert_eq!(proj_map.len(), 4);
    /// assert_eq!(proj_map.capacity(), old_capacity);
    ///
    /// let expected_proj_map_entries: TypedProjVec<(usize, f64)> = TypedProjVec::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    ///     (4_usize, 5_f64),
    /// ]);
    /// let result_proj_map_entries: TypedProjVec<(usize, f64)> = proj_map
    ///     .iter()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result_proj_map_entries, expected_proj_map_entries);
    ///
    /// assert_eq!(proj_split_map.len(), 2);
    ///
    /// let expected_split_map_entries: TypedProjVec<(usize, f64)> = TypedProjVec::from([
    ///     (5_usize, 6_f64),
    ///     (6_usize, 7_f64),
    /// ]);
    /// let result_split_map_entries: TypedProjVec<(usize, f64)> = proj_split_map
    ///     .iter()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result_split_map_entries, expected_split_map_entries);
    /// ```
    #[must_use = "use `.truncate()` if you don't need the other map"]
    #[track_caller]
    pub fn split_off(&mut self, at: usize) -> Self
    where
        S: Clone,
        A: Clone,
    {
        Self {
            inner: self.inner.split_off(at),
        }
    }

    /// Removes an entry from a type-projected index map, moving the last entry in storage order in
    /// the collection to the index where the removed entry occupies the collection.
    ///
    /// This method behaves with respect to the lookup key `key` as follows:
    ///
    /// * If the equivalent key to `key` exists in the index map, let `index` be its storage index.
    ///   If `index < self.len() - 1`, it moves the last entry in the collection to the slot at
    ///   `index`, leaving the rest of the entries in place. If `index == self.len() - 1`, it
    ///   removes the entry from end of the collection with no reordering of the remaining entries
    ///   in the collection. The method then returns `Some(value)`, where `value` is the value
    ///   stored in the index map corresponding to the equivalent key to `key`.
    /// * If the equivalent key to `key` does not exist in the index map, the method returns
    ///   `None`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Hashing And Equivalence
    ///
    /// A **hashing type** is a triple `(X, ~, h)` where `~` is an equivalence relation on
    /// `X`, and `h` is a hash function such that
    ///
    /// ```text
    /// ∀ a :: X. ∀ b :: X. a ~ b ⇒ h(a) = h(b).
    /// ```
    ///
    /// A type `X` is a **hashable type** if there is an equivalence relation `~` and a hashing
    /// function `h` such that `(X, ~, h)` is a hashing type.
    ///
    /// Let `K` be the type of the keys of the index map `map`. Let `Q` be a data type. Let
    /// `q :: Q` be a value of type `Q`, and let `k :: K` be a key. let `X` be a hashable type. Let
    /// `f: Q → X` and `g: K → X` be functions. We say that
    /// **`q` is equivalent to `k` using `f` and `g`** if and only if
    ///
    /// ```test
    /// equiv(X, f, g)(q, k) := f(q) ∼ g(k).
    /// ```
    ///
    /// Note that by the definition of `~`
    ///
    /// ```text
    /// ∀ q :: Q. ∀ k :: K. f(q) ∼ g(k) ⇒ h(f(q)) = h(g(k)).
    /// ```
    ///
    /// This is an implication, not an equivalence, because practical hashing functions can have
    /// collisions, i.e. for a practical hashing function `h`,
    /// `∃ a, b :: X. ¬(a ~ b) ∧ h(a) = h(b)`. We say that the type
    /// **`Q` is equivalent to `K` using `f` and `g`** if and only if
    ///
    /// ```text
    /// equiv(X, f, g)(Q, K) :=
    ///     (∀ q :: Q. ∃ k :: K. equiv(X, f, g)(q, k))
    ///     ∧ (∀ k :: K. ∃ q :: Q. equiv(X, f, g)(q, k)).
    /// ```
    ///
    /// Let `X` be a hashable type. Then the type **`Q` is equivalent to the type `K` using `X`**
    /// if and only if
    ///
    /// ```text
    /// equiv(X, Q, K) := ∃ f: Q → X. ∃ g: K → X. equiv(X, f, g)(Q, K).
    /// ```
    ///
    /// Key equality is a special case of key equivalence. Let `K` be a hashable data type. Let
    /// `Q = K`, and `f = g = id`. Then
    ///
    /// ```text
    /// ∀ k1, k2 :: K. k1 = k2 = id(k1) = id(k2) ⇒ h(id(k1)) = h(id(k2)) = h(k1) = h(k2)
    /// ```
    ///
    /// so that we have `equiv(K, id, id)(K, K)` which implies `equiv(K, K, K)`, i.e. `K` is
    /// equivalent to `K` using `K` when `K` is a hashable type.
    ///
    /// Let `Q` be a type equivalent to the key type `K` using `K`. Let `f: Q → K` and `id: K → K`
    /// be the identity. We say that **`q` is equivalent to `k`** if and only if
    ///
    /// ```text
    /// equiv(q, k) := equiv(K, f, id)(q, k).
    /// ```
    ///
    /// Let `Q` be a data type equivalent to key type `K` using `K`. We say that `q` is an
    /// **equivalent element of** the map `map`, or that **`map` equivalently contains `q`** if and
    /// only if
    ///
    /// ```text
    /// q ~∈ map ⇔ ∃ i ∈ [0, map.len()). equiv(q, map[i].key()).
    /// ```
    ///
    /// If `q` is not an equivalent element of `map`, we write `q ~∉ map`.
    ///
    /// When `K` is a hashable type, we see that `k ~∈ map ⇔ k ∈ map`, so that equivalent
    /// containment indeed generalizes containment.
    ///
    /// ## Specification Definitions
    ///
    /// The set of **keys** in the map `map` is defined as
    ///
    /// ```text
    /// keys(map) := { k :: K | ∃ i ∈ [0, map.len()). map[i].key() = k }
    /// ```
    ///
    /// or equivalently
    ///
    /// ```text
    /// ∀ k :: K. (k ∈ keys(map)) ⇔ (∃ i ∈ [0, map.len()). map[i].key() = k).
    /// ```
    ///
    /// We also say that a key `k` is in the map `map` provided that
    ///
    /// ```text
    /// ∀ k :: K. k ∈ map ⇔ k ∈ keys(map).
    /// ```
    ///
    /// We say that two maps `map1` and `map2` are **equal** if and only if
    ///
    /// ```text
    /// map1 = map2 ⇔ (map1.len() = map2.len()) ∧ (∀ i ∈ [0, map1.len()). map1[i] = map2[i]).
    /// ```
    ///
    /// The **index** of an equivalent key `q :: Q` in `map` is defined by
    ///
    /// ```text
    /// index(map, q) := i such that equiv(q, map[i].key()).
    /// ```
    ///
    /// The **last entry** in the map `map` when `map` is non-empty is defined by
    ///
    /// ```text
    /// last(map) := map[map.len() - 1].
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ~∈ map_before }
    /// map.swap_remove(key)
    /// {
    ///     result = Some(map_before[index(map_before, key)])
    ///     ∧ map_after.len() = map_before.len() - 1
    ///     ∧ key ~∉ map_after
    ///     ∧ (map_after[index(map_before, key)] = last(map_before)
    ///       ∧ (∀ k ∈ keys(map_after). k ≠ last(map_before).key() ∧ ¬equiv(key, k)
    ///         ⇒ index(map_after, k) = index(map_before, k)
    ///         ∧ map_after[index(map_after, k)] = map_before[index(map_before, k)]
    ///       )
    ///     )
    /// }
    ///
    /// { key ~∉ map_before }
    /// map.swap_remove(key)
    /// { result = None ∧ map_after = map_before }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Examples
    ///
    /// Showing how swap removal happens.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    ///     (isize::MAX, f64::MAX),
    /// ]);
    /// {
    ///     let expected: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (2_isize, 3_f64),
    ///         (3_isize, 4_f64),
    ///     ]);
    ///     let mut result = proj_map.clone();
    ///     let removed = result.swap_remove(&isize::MAX);
    ///     assert_eq!(result, expected);
    ///     assert_eq!(removed, Some(f64::MAX));
    /// }
    /// {
    ///     let expected: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (2_isize, 3_f64),
    ///         (isize::MAX, f64::MAX),
    ///     ]);
    ///     let mut result = proj_map.clone();
    ///     let removed = result.swap_remove(&3_isize);
    ///     assert_eq!(result, expected);
    ///     assert_eq!(removed, Some(4_f64));
    /// }
    /// {
    ///     let expected: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (isize::MAX, f64::MAX),
    ///         (3_isize, 4_f64),
    ///     ]);
    ///     let mut result = proj_map.clone();
    ///     let removed = result.swap_remove(&2_isize);
    ///     assert_eq!(result, expected);
    ///     assert_eq!(removed, Some(3_f64));
    /// }
    /// {
    ///     let expected: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///         (isize::MAX, f64::MAX),
    ///         (2_isize, 3_f64),
    ///         (3_isize, 4_f64),
    ///     ]);
    ///     let mut result = proj_map.clone();
    ///     let removed = result.swap_remove(&1_isize);
    ///     assert_eq!(result, expected);
    ///     assert_eq!(removed, Some(2_f64));
    /// }
    /// ```
    pub fn swap_remove<Q>(&mut self, key: &Q) -> Option<V>
    where
        Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    {
        self.inner.swap_remove(key)
    }

    /// Removes an entry from a type-projected index map, moving the last entry in storage order in
    /// the collection to the index where the removed entry occupies the collection.
    ///
    /// This method behaves with respect to the lookup key `key` as follows:
    ///
    /// * If the equivalent key to `key` exists in the index map, let `index` be its storage index.
    ///   If `index < self.len() - 1`, it moves the last entry in the collection to the slot at
    ///   `index`, leaving the rest of the entries in place. If `index == self.len() - 1`, it
    ///   removes the entry from end of the collection with no reordering of the remaining entries
    ///   in the collection. The method then returns `Some((eq_key, value))`, where
    ///   `(eq_key, value)` is the key-value pair with equivalent key `eq_key` to `key` in the
    ///   index map.
    /// * If the equivalent key to `key` does not exist in the index map, the method returns
    ///   `None`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Hashing And Equivalence
    ///
    /// A **hashing type** is a triple `(X, ~, h)` where `~` is an equivalence relation on
    /// `X`, and `h` is a hash function such that
    ///
    /// ```text
    /// ∀ a :: X. ∀ b :: X. a ~ b ⇒ h(a) = h(b).
    /// ```
    ///
    /// A type `X` is a **hashable type** if there is an equivalence relation `~` and a hashing
    /// function `h` such that `(X, ~, h)` is a hashing type.
    ///
    /// Let `K` be the type of the keys of the index map `map`. Let `Q` be a data type. Let
    /// `q :: Q` be a value of type `Q`, and let `k :: K` be a key. let `X` be a hashable type. Let
    /// `f: Q → X` and `g: K → X` be functions. We say that
    /// **`q` is equivalent to `k` using `f` and `g`** if and only if
    ///
    /// ```test
    /// equiv(X, f, g)(q, k) := f(q) ∼ g(k).
    /// ```
    ///
    /// Note that by the definition of `~`
    ///
    /// ```text
    /// ∀ q :: Q. ∀ k :: K. f(q) ∼ g(k) ⇒ h(f(q)) = h(g(k)).
    /// ```
    ///
    /// This is an implication, not an equivalence, because practical hashing functions can have
    /// collisions, i.e. for a practical hashing function `h`,
    /// `∃ a, b :: X. ¬(a ~ b) ∧ h(a) = h(b)`. We say that the type
    /// **`Q` is equivalent to `K` using `f` and `g`** if and only if
    ///
    /// ```text
    /// equiv(X, f, g)(Q, K) :=
    ///     (∀ q :: Q. ∃ k :: K. equiv(X, f, g)(q, k))
    ///     ∧ (∀ k :: K. ∃ q :: Q. equiv(X, f, g)(q, k)).
    /// ```
    ///
    /// Let `X` be a hashable type. Then the type **`Q` is equivalent to the type `K` using `X`**
    /// if and only if
    ///
    /// ```text
    /// equiv(X, Q, K) := ∃ f: Q → X. ∃ g: K → X. equiv(X, f, g)(Q, K).
    /// ```
    ///
    /// Key equality is a special case of key equivalence. Let `K` be a hashable data type. Let
    /// `Q = K`, and `f = g = id`. Then
    ///
    /// ```text
    /// ∀ k1, k2 :: K. k1 = k2 = id(k1) = id(k2) ⇒ h(id(k1)) = h(id(k2)) = h(k1) = h(k2)
    /// ```
    ///
    /// so that we have `equiv(K, id, id)(K, K)` which implies `equiv(K, K, K)`, i.e. `K` is
    /// equivalent to `K` using `K` when `K` is a hashable type.
    ///
    /// Let `Q` be a type equivalent to the key type `K` using `K`. Let `f: Q → K` and `id: K → K`
    /// be the identity. We say that **`q` is equivalent to `k`** if and only if
    ///
    /// ```text
    /// equiv(q, k) := equiv(K, f, id)(q, k).
    /// ```
    ///
    /// Let `Q` be a data type equivalent to key type `K` using `K`. We say that `q` is an
    /// **equivalent element of** the map `map`, or that **`map` equivalently contains `q`** if and
    /// only if
    ///
    /// ```text
    /// q ~∈ map ⇔ ∃ i ∈ [0, map.len()). equiv(q, map[i].key()).
    /// ```
    ///
    /// If `q` is not an equivalent element of `map`, we write `q ~∉ map`.
    ///
    /// When `K` is a hashable type, we see that `k ~∈ map ⇔ k ∈ map`, so that equivalent
    /// containment indeed generalizes containment.
    ///
    /// ## Specification Definitions
    ///
    /// The set of **keys** in the map `map` is defined as
    ///
    /// ```text
    /// keys(map) := { k :: K | ∃ i ∈ [0, map.len()). map[i].key() = k }
    /// ```
    ///
    /// or equivalently
    ///
    /// ```text
    /// ∀ k :: K. (k ∈ keys(map)) ⇔ (∃ i ∈ [0, map.len()). map[i].key() = k).
    /// ```
    ///
    /// We also say that a key `k` is in the map `map` provided that
    ///
    /// ```text
    /// ∀ k :: K. k ∈ map ⇔ k ∈ keys(map).
    /// ```
    ///
    /// We say that two maps `map1` and `map2` are **equal** if and only if
    ///
    /// ```text
    /// map1 = map2 ⇔ (map1.len() = map2.len()) ∧ (∀ i ∈ [0, map1.len()). map1[i] = map2[i]).
    /// ```
    ///
    /// The **index** of an equivalent key `q` in `map` is defined by
    ///
    /// ```text
    /// index(map, q) := i such that equiv(q, map[i].key()).
    /// ```
    ///
    /// The **last entry** in the map `map` when `map` is non-empty is defined by
    ///
    /// ```text
    /// last(map) := map[map.len() - 1].
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ~∈ map_before }
    /// map.swap_remove_entry(key)
    /// {
    ///     result = Some(map_before[index(map_before, key)])
    ///     ∧ map_after.len() = map_before.len() - 1
    ///     ∧ key ~∉ map_after
    ///     ∧ (map_after[index(map_before, key)] = last(map_before)
    ///       ∧ (∀ k ∈ keys(map_after). k ≠ last(map_before).key() ∧ ¬equiv(key, k)
    ///         ⇒ index(map_after, k) = index(map_before, k)
    ///         ∧ map_after[index(map_after, k)] = map_before[index(map_before, k)]
    ///       )
    ///     )
    /// }
    ///
    /// { key ~∉ map_before }
    /// map.swap_remove_entry(key)
    /// { result = None ∧ map_after = map_before }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Examples
    ///
    /// Showing how swap removal happens.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    ///     (isize::MAX, f64::MAX),
    /// ]);
    /// {
    ///     let expected: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (2_isize, 3_f64),
    ///         (3_isize, 4_f64),
    ///     ]);
    ///     let mut result = proj_map.clone();
    ///     let removed = result.swap_remove_entry(&isize::MAX);
    ///     assert_eq!(result, expected);
    ///     assert_eq!(removed, Some((isize::MAX, f64::MAX)));
    /// }
    /// {
    ///     let expected: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (2_isize, 3_f64),
    ///         (isize::MAX, f64::MAX),
    ///     ]);
    ///     let mut result = proj_map.clone();
    ///     let removed = result.swap_remove_entry(&3_isize);
    ///     assert_eq!(result, expected);
    ///     assert_eq!(removed, Some((3_isize, 4_f64)));
    /// }
    /// {
    ///     let expected: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (isize::MAX, f64::MAX),
    ///         (3_isize, 4_f64),
    ///     ]);
    ///     let mut result = proj_map.clone();
    ///     let removed = result.swap_remove_entry(&2_isize);
    ///     assert_eq!(result, expected);
    ///     assert_eq!(removed, Some((2_isize, 3_f64)));
    /// }
    /// {
    ///     let expected: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///         (isize::MAX, f64::MAX),
    ///         (2_isize, 3_f64),
    ///         (3_isize, 4_f64),
    ///     ]);
    ///     let mut result = proj_map.clone();
    ///     let removed = result.swap_remove_entry(&1_isize);
    ///     assert_eq!(result, expected);
    ///     assert_eq!(removed, Some((1_isize, 2_f64)));
    /// }
    /// ```
    pub fn swap_remove_entry<Q>(&mut self, key: &Q) -> Option<(K, V)>
    where
        Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    {
        self.inner.swap_remove_entry(key)
    }

    /// Removes an entry from a type-projected index map, moving the last entry in storage order in
    /// the collection to the index where the removed entry occupies the collection.
    ///
    /// This method behaves with respect to the lookup key `key` as follows:
    ///
    /// * If the equivalent key to `key` exists in the index map, let `index` be its storage index.
    ///   If `index < self.len() - 1`, it moves the last entry in the collection to the slot at
    ///   `index`, leaving the rest of the entries in place. If `index == self.len() - 1`, it
    ///   removes the entry from end of the collection with no reordering of the remaining entries
    ///   in the collection. The method then returns `Some((index, eq_key, value))`, where
    ///   `(eq_key, value)` is the key-value pair with the equivalent key `eq_key` to `key `stored
    ///   in the index map.
    /// * If the equivalent key to `key` does not exist in the index map, the method returns
    ///   `None`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Hashing And Equivalence
    ///
    /// A **hashing type** is a triple `(X, ~, h)` where `~` is an equivalence relation on
    /// `X`, and `h` is a hash function such that
    ///
    /// ```text
    /// ∀ a :: X. ∀ b :: X. a ~ b ⇒ h(a) = h(b).
    /// ```
    ///
    /// A type `X` is a **hashable type** if there is an equivalence relation `~` and a hashing
    /// function `h` such that `(X, ~, h)` is a hashing type.
    ///
    /// Let `K` be the type of the keys of the index map `map`. Let `Q` be a data type. Let
    /// `q :: Q` be a value of type `Q`, and let `k :: K` be a key. let `X` be a hashable type. Let
    /// `f: Q → X` and `g: K → X` be functions. We say that
    /// **`q` is equivalent to `k` using `f` and `g`** if and only if
    ///
    /// ```test
    /// equiv(X, f, g)(q, k) := f(q) ∼ g(k).
    /// ```
    ///
    /// Note that by the definition of `~`
    ///
    /// ```text
    /// ∀ q :: Q. ∀ k :: K. f(q) ∼ g(k) ⇒ h(f(q)) = h(g(k)).
    /// ```
    ///
    /// This is an implication, not an equivalence, because practical hashing functions can have
    /// collisions, i.e. for a practical hashing function `h`,
    /// `∃ a, b :: X. ¬(a ~ b) ∧ h(a) = h(b)`. We say that the type
    /// **`Q` is equivalent to `K` using `f` and `g`** if and only if
    ///
    /// ```text
    /// equiv(X, f, g)(Q, K) :=
    ///     (∀ q :: Q. ∃ k :: K. equiv(X, f, g)(q, k))
    ///     ∧ (∀ k :: K. ∃ q :: Q. equiv(X, f, g)(q, k)).
    /// ```
    ///
    /// Let `X` be a hashable type. Then the type **`Q` is equivalent to the type `K` using `X`**
    /// if and only if
    ///
    /// ```text
    /// equiv(X, Q, K) := ∃ f: Q → X. ∃ g: K → X. equiv(X, f, g)(Q, K).
    /// ```
    ///
    /// Key equality is a special case of key equivalence. Let `K` be a hashable data type. Let
    /// `Q = K`, and `f = g = id`. Then
    ///
    /// ```text
    /// ∀ k1, k2 :: K. k1 = k2 = id(k1) = id(k2) ⇒ h(id(k1)) = h(id(k2)) = h(k1) = h(k2)
    /// ```
    ///
    /// so that we have `equiv(K, id, id)(K, K)` which implies `equiv(K, K, K)`, i.e. `K` is
    /// equivalent to `K` using `K` when `K` is a hashable type.
    ///
    /// Let `Q` be a type equivalent to the key type `K` using `K`. Let `f: Q → K` and `id: K → K`
    /// be the identity. We say that **`q` is equivalent to `k`** if and only if
    ///
    /// ```text
    /// equiv(q, k) := equiv(K, f, id)(q, k).
    /// ```
    ///
    /// Let `Q` be a data type equivalent to key type `K` using `K`. We say that `q` is an
    /// **equivalent element of** the map `map`, or that **`map` equivalently contains `q`** if and
    /// only if
    ///
    /// ```text
    /// q ~∈ map ⇔ ∃ i ∈ [0, map.len()). equiv(q, map[i].key()).
    /// ```
    ///
    /// If `q` is not an equivalent element of `map`, we write `q ~∉ map`.
    ///
    /// When `K` is a hashable type, we see that `k ~∈ map ⇔ k ∈ map`, so that equivalent
    /// containment indeed generalizes containment.
    ///
    /// ## Specification Definitions
    ///
    /// The set of **keys** in the map `map` is defined as
    ///
    /// ```text
    /// keys(map) := { k :: K | ∃ i ∈ [0, map.len()). map[i].key() = k }
    /// ```
    ///
    /// or equivalently
    ///
    /// ```text
    /// ∀ k :: K. (k ∈ keys(map)) ⇔ (∃ i ∈ [0, map.len()). map[i].key() = k).
    /// ```
    ///
    /// We also say that a key `k` is in the map `map` provided that
    ///
    /// ```text
    /// ∀ k :: K. k ∈ map ⇔ k ∈ keys(map).
    /// ```
    ///
    /// We say that two maps `map1` and `map2` are **equal** if and only if
    ///
    /// ```text
    /// map1 = map2 ⇔ (map1.len() = map2.len()) ∧ (∀ i ∈ [0, map1.len()). map1[i] = map2[i]).
    /// ```
    ///
    /// The **index** of an equivalent key `q` in `map` is defined by
    ///
    /// ```text
    /// index(map, q) := i such that equiv(q, map[i].key()).
    /// ```
    ///
    /// The **last entry** in the map `map` when `map` is non-empty is defined by
    ///
    /// ```text
    /// last(map) := map[map.len() - 1].
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ~∈ map_before }
    /// map.swap_remove_full(key)
    /// {
    ///     result = Some(map_before[index(map_before, key)])
    ///     ∧ map_after.len() = map_before.len() - 1
    ///     ∧ key ~∉ map_after
    ///     ∧ (map_after[index(map_before, key)] = last(map_before)
    ///       ∧ (∀ k ∈ keys(map_after). k ≠ last(map_before).key() ∧ ¬equiv(key, k)
    ///         ⇒ index(map_after, k) = index(map_before, k)
    ///         ∧ map_after[index(map_after, k)] = map_before[index(map_before, k)]
    ///       )
    ///     )
    /// }
    ///
    /// { key ~∉ map_before }
    /// map.swap_remove_full(key)
    /// { result = None ∧ map_after = map_before }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Examples
    ///
    /// Showing how swap removal happens.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    ///     (isize::MAX, f64::MAX),
    /// ]);
    /// {
    ///     let expected: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (2_isize, 3_f64),
    ///         (3_isize, 4_f64),
    ///     ]);
    ///     let mut result = proj_map.clone();
    ///     let removed = result.swap_remove_full(&isize::MAX);
    ///     assert_eq!(result, expected);
    ///     assert_eq!(removed, Some((3, isize::MAX, f64::MAX)));
    /// }
    /// {
    ///     let expected: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (2_isize, 3_f64),
    ///         (isize::MAX, f64::MAX),
    ///     ]);
    ///     let mut result = proj_map.clone();
    ///     let removed = result.swap_remove_full(&3_isize);
    ///     assert_eq!(result, expected);
    ///     assert_eq!(removed, Some((2, 3_isize, 4_f64)));
    /// }
    /// {
    ///     let expected: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (isize::MAX, f64::MAX),
    ///         (3_isize, 4_f64),
    ///     ]);
    ///     let mut result = proj_map.clone();
    ///     let removed = result.swap_remove_full(&2_isize);
    ///     assert_eq!(result, expected);
    ///     assert_eq!(removed, Some((1, 2_isize, 3_f64)));
    /// }
    /// {
    ///     let expected: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///         (isize::MAX, f64::MAX),
    ///         (2_isize, 3_f64),
    ///         (3_isize, 4_f64),
    ///     ]);
    ///     let mut result = proj_map.clone();
    ///     let removed = result.swap_remove_full(&1_isize);
    ///     assert_eq!(result, expected);
    ///     assert_eq!(removed, Some((0, 1_isize, 2_f64)));
    /// }
    /// ```
    pub fn swap_remove_full<Q>(&mut self, key: &Q) -> Option<(usize, K, V)>
    where
        Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    {
        self.inner.swap_remove_full(key)
    }

    /// Removes an entry from a type-projected index map, shifting every successive entry in the
    /// collection in storage order down one index to fill where the removed entry occupies the
    /// collection.
    ///
    /// This method behaves with respect to the lookup key `key` as follows:
    ///
    /// * If the equivalent key to `key` exists in the index map, let `index` be its storage index.
    ///   If `index < self.len() - 1`, it moves every successive entry in the collection to the
    ///   entry at storage index `index` down one unit. Every entry preceding the entry at index
    ///   `index` remains in the same location. The method returns `Some(value)`, where `value` is
    ///    the value stored in the entry with equivalent key to key `key` in the index map.
    /// * If the equivalent key to `key` does not exist in the index map, the method returns
    ///   `None`.
    ///
    /// In particular, the method acts like a [`pop`] when the last value in the collection is
    /// shift-removed, because the sub-collection of successor entries in the entry storage is
    /// empty.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Hashing And Equivalence
    ///
    /// A **hashing type** is a triple `(X, ~, h)` where `~` is an equivalence relation on
    /// `X`, and `h` is a hash function such that
    ///
    /// ```text
    /// ∀ a :: X. ∀ b :: X. a ~ b ⇒ h(a) = h(b).
    /// ```
    ///
    /// A type `X` is a **hashable type** if there is an equivalence relation `~` and a hashing
    /// function `h` such that `(X, ~, h)` is a hashing type.
    ///
    /// Let `K` be the type of the keys of the index map `map`. Let `Q` be a data type. Let
    /// `q :: Q` be a value of type `Q`, and let `k :: K` be a key. let `X` be a hashable type. Let
    /// `f: Q → X` and `g: K → X` be functions. We say that
    /// **`q` is equivalent to `k` using `f` and `g`** if and only if
    ///
    /// ```test
    /// equiv(X, f, g)(q, k) := f(q) ∼ g(k).
    /// ```
    ///
    /// Note that by the definition of `~`
    ///
    /// ```text
    /// ∀ q :: Q. ∀ k :: K. f(q) ∼ g(k) ⇒ h(f(q)) = h(g(k)).
    /// ```
    ///
    /// This is an implication, not an equivalence, because practical hashing functions can have
    /// collisions, i.e. for a practical hashing function `h`,
    /// `∃ a, b :: X. ¬(a ~ b) ∧ h(a) = h(b)`. We say that the type
    /// **`Q` is equivalent to `K` using `f` and `g`** if and only if
    ///
    /// ```text
    /// equiv(X, f, g)(Q, K) :=
    ///     (∀ q :: Q. ∃ k :: K. equiv(X, f, g)(q, k))
    ///     ∧ (∀ k :: K. ∃ q :: Q. equiv(X, f, g)(q, k)).
    /// ```
    ///
    /// Let `X` be a hashable type. Then the type **`Q` is equivalent to the type `K` using `X`**
    /// if and only if
    ///
    /// ```text
    /// equiv(X, Q, K) := ∃ f: Q → X. ∃ g: K → X. equiv(X, f, g)(Q, K).
    /// ```
    ///
    /// Key equality is a special case of key equivalence. Let `K` be a hashable data type. Let
    /// `Q = K`, and `f = g = id`. Then
    ///
    /// ```text
    /// ∀ k1, k2 :: K. k1 = k2 = id(k1) = id(k2) ⇒ h(id(k1)) = h(id(k2)) = h(k1) = h(k2)
    /// ```
    ///
    /// so that we have `equiv(K, id, id)(K, K)` which implies `equiv(K, K, K)`, i.e. `K` is
    /// equivalent to `K` using `K` when `K` is a hashable type.
    ///
    /// Let `Q` be a type equivalent to the key type `K` using `K`. Let `f: Q → K` and `id: K → K`
    /// be the identity. We say that **`q` is equivalent to `k`** if and only if
    ///
    /// ```text
    /// equiv(q, k) := equiv(K, f, id)(q, k).
    /// ```
    ///
    /// Let `Q` be a data type equivalent to key type `K` using `K`. We say that `q` is an
    /// **equivalent element of** the map `map`, or that **`map` equivalently contains `q`** if and
    /// only if
    ///
    /// ```text
    /// q ~∈ map ⇔ ∃ i ∈ [0, map.len()). equiv(q, map[i].key()).
    /// ```
    ///
    /// If `q` is not an equivalent element of `map`, we write `q ~∉ map`.
    ///
    /// When `K` is a hashable type, we see that `k ~∈ map ⇔ k ∈ map`, so that equivalent
    /// containment indeed generalizes containment.
    ///
    /// ## Specification Definitions
    ///
    /// The set of **keys** in the map `map` is defined as
    ///
    /// ```text
    /// keys(map) := { k :: K | ∃ i ∈ [0, map.len()). map[i].key() = k }
    /// ```
    ///
    /// or equivalently
    ///
    /// ```text
    /// ∀ k :: K. (k ∈ keys(map)) ⇔ (∃ i ∈ [0, map.len()). map[i].key() = k).
    /// ```
    ///
    /// We also say that a key `k` is in the map `map` provided that
    ///
    /// ```text
    /// ∀ k :: K. k ∈ map ⇔ k ∈ keys(map).
    /// ```
    ///
    /// We say that two maps `map1` and `map2` are **equal** if and only if
    ///
    /// ```text
    /// map1 = map2 ⇔ (map1.len() = map2.len()) ∧ (∀ i ∈ [0, map1.len()). map1[i] = map2[i]).
    /// ```
    ///
    /// The **index** of an equivalent key `q` in `map` is defined by
    ///
    /// ```text
    /// index(map, q) := i such that equiv(q, map[i].key()).
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ~∈ map_before }
    /// map.shift_remove(key)
    /// {
    ///     result = Some(map_before[index(map_before, key)])
    ///     ∧ map_after.len() = map_before.len() - 1
    ///     ∧ key ~∉ map_after
    ///     ∧ ((∀ j ∈ [0, index(map_before, key)). map_after[j] = map_before[j])
    ///        ∧ (∀ j ∈ [index(map_before, key), map_after.len()). map_after[j] = map_before[j + 1])
    ///     )
    /// }
    ///
    /// { key ~∉ map_before }
    /// map.shift_remove(key)
    /// { result = None ∧ map_after = map_before }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Examples
    ///
    /// Showing how shift removal happens.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    ///     (isize::MAX, f64::MAX),
    /// ]);
    /// {
    ///     let expected: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (2_isize, 3_f64),
    ///         (3_isize, 4_f64),
    ///     ]);
    ///     let mut result = proj_map.clone();
    ///     let removed = result.shift_remove(&isize::MAX);
    ///     assert_eq!(result, expected);
    ///     assert_eq!(removed, Some(f64::MAX));
    /// }
    /// {
    ///     let expected: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (2_isize, 3_f64),
    ///         (isize::MAX, f64::MAX),
    ///     ]);
    ///     let mut result = proj_map.clone();
    ///     let removed = result.shift_remove(&3_isize);
    ///     assert_eq!(result, expected);
    ///     assert_eq!(removed, Some(4_f64));
    /// }
    /// {
    ///     let expected: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (3_isize, 4_f64),
    ///         (isize::MAX, f64::MAX),
    ///     ]);
    ///     let mut result = proj_map.clone();
    ///     let removed = result.shift_remove(&2_isize);
    ///     assert_eq!(result, expected);
    ///     assert_eq!(removed, Some(3_f64));
    /// }
    /// {
    ///     let expected: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///         (2_isize, 3_f64),
    ///         (3_isize, 4_f64),
    ///         (isize::MAX, f64::MAX),
    ///     ]);
    ///     let mut result = proj_map.clone();
    ///     let removed = result.shift_remove(&1_isize);
    ///     assert_eq!(result, expected);
    ///     assert_eq!(removed, Some(2_f64));
    /// }
    /// ```
    ///
    /// [`pop`]: TypedProjIndexMap::pop
    pub fn shift_remove<Q>(&mut self, key: &Q) -> Option<V>
    where
        Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    {
        self.inner.shift_remove(key)
    }

    /// Removes an entry from a type-projected index map, shifting every successive entry in the
    /// collection in storage order down one index to fill where the removed entry occupies the
    /// collection.
    ///
    /// This method behaves with respect to the lookup key `key` as follows:
    ///
    /// * If the equivalent key to `key` exists in the index map, let `index` be its storage index.
    ///   If `index < self.len() - 1`, it moves every successive entry in the collection to the
    ///   entry at storage index `index` down one unit. Every entry preceding the entry at index
    ///   `index` remains in the same location. The method returns `Some((eq_key, value))`, where
    ///   `(eq_key, value)` is the key-value pair with equivalent key `eq_key` to `key` in the
    ///   index map.
    /// * If the equivalent key to `key` does not exist in the index map, the method returns
    ///   `None`.
    ///
    /// In particular, the method acts like a [`pop`] when the last value in the collection is
    /// shift-removed, because the sub-collection of successor entries in the entry storage is
    /// empty.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Hashing And Equivalence
    ///
    /// A **hashing type** is a triple `(X, ~, h)` where `~` is an equivalence relation on
    /// `X`, and `h` is a hash function such that
    ///
    /// ```text
    /// ∀ a :: X. ∀ b :: X. a ~ b ⇒ h(a) = h(b).
    /// ```
    ///
    /// A type `X` is a **hashable type** if there is an equivalence relation `~` and a hashing
    /// function `h` such that `(X, ~, h)` is a hashing type.
    ///
    /// Let `K` be the type of the keys of the index map `map`. Let `Q` be a data type. Let
    /// `q :: Q` be a value of type `Q`, and let `k :: K` be a key. let `X` be a hashable type. Let
    /// `f: Q → X` and `g: K → X` be functions. We say that
    /// **`q` is equivalent to `k` using `f` and `g`** if and only if
    ///
    /// ```test
    /// equiv(X, f, g)(q, k) := f(q) ∼ g(k).
    /// ```
    ///
    /// Note that by the definition of `~`
    ///
    /// ```text
    /// ∀ q :: Q. ∀ k :: K. f(q) ∼ g(k) ⇒ h(f(q)) = h(g(k)).
    /// ```
    ///
    /// This is an implication, not an equivalence, because practical hashing functions can have
    /// collisions, i.e. for a practical hashing function `h`,
    /// `∃ a, b :: X. ¬(a ~ b) ∧ h(a) = h(b)`. We say that the type
    /// **`Q` is equivalent to `K` using `f` and `g`** if and only if
    ///
    /// ```text
    /// equiv(X, f, g)(Q, K) :=
    ///     (∀ q :: Q. ∃ k :: K. equiv(X, f, g)(q, k))
    ///     ∧ (∀ k :: K. ∃ q :: Q. equiv(X, f, g)(q, k)).
    /// ```
    ///
    /// Let `X` be a hashable type. Then the type **`Q` is equivalent to the type `K` using `X`**
    /// if and only if
    ///
    /// ```text
    /// equiv(X, Q, K) := ∃ f: Q → X. ∃ g: K → X. equiv(X, f, g)(Q, K).
    /// ```
    ///
    /// Key equality is a special case of key equivalence. Let `K` be a hashable data type. Let
    /// `Q = K`, and `f = g = id`. Then
    ///
    /// ```text
    /// ∀ k1, k2 :: K. k1 = k2 = id(k1) = id(k2) ⇒ h(id(k1)) = h(id(k2)) = h(k1) = h(k2)
    /// ```
    ///
    /// so that we have `equiv(K, id, id)(K, K)` which implies `equiv(K, K, K)`, i.e. `K` is
    /// equivalent to `K` using `K` when `K` is a hashable type.
    ///
    /// Let `Q` be a type equivalent to the key type `K` using `K`. Let `f: Q → K` and `id: K → K`
    /// be the identity. We say that **`q` is equivalent to `k`** if and only if
    ///
    /// ```text
    /// equiv(q, k) := equiv(K, f, id)(q, k).
    /// ```
    ///
    /// Let `Q` be a data type equivalent to key type `K` using `K`. We say that `q` is an
    /// **equivalent element of** the map `map`, or that **`map` equivalently contains `q`** if and
    /// only if
    ///
    /// ```text
    /// q ~∈ map ⇔ ∃ i ∈ [0, map.len()). equiv(q, map[i].key()).
    /// ```
    ///
    /// If `q` is not an equivalent element of `map`, we write `q ~∉ map`.
    ///
    /// When `K` is a hashable type, we see that `k ~∈ map ⇔ k ∈ map`, so that equivalent
    /// containment indeed generalizes containment.
    ///
    /// ## Specification Definitions
    ///
    /// The set of **keys** in the map `map` is defined as
    ///
    /// ```text
    /// keys(map) := { k :: K | ∃ i ∈ [0, map.len()). map[i].key() = k }
    /// ```
    ///
    /// or equivalently
    ///
    /// ```text
    /// ∀ k :: K. (k ∈ keys(map)) ⇔ (∃ i ∈ [0, map.len()). map[i].key() = k).
    /// ```
    ///
    /// We also say that a key `k` is in the map `map` provided that
    ///
    /// ```text
    /// ∀ k :: K. k ∈ map ⇔ k ∈ keys(map).
    /// ```
    ///
    /// We say that two maps `map1` and `map2` are **equal** if and only if
    ///
    /// ```text
    /// map1 = map2 ⇔ (map1.len() = map2.len()) ∧ (∀ i ∈ [0, map1.len()). map1[i] = map2[i]).
    /// ```
    ///
    /// The **index** of an equivalent key `q` in `map` is defined by
    ///
    /// ```text
    /// index(map, q) := i such that equiv(q, map[i].key()).
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ~∈ map_before }
    /// map.shift_remove_entry(key)
    /// {
    ///     result = Some(map_before[index(map_before, key)])
    ///     ∧ map_after.len() = map_before.len() - 1
    ///     ∧ key ∉ map_after
    ///     ∧ ((∀ j ∈ [0, index(map_before, key)). map_after[j] = map_before[j])
    ///        ∧ (∀ j ∈ [index(map_before, key), map_after.len()). map_after[j] = map_before[j + 1])
    ///     )
    /// }
    ///
    /// { key ~∉ map_before }
    /// map.shift_remove_entry(key)
    /// { result = None ∧ map_after = map_before }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Examples
    ///
    /// Showing how shift removal happens.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    ///     (isize::MAX, f64::MAX),
    /// ]);
    /// {
    ///     let expected: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (2_isize, 3_f64),
    ///         (3_isize, 4_f64),
    ///     ]);
    ///     let mut result = proj_map.clone();
    ///     let removed = result.shift_remove_entry(&isize::MAX);
    ///     assert_eq!(result, expected);
    ///     assert_eq!(removed, Some((isize::MAX, f64::MAX)));
    /// }
    /// {
    ///     let expected: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (2_isize, 3_f64),
    ///         (isize::MAX, f64::MAX),
    ///     ]);
    ///     let mut result = proj_map.clone();
    ///     let removed = result.shift_remove_entry(&3_isize);
    ///     assert_eq!(result, expected);
    ///     assert_eq!(removed, Some((3_isize, 4_f64)));
    /// }
    /// {
    ///     let expected: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (3_isize, 4_f64),
    ///         (isize::MAX, f64::MAX),
    ///     ]);
    ///     let mut result = proj_map.clone();
    ///     let removed = result.shift_remove_entry(&2_isize);
    ///     assert_eq!(result, expected);
    ///     assert_eq!(removed, Some((2_isize, 3_f64)));
    /// }
    /// {
    ///     let expected: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///         (2_isize, 3_f64),
    ///         (3_isize, 4_f64),
    ///         (isize::MAX, f64::MAX),
    ///     ]);
    ///     let mut result = proj_map.clone();
    ///     let removed = result.shift_remove_entry(&1_isize);
    ///     assert_eq!(result, expected);
    ///     assert_eq!(removed, Some((1_isize, 2_f64)));
    /// }
    /// ```
    ///
    /// [`pop`]: TypedProjIndexMap::pop
    pub fn shift_remove_entry<Q>(&mut self, key: &Q) -> Option<(K, V)>
    where
        Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    {
        self.inner.shift_remove_entry(key)
    }

    /// Removes an entry from a type-projected index map, shifting every successive entry in the
    /// collection in storage order down one index to fill where the removed entry occupies the
    /// collection.
    ///
    /// This method behaves with respect to the lookup key `key` as follows:
    ///
    /// * If the equivalent key to `key` exists in the index map, let `index` be its storage index.
    ///   If `index < self.len() - 1`, it moves every successive entry in the collection to the
    ///   entry at storage index `index` down one unit. Every entry preceding the entry at index
    ///   `index` remains in the same location. The method returns `Some((index, eq_key, value))`,
    ///   where `(eq_key, value)` is the key-value pair with equivalent key `eq_key` to `key` in
    ///   the index map.
    /// * If the key `key` does not exist in the index map, the method returns `None`.
    ///
    /// In particular, the method acts like a [`pop`] when the last value in the collection is
    /// shift-removed, because the sub-collection of successor entries in the entry storage is
    /// empty.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Hashing And Equivalence
    ///
    /// A **hashing type** is a triple `(X, ~, h)` where `~` is an equivalence relation on
    /// `X`, and `h` is a hash function such that
    ///
    /// ```text
    /// ∀ a :: X. ∀ b :: X. a ~ b ⇒ h(a) = h(b).
    /// ```
    ///
    /// A type `X` is a **hashable type** if there is an equivalence relation `~` and a hashing
    /// function `h` such that `(X, ~, h)` is a hashing type.
    ///
    /// Let `K` be the type of the keys of the index map `map`. Let `Q` be a data type. Let
    /// `q :: Q` be a value of type `Q`, and let `k :: K` be a key. let `X` be a hashable type. Let
    /// `f: Q → X` and `g: K → X` be functions. We say that
    /// **`q` is equivalent to `k` using `f` and `g`** if and only if
    ///
    /// ```test
    /// equiv(X, f, g)(q, k) := f(q) ∼ g(k).
    /// ```
    ///
    /// Note that by the definition of `~`
    ///
    /// ```text
    /// ∀ q :: Q. ∀ k :: K. f(q) ∼ g(k) ⇒ h(f(q)) = h(g(k)).
    /// ```
    ///
    /// This is an implication, not an equivalence, because practical hashing functions can have
    /// collisions, i.e. for a practical hashing function `h`,
    /// `∃ a, b :: X. ¬(a ~ b) ∧ h(a) = h(b)`. We say that the type
    /// **`Q` is equivalent to `K` using `f` and `g`** if and only if
    ///
    /// ```text
    /// equiv(X, f, g)(Q, K) :=
    ///     (∀ q :: Q. ∃ k :: K. equiv(X, f, g)(q, k))
    ///     ∧ (∀ k :: K. ∃ q :: Q. equiv(X, f, g)(q, k)).
    /// ```
    ///
    /// Let `X` be a hashable type. Then the type **`Q` is equivalent to the type `K` using `X`**
    /// if and only if
    ///
    /// ```text
    /// equiv(X, Q, K) := ∃ f: Q → X. ∃ g: K → X. equiv(X, f, g)(Q, K).
    /// ```
    ///
    /// Key equality is a special case of key equivalence. Let `K` be a hashable data type. Let
    /// `Q = K`, and `f = g = id`. Then
    ///
    /// ```text
    /// ∀ k1, k2 :: K. k1 = k2 = id(k1) = id(k2) ⇒ h(id(k1)) = h(id(k2)) = h(k1) = h(k2)
    /// ```
    ///
    /// so that we have `equiv(K, id, id)(K, K)` which implies `equiv(K, K, K)`, i.e. `K` is
    /// equivalent to `K` using `K` when `K` is a hashable type.
    ///
    /// Let `Q` be a type equivalent to the key type `K` using `K`. Let `f: Q → K` and `id: K → K`
    /// be the identity. We say that **`q` is equivalent to `k`** if and only if
    ///
    /// ```text
    /// equiv(q, k) := equiv(K, f, id)(q, k).
    /// ```
    ///
    /// Let `Q` be a data type equivalent to key type `K` using `K`. We say that `q` is an
    /// **equivalent element of** the map `map`, or that **`map` equivalently contains `q`** if and
    /// only if
    ///
    /// ```text
    /// q ~∈ map ⇔ ∃ i ∈ [0, map.len()). equiv(q, map[i].key()).
    /// ```
    ///
    /// If `q` is not an equivalent element of `map`, we write `q ~∉ map`.
    ///
    /// When `K` is a hashable type, we see that `k ~∈ map ⇔ k ∈ map`, so that equivalent
    /// containment indeed generalizes containment.
    ///
    /// ## Specification Definitions
    ///
    /// The set of **keys** in the map `map` is defined as
    ///
    /// ```text
    /// keys(map) := { k :: K | ∃ i ∈ [0, map.len()). map[i].key() = k }
    /// ```
    ///
    /// or equivalently
    ///
    /// ```text
    /// ∀ k :: K. (k ∈ keys(map)) ⇔ (∃ i ∈ [0, map.len()). map[i].key() = k).
    /// ```
    ///
    /// We also say that a key `k` is in the map `map` provided that
    ///
    /// ```text
    /// ∀ k :: K. k ∈ map ⇔ k ∈ keys(map).
    /// ```
    ///
    /// We say that two maps `map1` and `map2` are **equal** if and only if
    ///
    /// ```text
    /// map1 = map2 ⇔ (map1.len() = map2.len()) ∧ (∀ i ∈ [0, map1.len()). map1[i] = map2[i]).
    /// ```
    ///
    /// The **index** of an equivalent key `q` in `map` is defined by
    ///
    /// ```text
    /// index(map, q) := i such that equiv(q, map[i].key()).
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ∈ map_before }
    /// map.shift_remove_full(key)
    /// {
    ///     result = Some(map_before[index(map_before, key)])
    ///     ∧ map_after.len() = map_before.len() - 1
    ///     ∧ key ∉ map_after
    ///     ∧ ((∀ j ∈ [0, index(map_before, key)). map_after[j] = map_before[j])
    ///        ∧ (∀ j ∈ [index(map_before, key), map_after.len()). map_after[j] = map_before[j + 1])
    ///     )
    /// }
    ///
    /// { key ∉ map_before }
    /// map.shift_remove_full(key)
    /// { result = None ∧ map_after = map_before }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Examples
    ///
    /// Showing how shift removal happens.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    ///     (isize::MAX, f64::MAX),
    /// ]);
    /// {
    ///     let expected: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (2_isize, 3_f64),
    ///         (3_isize, 4_f64),
    ///     ]);
    ///     let mut result = proj_map.clone();
    ///     let removed = result.shift_remove_full(&isize::MAX);
    ///     assert_eq!(result, expected);
    ///     assert_eq!(removed, Some((3, isize::MAX, f64::MAX)));
    /// }
    /// {
    ///     let expected: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (2_isize, 3_f64),
    ///         (isize::MAX, f64::MAX),
    ///     ]);
    ///     let mut result = proj_map.clone();
    ///     let removed = result.shift_remove_full(&3_isize);
    ///     assert_eq!(result, expected);
    ///     assert_eq!(removed, Some((2, 3_isize, 4_f64)));
    /// }
    /// {
    ///     let expected: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (3_isize, 4_f64),
    ///         (isize::MAX, f64::MAX),
    ///     ]);
    ///     let mut result = proj_map.clone();
    ///     let removed = result.shift_remove_full(&2_isize);
    ///     assert_eq!(result, expected);
    ///     assert_eq!(removed, Some((1, 2_isize, 3_f64)));
    /// }
    /// {
    ///     let expected: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///         (2_isize, 3_f64),
    ///         (3_isize, 4_f64),
    ///         (isize::MAX, f64::MAX),
    ///     ]);
    ///     let mut result = proj_map.clone();
    ///     let removed = result.shift_remove_full(&1_isize);
    ///     assert_eq!(result, expected);
    ///     assert_eq!(removed, Some((0, 1_isize, 2_f64)));
    /// }
    /// ```
    ///
    /// [`pop`]: TypedProjIndexMap::pop
    pub fn shift_remove_full<Q>(&mut self, key: &Q) -> Option<(usize, K, V)>
    where
        Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    {
        self.inner.shift_remove_full(key)
    }

    /// Returns a slice of all the key-value pairs in the index map.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<isize, &'static str> = TypedProjIndexMap::from([
    ///     (-1_isize, "foo"),
    ///     ( 0_isize, "bar"),
    ///     ( 1_isize, "baz"),
    /// ]);
    /// let slice = proj_map.as_slice();
    ///
    /// assert_eq!(slice.get_index(0), Some((&-1_isize, &"foo")));
    /// assert_eq!(slice.get_index(1), Some((&0_isize,  &"bar")));
    /// assert_eq!(slice.get_index(2), Some((&1_isize,  &"baz")));
    ///
    /// assert_eq!(slice[0], "foo");
    /// assert_eq!(slice[1], "bar");
    /// assert_eq!(slice[2], "baz");
    /// ```
    pub fn as_slice(&self) -> &'_ Slice<K, V> {
        Slice::from_slice(self.inner.as_slice())
    }

    /// Returns a mutable slice of all the key-value pairs in the index map.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<isize, &'static str> = TypedProjIndexMap::from([
    ///     (-1, "foo"),
    ///     ( 0, "bar"),
    ///     ( 1, "baz"),
    /// ]);
    /// let slice = proj_map.as_mut_slice();
    ///
    /// assert_eq!(slice.get_index(0), Some((&-1, &"foo")));
    /// assert_eq!(slice.get_index(1), Some((&0,  &"bar")));
    /// assert_eq!(slice.get_index(2), Some((&1,  &"baz")));
    ///
    /// assert_eq!(slice[0], "foo");
    /// assert_eq!(slice[1], "bar");
    /// assert_eq!(slice[2], "baz");
    /// ```
    pub fn as_mut_slice(&mut self) -> &mut Slice<K, V> {
        Slice::from_slice_mut(self.inner.as_mut_slice())
    }
}

impl<K, V, S, A> TypedProjIndexMap<K, V, S, A>
where
    K: any::Any,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    /// Inserts a new entry into the index map.
    ///
    /// This method behaves as follows:
    ///
    /// * If the equivalent key already exists in the index map, this method replaces the old value
    ///   with the new value in the map, and returns the old value as `Some(old_value)`. The entry
    ///   retains its position in the storage order of the index map.
    /// * If the entry with the equivalent key does not exist in the map, it is appended to the end
    ///   of the map, so the resulting entry is in last place in the storage order, and the method
    ///   returns `None`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Specification Definitions
    ///
    /// We say that a key `k` is in the map `map` provided that
    ///
    /// ```text
    /// ∀ k :: K. (k ∈ map) ⇔ (∃ i ∈ [0, map.len()). map[i].key() = k).
    /// ```
    ///
    /// The **index** of a key `k` in `map` is defined by
    ///
    /// ```text
    /// index(map, k) := i such that map[i].key() = k.
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ∈ map_before }
    /// map.insert(key, value)
    /// {
    ///     result = Some(map_before[index(map_before, key)])
    ///     ∧ map_after.len() = map_before.len()
    ///     ∧ map_after[index(map_after, key)] = value
    ///     ∧ (∀ k ∈ map_before. k ≠ key ⇒ index(map_after, k) = index(map_before, k)
    ///       ∧ map_after[index(map_after, k)] = map_before[index(map_before, k)]
    ///     )
    /// }
    ///
    /// { key ∉ map_before }
    /// map.insert(key, value)
    /// {
    ///     result = None
    ///     ∧ map_after.len() = map_before.len() + 1
    ///     ∧ map_after[index(map_after, key)] = value
    ///     ∧ (∀ k ∈ map_before. index(map_after, k) = index(map_before, k)
    ///       ∧ map_after[index(map_after, k)] = map_before[index(map_before, k)]
    ///     )
    /// }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    /// ]);
    ///
    /// let result = proj_map.insert(isize::MAX, f64::MAX);
    ///
    /// assert_eq!(result, None);
    ///
    /// let result = proj_map.insert(2_isize, 7_f64);
    ///
    /// assert_eq!(result, Some(3_f64));
    /// ```
    pub fn insert(&mut self, key: K, value: V) -> Option<V>
    where
        K: Eq + hash::Hash,
    {
        self.inner.insert(key, value)
    }

    /// Inserts a new entry into the index map, returning the storage index of the old entry, if it
    /// exists.
    ///
    /// This method behaves as follows:
    ///
    /// * If the equivalent key already exists in the index map, this method replaces the old value
    ///   with the new value in the map, and returns the storage index and the old value as
    ///   `(index, Some(old_value))`. The entry retains its position in the storage order of the
    ///   index map.
    /// * If the entry with the equivalent key does not exist in the map, it is appended to the end
    ///   of the map, so the resulting entry is in last place in the storage order, and the method
    ///   returns `(index, None)`, where `index` is the index of the last entry in the map in
    ///   storage order.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Specification Definitions
    ///
    /// We say that a key `k` is in the map `map` provided that
    ///
    /// ```text
    /// ∀ k :: K. (k ∈ map) ⇔ (∃ i ∈ [0, map.len()). map[i].key() = k).
    /// ```
    ///
    /// The **index** of a key `k` in `map` is defined by
    ///
    /// ```text
    /// index(map, k) := i such that map[i].key() = k.
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ∈ map_before }
    /// map.insert_full(key, value)
    /// {
    ///     result = Some(map_before[index(map_before, key)])
    ///     ∧ map_after.len() = map_before.len()
    ///     ∧ map_after[index(map_after, key)] = value
    ///     ∧ (∀ k ∈ map_before. k ≠ key
    ///       ⇒ index(map_after, k) = index(map_before, k)
    ///       ∧ map_after[index(map_after, k)] = map_before[index(map_before, k)]
    ///     )
    /// }
    ///
    /// { key ∉ map_before }
    /// map.insert_full(key, value)
    /// {
    ///     result = None
    ///     ∧ map_after.len() = map_before.len() + 1
    ///     ∧ map_after[index(map_after, key)] = value
    ///     ∧ (∀ k ∈ map_before. index(map_after, k) = index(map_before, k)
    ///       ∧ map_after[index(map_after, k)] = map_before[index(map_before, k)]
    ///     )
    /// }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    /// ]);
    ///
    /// let result = proj_map.insert_full(isize::MAX, f64::MAX);
    ///
    /// assert_eq!(result, (3, None));
    ///
    /// let result = proj_map.insert_full(2_isize, 7_f64);
    ///
    /// assert_eq!(result, (1, Some(3_f64)));
    /// ```
    pub fn insert_full(&mut self, key: K, value: V) -> (usize, Option<V>)
    where
        K: Eq + hash::Hash,
    {
        self.inner.insert_full(key, value)
    }

    /// Inserts a new entry in the index map at its ordered position among sorted keys.
    ///
    /// An index map is in **sorted order by key** if it satisfies the following property: let `e1`
    /// and `e2` be entries in `self`. Then `e1.key() <= e2.key()` if and only if
    /// `e1.index() <= e2.index()`. More precisely, given the index map `self`
    ///
    /// ```text
    /// forall e1, e2 in self. e1.index() <= e2.index() <-> e1.key() <= e2.key()
    /// ```
    ///
    /// or equivalently over key-value pairs
    ///
    /// ```text
    /// forall i1, i2 in [0, self.len()). forall k1, k2 :: K. forall v1, v2 :: V.
    /// (i1, (k1, v1)), (i2, (k2, v2)) in self --> i1 <= i2 <-> k1 <= k2.
    /// ```
    ///
    /// Otherwise, the index map is in **unsorted order by key**, or is **unsorted** for short.
    ///
    /// This means that an index map is in sorted order if the total ordering of the keys in the map
    /// matches the storage order of the entries in the map. The keys are **sorted** if the index
    /// map is in sorted order, and **unsorted** otherwise.
    ///
    /// This method is equivalent to finding the position with [`binary_search_keys`], then either
    /// updating it or calling [`insert_before`] for a new key.
    ///
    /// This method behaves as follows:
    ///
    /// * If the index map is in sorted order and contains the sorted key `key`, its corresponding
    ///   value is updated with `value`, and the older value is returned as
    ///   `(index, Some(old_value))`, where `index` is the storage index of the sorted key.
    /// * If the index map is in sorted order and does not contain the sorted key `key`, this method
    ///   inserts the new entry at the sorted position, returns `(index, None)`, where `index` is
    ///   the storage index of the sorted key.
    /// * If the existing keys are **not** sorted order, then the insertion index is unspecified.
    ///
    /// Instead of repeating calls to `insert_sorted`, it may be faster to call batched [`insert`]
    /// or [`extend`] and only call [`sort_keys`] or [`sort_unstable_keys`] once.
    ///
    /// [`binary_search_keys`]: TypedProjIndexMap::binary_search_keys
    /// [`insert_before`]: TypedProjIndexMap::insert_before
    /// [`insert`]: TypedProjIndexMap::insert
    /// [`extend`]: TypedProjIndexMap::extend
    /// [`sort_keys`]: TypedProjIndexMap::sort_keys
    /// [`sort_unstable_keys`]: TypedProjIndexMap::sort_unstable_keys
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Specification Definitions
    ///
    /// We say that a key `k` is in the map `map` provided that
    ///
    /// ```text
    /// ∀ k :: K. (k ∈ map) ⇔ (∃ i ∈ [0, map.len()). map[i].key() = k).
    /// ```
    ///
    /// The **index** of a key `k` in `map` is defined by
    ///
    /// ```text
    /// index(map, k) := i such that map[i].key() = k.
    /// ```
    ///
    /// The index map `map` is **sorted**, or in **sorted order** if and only if
    ///
    /// ```text
    /// is_sorted(map) := ∀ i1, i2 ∈ [0, map.len()). (i1 ≤ i2) ⇒ (map[i1].key() ≤ map[i2].key())
    /// ```
    ///
    /// or equivalently over index-key-value triples
    ///
    /// ```text
    /// ∀ i1, i2 ∈ [0, map.len()). ∀ k1, k2 :: K. ∀ v1, v2 :: V.
    /// ((i1, (k1, v1)) ∈ map ∧ (i2, (k2, v2)) ∈ map) ⇒ (i1 ≤ i2 ⇔ k1 ≤ k2).
    /// ```
    ///
    /// Otherwise, the index map is in **unsorted order by key**, or is **unsorted** for short.
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ∈ map_before ∧ is_sorted(map_before) }
    /// map.insert_sorted(key, value)
    /// {
    ///     result = Some(map_before[index(map_before, key)])
    ///     ∧ map_after[index(map_after, key)] = value
    ///     ∧ map_after.len() = map_before.len()
    ///     ∧ (∀ k ∈ map_before. k ≠ key ⇒ map_after[index(map_after, k)] = map_before[index(map_before, k)])
    ///     ∧ is_sorted(map_after)
    /// }
    ///
    /// { key ∉ map_before ∧ is_sorted(map_before) }
    /// map.insert_sorted(key, value)
    /// {
    ///     result = None
    ///     ∧ map_after[index(map_after, key)] = value
    ///     ∧ map_after.len() = map_before.len() + 1
    ///     ∧ (∀ k ∈ map_before. map_after[index(map_after, k)] = map_before[index(map_before, k)])
    ///     ∧ (∀ i < index(map_after, key). map_after[i].key() ≤ key
    ///        ∧ ∀ i > index(map_after, key). key ≤ map_after[i].key()
    ///     )
    ///     ∧ is_sorted(map_after)
    /// }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Examples
    ///
    /// Calling this method on an index map with a set of sorted keys yields the index of the
    /// entry in the underlying storage.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    ///     (4_isize, 5_f64),
    ///     (5_isize, 6_f64),
    ///     (6_isize, 7_f64),
    ///     (7_isize, 8_f64),
    /// ]);
    /// let result = proj_map.insert_sorted(5_isize, 100_f64);
    ///
    /// // The map is sorted, so the index returned is the storage index in the map.
    /// assert_eq!(result, (4, Some(6_f64)));
    ///
    /// assert_eq!(proj_map.get(&5_isize), Some(&100_f64));
    /// ```
    ///
    /// Calling this method on an index map with a set of unsorted keys yields a meaningless
    /// result for the insertion index.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///     (7_isize, 8_f64),
    ///     (4_isize, 5_f64),
    ///     (2_isize, 3_f64),
    ///     (5_isize, 6_f64),
    ///     (6_isize, 7_f64),
    ///     (1_isize, 2_f64),
    ///     (3_isize, 4_f64),
    /// ]);
    /// let result = proj_map.insert_sorted(5_isize, 100_f64);
    ///
    /// // The map is unsorted, so the index returned by the method is meaningless.
    /// assert_ne!(result, (4, Some(6_f64)));
    ///
    /// assert_eq!(proj_map.get(&5_isize), Some(&100_f64));
    /// ```
    pub fn insert_sorted(&mut self, key: K, value: V) -> (usize, Option<V>)
    where
        K: Eq + hash::Hash + Ord,
    {
        self.inner.insert_sorted(key, value)
    }

    /// Inserts an entry into a type-projected index map before the entry at the given index, or at
    /// the end of the index map.
    ///
    /// The index `index` must be in bounds. The index `index` is **in bounds** provided that
    /// `index` is in `[0, self.len()]`. Otherwise, the index `index` is **out of bounds**.
    ///
    /// This method behaves as follows:
    ///
    /// * If an equivalent key to the key `key` exists in the index map, let `current_index` be the
    ///   storage index of the entry with the equivalent key to `key`.
    ///   - If `index > current_index`, this method moves the entry at `current_index` to
    ///     `index - 1`, shifts each entry in `(current_index, index - 1]` down one index in the
    ///     storage of the index map, replaces the old value of the entry `old_value` with the new
    ///     value `value`, then returns `(index - 1, Some(old_value))`.
    ///   - If `index < current_index`, this method moves the entry at `current_index` to `index`,
    ///     shifts each entry in `[index, current_index)` up one index in the storage for the index
    ///     map, replaces the old value of the entry `old_value` with the new value `value`, then
    ///     returns `(index, Some(old_value))`.
    ///   - If `index == current_index`, this method replaces the old value of the entry `old_value`
    ///     with the new value `value`, no other entries get shifted or moved, then returns
    ///     `(index, Some(old_value))`.
    /// * If an equivalent key to the key `key` does not exist in the index map, the new entry is
    ///   inserted exactly at the index `index`, every element in `[index, self.len())` is shifted
    ///   up one index, and the method returns `(index, None)`. When `index == self.len()`,
    ///   the interval `[index, self.len()] == [self.len(), self.len())` is empty, so no shifting
    ///   occurs.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes. Let `result` be the return value of this method after it completes.
    ///
    /// ## Specification Definitions
    ///
    /// We say that a key `k` is in the map `map` provided that
    ///
    /// ```text
    /// ∀ k :: K. (k ∈ map) ⇔ (∃ i ∈ [0, map.len()). map[i].key() = k).
    /// ```
    ///
    /// The **index** of a key `k` in `map` is defined by
    ///
    /// ```text
    /// index(map, k) := i such that map[i].key() = k.
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { index ∈ [0, map_before.len()] ∧ key ∈ map_before }
    /// map.insert_before(index, key, value)
    /// {
    ///     result = (new_index, Some(map_before[index(map_before, key)]))
    ///     ∧ map_after[index(map_after, key)] = value
    ///     ∧ map_after.len() = map_before.len()
    ///     ∧ (∀ k ∈ map_before. k ≠ key ⇒ map_after[index(map_after, k)] = map_before[index(map_before, k)])
    ///     ∧ new_index = index(map_after, key)
    ///     ∧ ((new_index = index) ∨ (new_index = index - 1))
    /// }
    ///
    /// { index ∈ [0, map_before.len()] ∧ key ∉ map_before }
    /// map.insert_before(index, key, value)
    /// {
    ///     result = (index, None)
    ///     ∧ map_after[index(map_after, key)] = value
    ///     ∧ map_after.len() = map_before.len() + 1
    ///     ∧ (∀ k ∈ map_before. map_after[index(map_after, k)] = map_before[index(map_before, k)])
    ///     ∧ map_after[index].key() = key
    ///     ∧ (∀ i ∈ [0, map_after.len()). i ≠ index ⇒ map_after[i].key() ≠ key)
    /// }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if the index `index` is out of bounds.
    ///
    /// # Examples
    ///
    /// Inserting an existing key `key` where `index > self.get_index_of(key)`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<isize, char> = TypedProjIndexMap::from([
    ///     (1_isize, 'a'),
    ///     (2_isize, 'b'),
    ///     (3_isize, 'c'),
    ///     (4_isize, 'd'),
    ///     (5_isize, 'e'),
    ///     (6_isize, 'f'),
    ///     (7_isize, 'g'),
    /// ]);
    /// let removed = proj_map.insert_before(5, 2_isize, '*');
    /// let expected: TypedProjVec<(isize, char)> = TypedProjVec::from([
    ///     (1_isize, 'a'),
    ///     (3_isize, 'c'),
    ///     (4_isize, 'd'),
    ///     (5_isize, 'e'),
    ///     (2_isize, '*'),
    ///     (6_isize, 'f'),
    ///     (7_isize, 'g'),
    /// ]);
    /// let result: TypedProjVec<(isize, char)> = proj_map
    ///     .iter()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result, expected);
    /// assert_eq!(removed, (4, Some('b')));
    /// ```
    ///
    /// Inserting an existing key `key` where `index < self.get_index_of(key)`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<isize, char> = TypedProjIndexMap::from([
    ///     (1_isize, 'a'),
    ///     (2_isize, 'b'),
    ///     (3_isize, 'c'),
    ///     (4_isize, 'd'),
    ///     (5_isize, 'e'),
    ///     (6_isize, 'f'),
    ///     (7_isize, 'g'),
    /// ]);
    /// let removed = proj_map.insert_before(2, 6_isize, '*');
    /// let expected: TypedProjVec<(isize, char)> = TypedProjVec::from([
    ///     (1_isize, 'a'),
    ///     (2_isize, 'b'),
    ///     (6_isize, '*'),
    ///     (3_isize, 'c'),
    ///     (4_isize, 'd'),
    ///     (5_isize, 'e'),
    ///     (7_isize, 'g'),
    /// ]);
    /// let result: TypedProjVec<(isize, char)> = proj_map
    ///     .iter()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result, expected);
    /// assert_eq!(removed, (2, Some('f')));
    /// ```
    ///
    /// Inserting an existing key `key` where `index == self.get_index_of(key)`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<isize, char> = TypedProjIndexMap::from([
    ///     (1_isize, 'a'),
    ///     (2_isize, 'b'),
    ///     (3_isize, 'c'),
    ///     (4_isize, 'd'),
    ///     (5_isize, 'e'),
    ///     (6_isize, 'f'),
    ///     (7_isize, 'g'),
    /// ]);
    /// let removed = proj_map.insert_before(3, 4_isize, '*');
    /// let expected: TypedProjVec<(isize, char)> = TypedProjVec::from([
    ///     (1_isize, 'a'),
    ///     (2_isize, 'b'),
    ///     (3_isize, 'c'),
    ///     (4_isize, '*'),
    ///     (5_isize, 'e'),
    ///     (6_isize, 'f'),
    ///     (7_isize, 'g'),
    /// ]);
    /// let result: TypedProjVec<(isize, char)> = proj_map
    ///     .iter()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result, expected);
    /// assert_eq!(removed, (3, Some('d')));
    /// ```
    ///
    /// Inserting a key `key` that does not exist in the index map at an index `index`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<isize, char> = TypedProjIndexMap::from([
    ///     (1_isize, 'a'),
    ///     (2_isize, 'b'),
    ///     (3_isize, 'c'),
    ///     (4_isize, 'd'),
    ///     (5_isize, 'e'),
    ///     (6_isize, 'f'),
    ///     (7_isize, 'g'),
    /// ]);
    /// let removed = proj_map.insert_before(3, isize::MAX, '*');
    /// let expected: TypedProjVec<(isize, char)> = TypedProjVec::from([
    ///     (1_isize, 'a'),
    ///     (2_isize, 'b'),
    ///     (3_isize, 'c'),
    ///     (isize::MAX, '*'),
    ///     (4_isize, 'd'),
    ///     (5_isize, 'e'),
    ///     (6_isize, 'f'),
    ///     (7_isize, 'g'),
    /// ]);
    /// let result: TypedProjVec<(isize, char)> = proj_map
    ///     .iter()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result, expected);
    /// assert_eq!(removed, (3, None));
    /// ```
    #[track_caller]
    pub fn insert_before(&mut self, index: usize, key: K, value: V) -> (usize, Option<V>)
    where
        K: Eq + hash::Hash,
    {
        self.inner.insert_before(index, key, value)
    }

    /// Inserts an entry into a type-projected index map at the given storage index.
    ///
    /// The index `index` must be in bounds. The index `index` is **in bounds** provided that one
    /// of the following conditions holds:
    ///
    /// * If an entry with a key equivalent to the key `key` exists in the index map, and `index` is
    ///   in `[0, self.len())`.
    /// * If an entry with a key equivalent to the key `key` does not exist in the index map, and
    ///   index is in `[0, self.len()]`.
    ///
    /// Otherwise, the index `index` is **out of bounds**.
    ///
    /// This method behaves as follows:
    ///
    /// * If an equivalent key already exists in the map, let `current_index` be the storage index
    ///   of the entry with key equivalent to `key`.
    ///   - If `index < current_index`, every entry in range `[index, current_index)` is shifted up
    ///     one entry in the storage order, the current entry is moved from `current_index` to
    ///     `index`, the old value of the entry `old_value` is replaced with the new value `value`,
    ///     and the method returns `Some(old_value)`.
    ///   - If `index > current_index`, every entry in range `(current_index, index]` is shifted
    ///     down one entry in the storage order, the current entry is moved from `current_index` to
    ///     `index`, the old value of the entry `old_value` is replaced with the new value `value`,
    ///     and the method returns `Some(old_value)`.
    ///   - If `index == current_index`, no shifting occurs, the old value of the entry `old_value`
    ///     is replaced with the new value `value`, and the method returns `Some(old_value)`.
    /// * If an equivalent key does not exist in the index map, the new entry is inserted at the
    ///   storage index `index`, and each entry in the range `[index, self.len())` is shifted
    ///   up one index, and the method returns `None`.
    ///
    /// Note that an existing entry **cannot** be moved to the index `self.len()`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes. Let `result` be the return value of this method after it completes.
    ///
    /// ## Specification Definitions
    ///
    /// We say that a key `k` is in the map `map` provided that
    ///
    /// ```text
    /// ∀ k :: K. (k ∈ map) ⇔ (∃ i ∈ [0, map.len()). map[i].key() = k).
    /// ```
    ///
    /// The **index** of a key `k` in `map` is defined by
    ///
    /// ```text
    /// index(map, k) := i such that map[i].key() = k.
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { index ∈ [0, map_before.len()) ∧ key ∈ map_before ∧ index(map_before, key) = index }
    /// map.shift_insert(index, key, value)
    /// {
    ///     result = Some(map_before[index(map_before, key)])
    ///     ∧ map_after[index(map_after, key)] = value
    ///     ∧ map_after[index].key() = key
    ///     ∧ map_after.len() = map_before.len()
    ///     ∧ (∀ k ∈ map_before. map_after[index(map_after, k)] = map_before[index(map_before, k)])
    /// }
    ///
    /// { index ∈ [0, map_before.len()) ∧ key ∈ map_before ∧ index(map_before, key) < index }
    /// map.shift_insert(index, key, value)
    /// {
    ///     result = Some(map_before[index(map_before, key)])
    ///     ∧ map_after[index(map_after, key)] = value
    ///     ∧ map_after[index].key() = key
    ///     ∧ map_after.len() = map_before.len()
    ///     ∧ (∀ i ∈ [0, index(map_fore, key). map_after[i] = map_before[i])
    ///     ∧ (∀ i ∈ [index(map_before, key), index - 1]. map_after[i] = map_before[i + 1])
    ///     ∧ (∀ i ∈ [index + 1, map_after.len()). map_after[i] = map_before[i])
    /// }
    ///
    /// { index ∈ [0, map_before.len()) ∧ key ∈ map_before ∧ index(map_before, key) > index }
    /// map.shift_insert(index, key, value)
    /// {
    ///     result = Some(map_before[index(map_before, key)])
    ///     ∧ map_after[index(map_after, key)] = value
    ///     ∧ map_after[index].key() = key
    ///     ∧ map_after.len() = map_before.len()
    ///     ∧ (∀ i ∈ [0, index). map_after[i] = map_before[i])
    ///     ∧ (∀ i ∈ [index + 1, index(map_before, key) + 1]. map_after[i] = map_before[i - 1])
    ///     ∧ (∀ i ∈ [index(map_before, key) + 1, map_after.len()). map_after[i] = map_before[i])
    /// }
    ///
    /// { index ∈ [0, map_before.len()] ∧ key ∉ map_before }
    /// map.shift_insert(index, key, value)
    /// {
    ///     result = None
    ///     ∧ map_after[index(map_after, key)] = value
    ///     ∧ map_after[index].key() = key
    ///     ∧ map_after.len() = map_before.len() + 1
    ///     ∧ (∀ j ∈ [0, map_after.len()). j ≠ index ⇒ map_after[j].key() ≠ key)
    ///     ∧ (∀ i ∈ [0, index). map_after[i] = map_before[i])
    ///     ∧ (∀ i ∈ [index + 1, map_after.len()). map_after[i] = map_before[i - 1])
    /// }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if the index `index` is out of bounds.
    ///
    /// # Examples
    ///
    /// Shift inserting an entry that **does not** exist with index `index < self.len()`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    ///     (4_isize, 5_f64),
    ///     (5_isize, 6_f64),
    ///     (6_isize, 7_f64),
    ///     (7_isize, 8_f64),
    /// ]);
    /// let old_value = proj_map.shift_insert(3, isize::MAX, f64::MAX);
    /// let expected: TypedProjVec<(isize, f64)> = TypedProjVec::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    ///     (isize::MAX, f64::MAX),
    ///     (4_isize, 5_f64),
    ///     (5_isize, 6_f64),
    ///     (6_isize, 7_f64),
    ///     (7_isize, 8_f64),
    /// ]);
    /// let result: TypedProjVec<(isize, f64)> = proj_map
    ///     .iter()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result, expected);
    /// assert_eq!(old_value, None);
    /// ```
    ///
    /// Shift inserting an entry that **does not** exist with index `index == self.len()`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    ///     (4_isize, 5_f64),
    ///     (5_isize, 6_f64),
    ///     (6_isize, 7_f64),
    ///     (7_isize, 8_f64),
    /// ]);
    /// let old_value = proj_map.shift_insert(proj_map.len(), isize::MAX, f64::MAX);
    /// let expected: TypedProjVec<(isize, f64)> = TypedProjVec::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    ///     (4_isize, 5_f64),
    ///     (5_isize, 6_f64),
    ///     (6_isize, 7_f64),
    ///     (7_isize, 8_f64),
    ///     (isize::MAX, f64::MAX),
    /// ]);
    /// let result: TypedProjVec<(isize, f64)> = proj_map
    ///     .iter()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result, expected);
    /// assert_eq!(old_value, None);
    /// ```
    ///
    /// Shift inserting an entry that **does** exist with index `index < self.len()`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<isize, f64> = TypedProjIndexMap::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    ///     (4_isize, 5_f64),
    ///     (5_isize, 6_f64),
    ///     (6_isize, 7_f64),
    ///     (7_isize, 8_f64),
    /// ]);
    /// let old_value = proj_map.shift_insert(3, 6_isize, f64::MAX);
    /// let expected: TypedProjVec<(isize, f64)> = TypedProjVec::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    ///     (6_isize, f64::MAX),
    ///     (4_isize, 5_f64),
    ///     (5_isize, 6_f64),
    ///     (7_isize, 8_f64),
    /// ]);
    /// let result: TypedProjVec<(isize, f64)> = proj_map
    ///     .iter()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result, expected);
    /// assert_eq!(old_value, Some(7_f64));
    /// ```
    #[track_caller]
    pub fn shift_insert(&mut self, index: usize, key: K, value: V) -> Option<V>
    where
        K: Eq + hash::Hash,
    {
        self.inner.shift_insert(index, key, value)
    }

    /// Returns the entry in the index map corresponding to the given key.
    ///
    /// The resulting entry can be queried or manipulated directly, instead of going through the
    /// index map to do it.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<&str, i32> = TypedProjIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  4_i32),
    ///     ("quux", 8_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.len(), 4);
    ///
    /// assert_eq!(proj_map.entry("foo").key(), &"foo");
    /// assert_eq!(proj_map.entry("bar").key(), &"bar");
    /// assert_eq!(proj_map.entry("baz").key(), &"baz");
    /// assert_eq!(proj_map.entry("quux").key(), &"quux");
    ///
    /// // Vacant entries also return their keys.
    /// assert_eq!(proj_map.entry("quuz").key(), &"quuz");
    /// assert_eq!(proj_map.entry("garply").key(), &"garply");
    ///
    /// assert_eq!(proj_map.entry("foo").index(), 0);
    /// assert_eq!(proj_map.entry("bar").index(), 1);
    /// assert_eq!(proj_map.entry("baz").index(), 2);
    /// assert_eq!(proj_map.entry("quux").index(), 3);
    ///
    /// // Vacant entries have the length of the index map as their index.
    /// assert_eq!(proj_map.entry("quuz").index(), proj_map.len());
    /// assert_eq!(proj_map.entry("garply").index(), proj_map.len());
    ///
    /// assert_eq!(proj_map.len(), 4);
    ///
    /// proj_map.entry("quuz").insert_entry(16_i32);
    ///
    /// assert_eq!(proj_map.len(), 5);
    ///
    /// assert_eq!(proj_map.entry("quuz").index(), 4);
    /// assert_eq!(proj_map.entry("garply").index(), 5);
    /// ```
    pub fn entry(&mut self, key: K) -> Entry<'_, K, V, A>
    where
        K: Eq + hash::Hash,
    {
        match self.inner.entry(key) {
            map_inner::Entry::Occupied(occupied) => Entry::Occupied(OccupiedEntry::new(occupied)),
            map_inner::Entry::Vacant(vacant) => Entry::Vacant(VacantEntry::new(vacant)),
        }
    }

    /// Creates a splicing iterator that replaces the specified storage range in the type-projected
    /// index map with the given `replace_with` iterator and yields the removed items. The argument
    /// `replace_with` does not need to be the same length as `range`.
    ///
    /// The `range` argument is removed even if the `Splice` iterator is not consumed before it is
    /// dropped.
    ///
    /// It is unspecified how many elements are removed from the type-projected index map
    /// if the `Splice` value is leaked.
    ///
    /// The input iterator `replace_with` is only consumed when the `Splice` value is dropped.
    /// If a key from the iterator matches an existing entry in the map (i.e. outside the range
    /// `range`), then the value will be updated in that position. Otherwise, the new entry will be
    /// inserted in the replaced `range`.
    ///
    /// # Panics
    ///
    /// This method panics if the starting point is greater than the end point or if the end point
    /// is greater than the length of the index map.
    ///
    /// # Examples
    ///
    /// Splicing entries into an index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (0_usize, "foo"),
    ///     (1_usize, "bar"),
    ///     (2_usize, "baz"),
    ///     (3_usize, "quux"),
    /// ]);
    /// let new = [
    ///     (7_usize, "garply"),
    ///     (8_usize, "corge"),
    ///     (9_usize, "grault"),
    /// ];
    /// let expected = TypedProjVec::from([
    ///     (0_usize, "foo"),
    ///     (7_usize, "garply"),
    ///     (8_usize, "corge"),
    ///     (9_usize, "grault"),
    ///     (3_usize, "quux"),
    /// ]);
    /// let expected_removed = TypedProjVec::from([
    ///     (1_usize, "bar"),
    ///     (2_usize, "baz"),
    /// ]);
    /// let removed: TypedProjVec<(usize, &str)> = proj_map.splice(1..3, new).collect();
    /// let result: TypedProjVec<(usize, &str)> = proj_map
    ///     .iter()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result, expected);
    /// assert_eq!(removed, expected_removed);
    /// ```
    ///
    /// Using `splice` to insert new items into an index map efficiently at a specific position
    /// indicated by an empty range.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (0_usize, "foo"),
    ///     (4_usize, "grault")
    /// ]);
    /// let new = [
    ///     (1_usize, "bar"),
    ///     (2_usize, "baz"),
    ///     (3_usize, "quux"),
    /// ];
    /// let expected = TypedProjVec::from([
    ///     (0_usize, "foo"),
    ///     (1_usize, "bar"),
    ///     (2_usize, "baz"),
    ///     (3_usize, "quux"),
    ///     (4_usize, "grault"),
    /// ]);
    /// let expected_removed = TypedProjVec::from([]);
    /// let removed: TypedProjVec<(usize, &str)> = proj_map.splice(1..1, new).collect();
    /// let result: TypedProjVec<(usize, &str)> = proj_map
    ///     .iter()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result, expected);
    /// assert_eq!(removed, expected_removed);
    /// ```
    #[track_caller]
    pub fn splice<R, I>(&mut self, range: R, replace_with: I) -> Splice<'_, I::IntoIter, K, V, S, A>
    where
        K: Eq + hash::Hash,
        A: any::Any + alloc::Allocator + Clone,
        R: ops::RangeBounds<usize>,
        I: IntoIterator<Item = (K, V)>,
    {
        Splice::new::<R>(self.inner.splice(range, replace_with))
    }

    /// Moves all entries from `other` into `self`, leaving `other` empty.
    ///
    /// This is equivalent to calling [`insert`] for each entry from `other` in order, which means
    /// that for keys that already exist in `self`, their value is updated in the current position.
    ///
    /// [`insert`]: TypedProjIndexMap::insert
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map1` and `map2` be index maps, `map1_before` be the state of `map1` before this
    /// method is called, `map2_before` be the state of `map2` before this method is called,
    /// `map1_after` be the state of `map1` after this method completes, and `map2_after` be the
    /// state of `map2` after this method completes.
    ///
    /// ## Specification Definitions
    ///
    /// We say that a key `k` is in the map `map` provided that
    ///
    /// ```text
    /// ∀ k :: K. (k ∈ map) ⇔ (∃ i ∈ [0, map.len()). map[i].key() = k).
    /// ```
    ///
    /// The **index** of a key `k` in `map` is defined by
    ///
    /// ```text
    /// index(map, k) := i such that map[i].key() = k.
    /// ```
    ///
    /// We can index an index map `map` by a key `k` by defining
    ///
    /// ```text
    /// map[key] := map[index(map, key)].
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { true }
    /// map1.append(map2)
    /// {
    ///     map1_after.len() ≤ map1_before.len() + map2_before.len()
    ///     ∧ map2_after.len() = 0
    ///     ∧ (∀ k ∈ map2_before. k ∈ map1_before ⇒ map1_after[k] = map2_before[k])
    ///     ∧ (∀ k ∈ map2_before. k ∉ map1_before ⇒ map1_after[k] = map2_before[k])
    ///     ∧ (∀ k ∈ map1_before. k ∉ map2_before ⇒ map1_after[k] = map1_before[k])
    ///     ∧ (∀ i ∈ [0, map1_before.len()). map1_after[i].key() = map1_before[i].key())
    ///     ∧ (∀ j1, j2 ∈ [0, map2_before.len()).
    ///          ((map2_before[j1].key() ∉ map1_before) ∧ (map2_before[j2].key() ∉ map1_before) ∧ (j1 < j2))
    ///          ⇒ (∃ i1, i2 ∈ [map1_before.len(), map1_after.len()).
    ///               i1 < i2
    ///               ∧ map1_after[i1].key() = map2_before[j1].key()
    ///               ∧ map1_after[i2].key() = map2_before[j2].key()
    ///          )
    ///     )
    /// }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Examples
    ///
    /// Appending one index map to another when they have no overlapping keys.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map1 = TypedProjIndexMap::from([
    ///     ("foo",  0_usize),
    ///     ("bar",  1_usize),
    ///     ("baz",  2_usize),
    ///     ("quux", 3_usize),
    /// ]);
    /// let mut proj_map2 = TypedProjIndexMap::from([
    ///     ("garply", 4_usize),
    ///     ("corge",  5_usize),
    ///     ("grault", 6_usize),
    /// ]);
    ///
    /// assert_eq!(proj_map1.len(), 4);
    /// assert_eq!(proj_map2.len(), 3);
    ///
    /// proj_map1.append(&mut proj_map2);
    ///
    /// assert_eq!(proj_map1.len(), 7);
    /// assert_eq!(proj_map2.len(), 0);
    ///
    /// let expected_keys = ["foo", "bar", "baz", "quux", "garply", "corge", "grault"];
    /// let result_keys = TypedProjVec::from_iter(proj_map1.keys().cloned());
    ///
    /// assert_eq!(result_keys.as_slice(), expected_keys.as_slice());
    ///
    /// let expected_values = [0_usize, 1_usize, 2_usize, 3_usize, 4_usize, 5_usize, 6_usize];
    /// let result_values = TypedProjVec::from_iter(proj_map1.values().cloned());
    ///
    /// assert_eq!(result_values.as_slice(), expected_values.as_slice());
    /// ```
    ///
    /// Appending one index map to another when they have overlapping keys.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map1 = TypedProjIndexMap::from([
    ///     ("foo",  0_usize),
    ///     ("bar",  1_usize),
    ///     ("baz",  2_usize),
    ///     ("quux", 3_usize),
    /// ]);
    /// let mut proj_map2 = TypedProjIndexMap::from([
    ///     ("garply", 4_usize),
    ///     ("corge",  5_usize),
    ///     ("grault", 6_usize),
    ///     ("baz", usize::MAX),
    /// ]);
    ///
    /// assert_eq!(proj_map1.len(), 4);
    /// assert_eq!(proj_map2.len(), 4);
    ///
    /// proj_map1.append(&mut proj_map2);
    ///
    /// assert_eq!(proj_map1.len(), 7);
    /// assert_eq!(proj_map2.len(), 0);
    ///
    /// let expected_keys = ["foo", "bar", "baz", "quux", "garply", "corge", "grault"];
    /// let result_keys = TypedProjVec::from_iter(proj_map1.keys().cloned());
    ///
    /// assert_eq!(result_keys.as_slice(), expected_keys.as_slice());
    ///
    /// let expected_values = [0_usize, 1_usize, usize::MAX, 3_usize, 4_usize, 5_usize, 6_usize];
    /// let result_values = TypedProjVec::from_iter(proj_map1.values().cloned());
    ///
    /// assert_eq!(result_values.as_slice(), expected_values.as_slice());
    /// ```
    pub fn append<S2>(&mut self, other: &mut TypedProjIndexMap<K, V, S2, A>)
    where
        K: Eq + hash::Hash,
        S2: any::Any + hash::BuildHasher + Send + Sync,
        S2::Hasher: any::Any + hash::Hasher + Send + Sync,
    {
        self.inner.append(&mut other.inner);
    }
}

impl<K, V, S, A> TypedProjIndexMap<K, V, S, A>
where
    K: any::Any,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    /// Removes and returns the last entry in the index map.
    ///
    /// If `self` is nonempty, this method returns the last key-value pair in the index map
    /// as `Some((key, value))`. If `self` is empty, this method returns `None`.
    ///
    /// This method preserves the order of the remaining elements in the collection.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes. Let `result` be the return value of this method after it completes.
    ///
    /// ## Specification Definitions
    ///
    /// The **last entry** in the map `map` when `map` is non-empty is defined by
    ///
    /// ```text
    /// last(map) := map[map.len() - 1].
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { map_before.len() > 0 }
    /// map.pop()
    /// {
    ///     result = Some(last(map_before))
    ///     ∧ map_after.len() = map_before.len() - 1
    ///     ∧ (∀ i ∈ [0, map_after.len()). map_after[i] = map_before[i])
    /// }
    ///
    /// { map_before.len() = 0 }
    /// map.pop()
    /// { result = None ∧ map_after.len() = 0 }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Examples
    ///
    /// Popping from a nonempty index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",  0_usize),
    ///     ("bar",  1_usize),
    ///     ("baz",  2_usize),
    ///     ("quux", 3_usize),
    /// ]);
    ///
    /// assert_eq!(proj_map.len(), 4);
    ///
    /// let expected = Some(("quux", 3_usize));
    /// let result = proj_map.pop();
    ///
    /// assert_eq!(result, expected);
    /// assert_eq!(proj_map.len(), 3);
    /// ```
    ///
    /// Popping from an empty index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<&str, usize> = TypedProjIndexMap::new();
    ///
    /// assert!(proj_map.is_empty());
    ///
    /// let expected = None;
    /// let result = proj_map.pop();
    ///
    /// assert_eq!(result, expected);
    /// assert!(proj_map.is_empty());
    /// ```
    #[doc(alias = "pop_last")]
    pub fn pop(&mut self) -> Option<(K, V)> {
        self.inner.pop()
    }

    /// Retains only the key-value pairs specified by the predicate.
    ///
    /// This method removes all entries `e` for which `keep(&e)` returns `false`. This method
    /// operates in place, visiting each element exactly once in the original order, and preserves
    /// the storage order of the retained entries. Stated differently, this method keeps only those
    /// entries `e` for which `keep(&e)` returns `true`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes. Let `result` be the return value of this method after it completes. Let
    /// `keep` be the filtering function for entries in `map`.
    ///
    /// ## Specification Definitions
    ///
    /// We say that a key-value pair `e :: (K, V)` is an **entry** in the map `map` if and only if
    ///
    /// ```text
    /// ∀ e :: (K, V). e ∈ map ⇔ (∃ i ∈ [0, map.len()). map[i] = e).
    /// ```
    ///
    /// The set of **keys** in the map `map` is defined as
    ///
    /// ```text
    /// keys(map) := { k :: K | ∃ i ∈ [0, map.len()). map[i].key() = k }
    /// ```
    ///
    /// or equivalently
    ///
    /// ```text
    /// ∀ k :: K. (k ∈ keys(map)) ⇔ (∃ i ∈ [0, map.len()). map[i].key() = k).
    /// ```
    ///
    /// The **index** of a key `k` in `map` is defined by
    ///
    /// ```text
    /// index(map, k) := i such that map[i].key() = k.
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { true }
    /// map.retain(keep)
    /// {
    ///     map_after.len() ≤ map_before.len()
    ///     ∧ (∀ (k, v) ∈ map_after. k ∈ map_before ∧ keep(k, v))
    ///     ∧ (∀ (k, v) ∈ map_before. keep(k, v) ⇒
    ///         (k, v') ∈ map_after
    ///         ∧ (if f mutated v, then v' is the updated value, else v' = v)
    ///       )
    ///     ∧ (∀ (k, v) ∈ map_before. ¬keep(k, v) ⇒ k ∉ keys(map_after))
    ///     ∧ (∀ k1, k2 ∈ keys(map_after).
    ///         index(map_before, k1) < index(map_before, k2) ⇒ index(map_after, k1) < index(map_after, k2)
    ///       )
    /// }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// fn is_odd(k: &&str, v: &mut usize) -> bool { k.len() % 2 != 0 }
    ///
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",    0_usize),
    ///     ("bar",    1_usize),
    ///     ("baz",    2_usize),
    ///     ("quux",   3_usize),
    ///     ("quuz",   4_usize),
    ///     ("corge",  5_usize),
    ///     ("grault", 6_usize),
    ///     ("garply", 7_usize),
    ///     ("waldo",  8_usize),
    /// ]);
    /// proj_map.retain(is_odd);
    /// let expected = TypedProjVec::from([
    ///     ("foo",    0_usize),
    ///     ("bar",    1_usize),
    ///     ("baz",    2_usize),
    ///     ("corge",  5_usize),
    ///     ("waldo",  8_usize),
    /// ]);
    /// let result: TypedProjVec<(&str, usize)> = proj_map
    ///     .iter()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result, expected);
    /// ```
    pub fn retain<F>(&mut self, keep: F)
    where
        F: FnMut(&K, &mut V) -> bool,
    {
        self.inner.retain(keep);
    }

    /// Sorts the entries in the index map into the sorted ordering of the keys as defined by the
    /// default ordering of the keys.
    ///
    /// An index map is in **sorted order by key** if it satisfies the following property: let `e1`
    /// and `e2` be entries in `self`. Then `e1.key() <= e2.key()` if and only if
    /// `e1.index() <= e2.index()`. More precisely, given the index map `self`
    ///
    /// ```text
    /// forall e1, e2 in self. e1.index() <= e2.index() <-> e1.key() <= e2.key()
    /// ```
    ///
    /// or equivalently over key-value pairs
    ///
    /// ```text
    /// forall i1, i2 in [0, self.len()). forall k1, k2 :: K. forall v1, v2 :: V.
    /// (i1, (k1, v1)), (i2, (k2, v2)) in self --> i1 <= i2 <-> k1 <= k2.
    /// ```
    ///
    /// Otherwise, the index map is in **unsorted order by key**, or is **unsorted** for short.
    ///
    /// This means that an index map is in sorted order if the total ordering of the keys in the map
    /// matches the storage order of the entries in the map. The keys are **sorted** if the index
    /// map is in sorted order, and **unsorted** otherwise.
    ///
    /// After this method completes, the index map will be in stable sorted order.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Specification Definitions
    ///
    /// We say that a key-value pair `(k, v) :: (K, V)` is an **entry** in the map `map` if and
    /// only if
    ///
    /// ```text
    /// ∀ (k, v) :: (K, V). (k, v) ∈ map ⇔ (∃ i ∈ [0, map.len()). map[i] = (k, v)).
    /// ```
    ///
    /// An index map `map1` is a **permutation** of an index map `map2` if it satisfies
    ///
    /// ```text
    /// is_permutation(map1, map2) :=
    ///     map1.len() = map2.len()
    ///     ∧ (∀ i ∈ [0, map1.len()). ∃ j ∈ [0, map2.len()). map1[i] = map2[j])
    ///     ∧ (∀ i ∈ [0, map2.len()). ∃ j ∈ [0, map1.len()). map2[i] = map1[j])
    /// ```
    ///
    /// Note that multiset equality is not needed here because every key is unique in an index map.
    ///
    /// The index map `map` is **sorted** with respect to its keys if
    ///
    /// ```text
    /// is_sorted(map) := ∀ i ∈ [0, map.len() - 1). map[i].key() ≤ map[i + 1].key().
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { true }
    /// map.sort_keys()
    /// {
    ///     map_after.len() = map_before.len()
    ///     ∧ is_permutation(map_after, map_before)
    ///     ∧ is_sorted(map_after)
    /// }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// This sort is stable because keys are unique.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (5_isize, 'e'),
    ///     (2_isize, 'b'),
    ///     (1_isize, 'a'),
    ///     (4_isize, 'd'),
    ///     (3_isize, 'c'),
    /// ]);
    /// proj_map.sort_keys();
    /// let expected = [(1_isize, 'a'), (2_isize, 'b'), (3_isize, 'c'), (4_isize, 'd'), (5_isize, 'e')];
    ///
    /// assert_eq!(proj_map.as_slice(), expected.as_slice());
    /// ```
    pub fn sort_keys(&mut self)
    where
        K: Ord,
    {
        self.inner.sort_keys();
    }

    /// Sorts the entries in the index map into the sorted ordering of the entries as defined by the
    /// provided comparison function.
    ///
    /// After this method completes, the index map will be in stable sorted order with the ordering
    /// defined by the comparison function.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Specification Definitions
    ///
    /// A **comparator** is a map `cmp : K ⨯ V ⨯ K ⨯ V → Ordering` such that given entries
    /// `(k1, v1) :: (K, V)` and `(k2, v2) :: (K, V)` from a partially ordered collection of
    /// entries
    ///
    /// ```text
    /// cmp(k1, v1, k2, v2) = Ordering::Greater when (k1, v1) > (k2, v2)
    /// cmp(k1, v1, k2, v2) = Ordering::Less    when (k1, v1) < (k2, v2)
    /// cmp(k1, v1, k2, v2) = Ordering::Equal   when (k1, v1) = (k2, v2)
    /// ```
    ///
    /// An index map `map1` is a **permutation** of an index map `map2` if it satisfies
    ///
    /// ```text
    /// is_permutation(map1, map2) :=
    ///     map1.len() = map2.len()
    ///     ∧ (∀ i ∈ [0, map1.len()). ∃ j ∈ [0, map2.len()). map1[i] = map2[j])
    ///     ∧ (∀ i ∈ [0, map2.len()). ∃ j ∈ [0, map1.len()). map2[i] = map1[j])
    /// ```
    ///
    /// Note that multiset equality is not needed here because every key is unique in an index map.
    ///
    /// The **index** of a key `k` in `map` is defined by
    ///
    /// ```text
    /// index(map, k) := i such that map[i].key() = k.
    /// ```
    ///
    /// The index map `map` is **sorted** with respect to the comparator `cmp` if
    ///
    /// ```text
    /// is_sorted(map, cmp) := ∀ i ∈ [0, map.len() - 1).
    ///     cmp(map[i].key(), map[i].value(), map[i + 1].key(), map[i + 1].value()) != Greater
    /// ```
    ///
    /// holds. We say that the sort is **stable** if and only if
    ///
    /// ```text
    /// is_stable_sorted(map, original, cmp) :=
    ///     is_sorted(map, cmp)
    ///     ∧ ∀ i, j ∈ [0, original.len()).
    ///         (cmp(original[i].key(), original[i].value(), original[j].key(), original[j].value()) = Equal ∧ (i < j))
    ///         ⇒
    ///         (index(map, original[i].key()) < index(map, original[j].key()))
    /// ```
    ///
    /// holds.
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { true }
    /// map.sort_by(cmp)
    /// {
    ///     map_after.len() = map_before.len()
    ///     ∧ is_permutation(map_after, map_before)
    ///     ∧ is_stable_sorted(map_after, map_before, cmp)
    /// }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (1_usize, 'b'),
    ///     (0_usize, '*'),
    ///     (3_usize, 'c'),
    ///     (2_usize, 'a'),
    /// ]);
    /// proj_map.sort_by(|k1, v1, k2, v2| v1.cmp(&v2));
    /// let expected = [(0_usize, '*'), (2_usize, 'a'), (1_usize, 'b'), (3_usize, 'c')];
    ///
    /// assert_eq!(proj_map.as_slice(), expected.as_slice());
    /// ```
    pub fn sort_by<F>(&mut self, cmp: F)
    where
        F: FnMut(&K, &V, &K, &V) -> cmp::Ordering,
    {
        self.inner.sort_by(cmp);
    }

    /// Returns a moving iterator that returns the entries of the index map in sorted order as
    /// defined by the provided comparison function.
    ///
    /// The resulting moving iterator will return the entries of the index map in stable sorted
    /// order with the ordering defined by the comparison function.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (1_usize, 'b'),
    ///     (0_usize, '*'),
    ///     (3_usize, 'c'),
    ///     (2_usize, 'a'),
    /// ]);
    /// let result: TypedProjVec<(usize, char)> = proj_map
    ///     .sorted_by(|k1, v1, k2, v2| v1.cmp(&v2))
    ///     .collect();
    /// let expected = TypedProjVec::from([
    ///     (0_usize, '*'),
    ///     (2_usize, 'a'),
    ///     (1_usize, 'b'),
    ///     (3_usize, 'c')
    /// ]);
    ///
    /// assert_eq!(result.as_slice(), expected.as_slice());
    /// ```
    pub fn sorted_by<F>(self, cmp: F) -> IntoIter<K, V, A>
    where
        F: FnMut(&K, &V, &K, &V) -> cmp::Ordering,
    {
        IntoIter::new(self.inner.sorted_by(cmp))
    }

    /// Sorts the entries in the index map into the sorted ordering of the keys as defined by the
    /// default ordering of the keys, but may not preserve the order of equal values.
    ///
    /// After this method completes, the index map will be in unstable sorted order.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Specification Definitions
    ///
    /// We say that a key-value pair `(k, v) :: (K, V)` is an **entry** in the map `map` if and
    /// only if
    ///
    /// ```text
    /// ∀ (k, v) :: (K, V). (k, v) ∈ map ⇔ (∃ i ∈ [0, map.len()). map[i] = (k, v)).
    /// ```
    ///
    /// An index map `map1` is a **permutation** of an index map `map2` if it satisfies
    ///
    /// ```text
    /// is_permutation(map1, map2) :=
    ///     map1.len() = map2.len()
    ///     ∧ (∀ i ∈ [0, map1.len()). ∃ j ∈ [0, map2.len()). map1[i] = map2[j])
    ///     ∧ (∀ i ∈ [0, map2.len()). ∃ j ∈ [0, map1.len()). map2[i] = map1[j])
    /// ```
    ///
    /// Note that multiset equality is not needed here because every key is unique in an index map.
    ///
    /// The index map `map` is **sorted** with respect to its keys if
    ///
    /// ```text
    /// is_sorted(map) := ∀ i ∈ [0, map.len() - 1). map[i].key() ≤ map[i + 1].key().
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { true }
    /// map.sort_unstable_keys()
    /// {
    ///     map_after.len() = map_before.len()
    ///     ∧ is_permutation(map_after, map_before)
    ///     ∧ is_sorted(map_after)
    /// }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (5_isize, 'e'),
    ///     (2_isize, 'b'),
    ///     (1_isize, 'a'),
    ///     (4_isize, 'd'),
    ///     (3_isize, 'c'),
    /// ]);
    /// proj_map.sort_unstable_keys();
    /// let expected = [
    ///     (1_isize, 'a'),
    ///     (2_isize, 'b'),
    ///     (3_isize, 'c'),
    ///     (4_isize, 'd'),
    ///     (5_isize, 'e'),
    /// ];
    ///
    /// assert_eq!(proj_map.as_slice(), expected.as_slice());
    /// ```
    pub fn sort_unstable_keys(&mut self)
    where
        K: Ord,
    {
        self.inner.sort_unstable_keys();
    }

    /// Sorts the entries in the index map in place into the sorted ordering of the entries as
    /// defined by the provided comparison function, but may not preserve the order of equal values.
    ///
    /// After this method completes, the index map will be in unstable sorted order with the
    /// ordering defined by the comparison function.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Specification Definitions
    ///
    /// A **comparator** is a map `cmp : K ⨯ V ⨯ K ⨯ V → Ordering` such that given entries
    /// `(k1, v1) :: (K, V)` and `(k2, v2) :: (K, V)` from a partially ordered collection of
    /// entries
    ///
    /// ```text
    /// cmp(k1, v1, k2, v2) = Ordering::Greater when (k1, v1) > (k2, v2)
    /// cmp(k1, v1, k2, v2) = Ordering::Less    when (k1, v1) < (k2, v2)
    /// cmp(k1, v1, k2, v2) = Ordering::Equal   when (k1, v1) = (k2, v2)
    /// ```
    ///
    /// An index map `map1` is a **permutation** of an index map `map2` if it satisfies
    ///
    /// ```text
    /// is_permutation(map1, map2) :=
    ///     map1.len() = map2.len()
    ///     ∧ (∀ i ∈ [0, map1.len()). ∃ j ∈ [0, map2.len()). map1[i] = map2[j])
    ///     ∧ (∀ i ∈ [0, map2.len()). ∃ j ∈ [0, map1.len()). map2[i] = map1[j])
    /// ```
    ///
    /// Note that multiset equality is not needed here because every key is unique in an index map.
    ///
    /// The index map `map` is **sorted** with respect to the comparator `cmp` if
    ///
    /// ```text
    /// is_sorted(map, cmp) := ∀ i ∈ [0, map.len() - 1).
    ///     cmp(map[i].key(), map[i].value(), map[i + 1].key(), map[i + 1].value()) != Greater
    /// ```
    ///
    /// holds.
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { true }
    /// map.sort_unstable_by(cmp)
    /// {
    ///     map_after.len() = map_before.len()
    ///     ∧ is_permutation(map_after, map_before)
    ///     ∧ is_sorted(map_after cmp)
    /// }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map = TypedProjIndexMap::from([
    ///     (6_isize, 'a'),
    ///     (2_isize, 'b'),
    ///     (1_isize, 'a'),
    ///     (4_isize, 'a'),
    ///     (3_isize, 'b'),
    ///     (5_isize, 'b'),
    /// ]);
    /// let result = {
    ///     let mut _map = proj_map.clone();
    ///     _map.sort_unstable_by(|k1, v1, k2, v2| {
    ///         match v1.cmp(&v2) {
    ///             Ordering::Equal => k1.cmp(&k2),
    ///             Ordering::Greater => Ordering::Greater,
    ///             Ordering::Less => Ordering::Less,
    ///         }
    ///     });
    ///     _map
    /// };
    /// let expected = [
    ///     (1_isize, 'a'),
    ///     (4_isize, 'a'),
    ///     (6_isize, 'a'),
    ///     (2_isize, 'b'),
    ///     (3_isize, 'b'),
    ///     (5_isize, 'b'),
    /// ];
    ///
    /// assert_eq!(result.as_slice(), expected.as_slice());
    /// ```
    pub fn sort_unstable_by<F>(&mut self, cmp: F)
    where
        F: FnMut(&K, &V, &K, &V) -> cmp::Ordering,
    {
        self.inner.sort_unstable_by(cmp);
    }

    /// Returns a moving iterator that returns the entries of the index map in sorted order as
    /// defined by the provided comparison function.
    ///
    /// The resulting moving iterator will return the elements in unstable sorted order.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map = TypedProjIndexMap::from([
    ///     (6_isize, 'a'),
    ///     (2_isize, 'b'),
    ///     (1_isize, 'a'),
    ///     (4_isize, 'a'),
    ///     (3_isize, 'b'),
    ///     (5_isize, 'b'),
    /// ]);
    /// let result: TypedProjVec<(isize, char)> = proj_map
    ///     .sorted_unstable_by(|k1, v1, k2, v2| {
    ///         match v1.cmp(&v2) {
    ///             Ordering::Equal => k1.cmp(&k2),
    ///             Ordering::Greater => Ordering::Greater,
    ///             Ordering::Less => Ordering::Less,
    ///         }
    ///     })
    ///     .collect();
    /// let expected = TypedProjVec::from([
    ///     (1_isize, 'a'),
    ///     (4_isize, 'a'),
    ///     (6_isize, 'a'),
    ///     (2_isize, 'b'),
    ///     (3_isize, 'b'),
    ///     (5_isize, 'b'),
    /// ]);
    ///
    /// assert_eq!(result.as_slice(), expected.as_slice());
    /// ```
    #[inline]
    pub fn sorted_unstable_by<F>(self, cmp: F) -> IntoIter<K, V, A>
    where
        F: FnMut(&K, &V, &K, &V) -> cmp::Ordering,
    {
        IntoIter::new(self.inner.sorted_unstable_by(cmp))
    }

    /// Sort the entries of the index map in place using a sort-key extraction function.
    ///
    /// During sorting, the function is called at most once per entry, by using temporary storage
    /// to remember the results of its evaluation. The order of calls to the function is
    /// unspecified. The sort is stable.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (0_usize,  4_i32),
    ///     (1_usize, -8_i32),
    ///     (2_usize, -1_i32),
    ///     (3_usize, -10_i32),
    ///     (4_usize,  2_i32),
    ///     (5_usize,  11_i32),
    ///     (6_usize,  7_i32),
    ///     (7_usize,  100_i32),
    /// ]);
    ///
    /// // Strings are sorted by lexicographical order.
    /// proj_map.sort_by_cached_key(|k, v| v.to_string());
    /// let expected = [
    ///     (2_usize, -1_i32),
    ///     (3_usize, -10_i32),
    ///     (1_usize, -8_i32),
    ///     (7_usize,  100_i32),
    ///     (5_usize,  11_i32),
    ///     (4_usize,  2_i32),
    ///     (0_usize,  4_i32),
    ///     (6_usize,  7_i32),
    /// ];
    ///
    /// assert_eq!(proj_map.as_slice(), expected.as_slice());
    /// ```
    pub fn sort_by_cached_key<T, F>(&mut self, mut sort_key: F)
    where
        T: Ord,
        F: FnMut(&K, &V) -> T,
    {
        self.inner.sort_by_cached_key(&mut sort_key);
    }

    /// Binary searches a sorted index map for the given key. If the index map is unsorted, the
    /// returned result is unspecified and meaningless.
    ///
    /// If the entry with the key `key` is found in the map, then this method returns `Ok(index)`,
    /// where `index` is the storage index of the entry with key `key` in the map. If the entry
    /// with the key `key` is not found in the map, then this method returns `Err(new_index)` where
    /// `new_index` is the position in the storage where an entry with the key `key` could be
    /// inserted to maintain the sorted order.
    ///
    /// # Examples
    ///
    /// Binary searching a sorted index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<isize, char> = TypedProjIndexMap::from_iter((1_isize..=26_isize).zip('a'..='z'));
    /// for (i, (key, value)) in (1_isize..=26_isize).zip('a'..='z').enumerate() {
    ///     let result = proj_map.binary_search_keys(&key);
    ///     assert_eq!(result, Ok(i));
    /// }
    /// ```
    pub fn binary_search_keys(&self, key: &K) -> Result<usize, usize>
    where
        K: Ord,
    {
        self.inner.binary_search_keys(key)
    }

    /// Binary searches a sorted index map using a given comparator function. If the index map is
    /// unsorted, the returned result is unspecified and meaningless.
    ///
    /// The comparator function should return an order code that indicates whether its argument is
    /// `Less`, `Equal` or `Greater` than the desired target.
    ///
    /// If the index map is not in sorted order or if the comparator function does not implement an
    /// order consistent with the sorted order of the underlying index map, the returned result is
    /// unspecified and meaningless.
    ///
    /// If an entry satisfying the comparator is found in the map, then this method returns
    /// `Ok(index)`, where `index` is the storage index of the entry found in the map. If an entry
    /// satisfying the comparator is not found in the map, then this method returns
    /// `Err(new_index)` where `new_index` is the position in the storage where an entry with the
    /// key `key` could be inserted to maintain the sorted order. If multiple entries in the index
    /// map satisfy the comparator, then any one of them could be returned. The index is chosen
    /// deterministically, but this method makes no guarantees as to how it picks that index.
    ///
    /// # Examples
    ///
    /// Binary searching a sorted index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<isize, char> = TypedProjIndexMap::from_iter((1_isize..=26_isize).zip('a'..='z'));
    /// let expected = Ok(23);
    /// let result = proj_map.binary_search_by(|k, v| v.cmp(&'x'));
    ///
    /// assert_eq!(result, expected);
    ///
    /// assert!('*' < 'a');
    ///
    /// let expected = Err(0);
    /// let result = proj_map.binary_search_by(|k, v| v.cmp(&'*'));
    ///
    /// assert_eq!(result, expected);
    /// ```
    ///
    /// Binary searching a sorted index map with repeating values.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map = TypedProjIndexMap::from([
    ///     (1_usize, 'a'), (2_usize, 'b'), (3_usize, 'c'),
    ///     (4_usize, 'd'), (5_usize, 'd'), (6_usize, 'd'),  (7_usize, 'd'),
    ///     (8_usize, 'e'), (9_usize, 'f'), (10_usize, 'g'), (11_usize, 'h'),
    /// ]);
    ///
    /// assert_eq!(proj_map.binary_search_by(|&k, &v| v.cmp(&'a')), Ok(0));
    /// assert_eq!(proj_map.binary_search_by(|&k, &v| v.cmp(&'b')), Ok(1));
    /// assert_eq!(proj_map.binary_search_by(|&k, &v| v.cmp(&'c')), Ok(2));
    ///
    /// let result = proj_map.binary_search_by(|&k, &v| v.cmp(&'d'));
    /// assert!(match result { Ok(3..=6) => true, _ => false });
    ///
    /// assert_eq!(proj_map.binary_search_by(|&k, &v| v.cmp(&'e')), Ok(7));
    /// assert_eq!(proj_map.binary_search_by(|&k, &v| v.cmp(&'f')), Ok(8));
    /// assert_eq!(proj_map.binary_search_by(|&k, &v| v.cmp(&'g')), Ok(9));
    /// assert_eq!(proj_map.binary_search_by(|&k, &v| v.cmp(&'h')), Ok(10));
    /// ```
    #[inline]
    pub fn binary_search_by<F>(&self, f: F) -> Result<usize, usize>
    where
        F: FnMut(&K, &V) -> cmp::Ordering,
    {
        self.inner.binary_search_by(f)
    }

    /// Binary searches the index map with a key extraction function.
    ///
    /// This method assumes that the index map is in sorted order by the key, for instance with
    /// [`sort_by_key`] using the same key extraction function. If the index map is not sorted by
    /// the key, the returned result is unspecified and meaningless.
    ///
    /// If an entry matching the key is found in the map, then this method returns `Ok(index)`,
    /// where `index` is the storage index of the entry found in the map. If an entry matching the
    /// key is not found in the map, then this method returns `Err(new_index)` where `new_index`
    /// is the position in the storage where an entry with the matching key could be inserted to
    /// maintain the sorted order. If multiple entries in the index map match the key, then any one
    /// of them could be returned. The index is chosen deterministically, but this method makes no
    /// guarantees as to how it picks that index.
    ///
    /// See also [`binary_search`], [`binary_search_by`], and [`partition_point`].
    ///
    /// [`sort_by_key`]: TypedProjIndexMap::sort_by_key
    /// [`binary_search`]: TypedProjIndexMap::binary_search
    /// [`binary_search_by`]: TypedProjIndexMap::binary_search_by
    /// [`partition_point`]: TypedProjIndexMap::partition_point
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map = TypedProjIndexMap::from([
    ///     (0_usize,  0_isize),
    ///     (1_usize,  1_isize), (2_usize, 1_isize), (3_usize, 1_isize), (4_usize, 1_isize),
    ///     (5_usize,  2_isize),
    ///     (6_usize,  3_isize),
    ///     (7_usize,  5_isize),
    ///     (8_usize,  8_isize),
    ///     (9_usize,  13_isize),
    ///     (10_usize, 21_isize),
    ///     (11_usize, 34_isize),
    ///     (12_usize, 55_isize),
    /// ]);
    ///
    /// assert_eq!(proj_map.binary_search_by_key(&13, |&a, &b| b),  Ok(9));
    /// assert_eq!(proj_map.binary_search_by_key(&4, |&a, &b| b),   Err(7));
    /// assert_eq!(proj_map.binary_search_by_key(&100, |&a, &b| b), Err(13));
    ///
    /// let result = proj_map.binary_search_by_key(&1, |&a, &b| b);
    ///
    /// assert!(match result { Ok(1..=4) => true, _ => false, });
    /// ```
    #[inline]
    pub fn binary_search_by_key<B, F>(&self, b: &B, f: F) -> Result<usize, usize>
    where
        F: FnMut(&K, &V) -> B,
        B: Ord,
    {
        self.inner.binary_search_by_key(b, f)
    }

    /// Returns the index of the partition point of a sorted index map according to the given
    /// predicate (the index of the first element of the second partition).
    ///
    /// This method assumes that the storage order of the entries in the index map is partitioned
    /// according to the predicate. That is, all entries for which the predicate returns `true` are
    /// at the start of the storage, and all entries for which the predicate returns `false` are at
    /// the end of the index map's storage. If the index map's storage order does not partition
    /// according to the predicate, the result is unspecified and meaningless.
    ///
    /// # Examples
    ///
    /// Finding the partition point of a partitioned index map where not every entry matches the
    /// predicate.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map = TypedProjIndexMap::from([
    ///     (0_usize, 1_isize),
    ///     (1_usize, 2_isize),
    ///     (2_usize, 2_isize),
    ///     (3_usize, 3_isize),
    ///     (4_usize, 5_isize),
    ///     (5_usize, 5_isize),
    ///     (6_usize, 5_isize),
    ///     (7_usize, 6_isize),
    ///     (8_usize, 9_isize),
    /// ]);
    ///
    /// assert_eq!(proj_map.partition_point(|&k, &v| v < 5_isize), 4);
    /// ```
    ///
    /// Finding the partition point of an index map where every entry matches the predicate.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// fn is_power_of_two(n: usize) -> bool {
    ///     n != 0 && (n & (n - 1)) == 0
    /// }
    ///
    /// let proj_map = TypedProjIndexMap::from([
    ///     (0_usize, 1_usize),
    ///     (1_usize, 2_usize),
    ///     (2_usize, 4_usize),
    ///     (3_usize, 8_usize),
    ///     (4_usize, 16_usize),
    ///     (5_usize, 32_usize),
    ///     (6_usize, 64_usize),
    /// ]);
    ///
    /// assert_eq!(proj_map.partition_point(|&k, &v| is_power_of_two(v)), proj_map.len());
    /// ```
    ///
    /// Finding the partition point of an index map where no entry matches the predicate.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// fn is_power_of_two(n: usize) -> bool {
    ///     n != 0 && (n & (n - 1)) == 0
    /// }
    ///
    /// let proj_map = TypedProjIndexMap::from([
    ///     (0_usize, 3_usize),
    ///     (1_usize, 5_usize),
    ///     (2_usize, 7_usize),
    ///     (3_usize, 11_usize),
    ///     (4_usize, 13_usize),
    ///     (5_usize, 17_usize),
    ///     (6_usize, 19_usize),
    /// ]);
    ///
    /// assert_eq!(proj_map.partition_point(|&k, &v| is_power_of_two(v)), 0);
    /// ```
    #[must_use]
    pub fn partition_point<P>(&self, pred: P) -> usize
    where
        P: FnMut(&K, &V) -> bool,
    {
        self.inner.partition_point(pred)
    }

    /// Reverses the storage order of the index map's entries in place.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (0_usize, "foo"),
    ///     (1_usize, "bar"),
    ///     (2_usize, "baz"),
    ///     (3_usize, "quux"),
    /// ]);
    /// let expected = [
    ///     (3_usize, "quux"),
    ///     (2_usize, "baz"),
    ///     (1_usize, "bar"),
    ///     (0_usize, "foo"),
    /// ];
    /// proj_map.reverse();
    ///
    /// assert_eq!(proj_map.as_slice(), expected.as_slice());
    /// ```
    pub fn reverse(&mut self) {
        self.inner.reverse();
    }

    /// Attempts to reserve capacity for **at least** `additional` more elements to be inserted
    /// in the given index map.
    ///
    /// The collection may reserve more space to speculatively avoid frequent reallocations.
    /// After calling this method, the capacity will be greater than or equal to
    /// `self.len() + additional` if it returns. This method does nothing if the collection
    /// capacity is already sufficient. This method preserves the contents even if a panic occurs.
    ///
    /// # Panics
    ///
    /// This method panics if one of the following conditions occurs:
    ///
    /// * If the capacity of the index map overflows.
    /// * If the allocator reports a failure.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    ///     (4_usize, 5_i32),
    ///     (5_usize, 6_i32),
    /// ]);
    /// proj_map.reserve(10);
    ///
    /// assert!(proj_map.capacity() >= proj_map.len() + 10);
    ///
    /// let old_capacity = proj_map.capacity();
    /// proj_map.extend([(6_usize, 7_i32), (7_usize, 8_i32), (8_usize, 9_i32), (9_usize, 10_i32)]);
    ///
    /// assert_eq!(proj_map.capacity(), old_capacity);
    /// ```
    pub fn reserve(&mut self, additional: usize) {
        self.inner.reserve(additional);
    }

    /// Attempts to reserve capacity for **at least** `additional` more elements to be inserted
    /// in the given index map.
    ///
    /// Unlike [`reserve`], this will not deliberately over-allocate to speculatively avoid
    /// frequent allocations. After calling `reserve_exact`, the capacity of `self` will be greater
    /// than or equal to `self.len() + additional`. This method does nothing if the capacity is
    /// already sufficient.
    ///
    /// [`reserve`]: TypedProjIndexMap::reserve
    ///
    /// # Panics
    ///
    /// This method panics if one of the following conditions occurs:
    ///
    /// * If the capacity of the index map overflows.
    /// * If the allocator reports a failure.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    ///     (4_usize, 5_i32),
    ///     (5_usize, 6_i32),
    /// ]);
    /// proj_map.reserve_exact(10);
    ///
    /// assert!(proj_map.capacity() >= proj_map.len() + 10);
    ///
    /// let old_capacity = proj_map.capacity();
    /// proj_map.extend([(6_usize, 7_i32), (7_usize, 8_i32), (8_usize, 9_i32), (9_usize, 10_i32)]);
    ///
    /// assert_eq!(proj_map.capacity(), old_capacity);
    /// ```
    pub fn reserve_exact(&mut self, additional: usize) {
        self.inner.reserve_exact(additional);
    }

    /// Attempts to reserve capacity for **at least** `additional` more elements to be inserted
    /// in the given index map.
    ///
    /// The collection may reserve more space to speculatively avoid frequent reallocations.
    /// After calling this method, the capacity will be greater than or equal to
    /// `self.len() + additional` if it returns `Ok(())`. This method does nothing if the collection
    /// capacity is already sufficient. This method preserves the contents even if an error occurs.
    ///
    /// # Errors
    ///
    /// This method returns an error if the capacity overflows, or the allocator reports a failure.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    ///     (4_usize, 5_i32),
    ///     (5_usize, 6_i32),
    /// ]);
    /// let result = proj_map.try_reserve(10);
    ///
    /// assert!(result.is_ok());
    /// assert!(proj_map.capacity() >= proj_map.len() + 10);
    ///
    /// let old_capacity = proj_map.capacity();
    /// proj_map.extend([(6_usize, 7_i32), (7_usize, 8_i32), (8_usize, 9_i32), (9_usize, 10_i32)]);
    ///
    /// assert_eq!(proj_map.capacity(), old_capacity);
    /// ```
    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {
        self.inner.try_reserve(additional)
    }

    /// Attempts to reserve capacity for **at least** `additional` more elements to be inserted
    /// in the given index map.
    ///
    /// Unlike [`try_reserve`], this will not deliberately over-allocate to speculatively avoid
    /// frequent allocations. After calling `reserve_exact`, the capacity of `self` will be greater
    /// than or equal to `self.len() + additional`. This method does nothing if the capacity is
    /// already sufficient.
    ///
    /// [`try_reserve`]: TypedProjIndexMap::try_reserve
    ///
    /// # Errors
    ///
    /// This method returns an error if the capacity overflows, or the allocator reports a failure.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    ///     (4_usize, 5_i32),
    ///     (5_usize, 6_i32),
    /// ]);
    /// let result = proj_map.try_reserve_exact(10);
    ///
    /// assert!(result.is_ok());
    /// assert!(proj_map.capacity() >= proj_map.len() + 10);
    ///
    /// let old_capacity = proj_map.capacity();
    /// proj_map.extend([(6_usize, 7_i32), (7_usize, 8_i32), (8_usize, 9_i32), (9_usize, 10_i32)]);
    ///
    /// assert_eq!(proj_map.capacity(), old_capacity);
    /// ```
    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError> {
        self.inner.try_reserve_exact(additional)
    }

    /// Shrinks the capacity of the index map as much as possible.
    ///
    /// The behavior of this method depends on the allocator, which may either shrink the
    /// index map in place or reallocate. The resulting index map might still have some excess
    /// capacity, just as is the case for [`with_capacity`]. See [`Allocator::shrink`] for more
    /// details.
    ///
    /// [`with_capacity`]: TypedProjIndexMap::with_capacity
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::with_capacity(10);
    /// proj_map.extend([(0_usize, 1_i32), (1_usize, 2_i32), (2_usize, 3_i32)]);
    ///
    /// assert!(proj_map.capacity() >= 10);
    ///
    /// proj_map.shrink_to_fit();
    ///
    /// assert!(proj_map.capacity() >= 3);
    /// ```
    pub fn shrink_to_fit(&mut self) {
        self.inner.shrink_to_fit();
    }

    /// Shrinks the capacity of the index map to a lower bound.
    ///
    /// The behavior of this method depends on the allocator, which may either shrink the
    /// index map in place or reallocate. The resulting index map might still have some excess
    /// capacity, just as is the case for [`with_capacity`]. See [`Allocator::shrink`] for more
    /// details.
    ///
    /// The capacity will remain at least as large as both the length
    /// and the supplied capacity `min_capacity`. In particular, after calling this method,
    /// the capacity of `self` satisfies
    ///
    /// ```text
    /// self.capacity() >= max(self.len(), min_capacity).
    /// ```
    ///
    /// If the current capacity of the index map is less than the lower bound, the method does
    /// nothing.
    ///
    /// [`with_capacity`]: TypedProjIndexMap::with_capacity
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::with_capacity(10);
    /// proj_map.extend([(0_usize, 1_i32), (1_usize, 2_i32), (2_usize, 3_i32)]);
    ///
    /// assert!(proj_map.capacity() >= 10);
    ///
    /// proj_map.shrink_to(4);
    ///
    /// assert!(proj_map.capacity() >= 4);
    ///
    /// proj_map.shrink_to(0);
    ///
    /// assert!(proj_map.capacity() >= 3);
    /// ```
    pub fn shrink_to(&mut self, min_capacity: usize) {
        self.inner.shrink_to(min_capacity);
    }
}

#[cfg(feature = "nightly")]
impl<K, V, S, A> TypedProjIndexMap<K, V, S, A>
where
    K: any::Any,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    /// Converts an index map into a [`Box<[T]>`][owned slice].
    ///
    /// Before doing the conversion, this method discards excess capacity like [`shrink_to_fit`].
    ///
    /// [owned slice]: Box
    /// [`shrink_to_fit`]: TypedProjIndexMap::shrink_to_fit
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::map::{Slice, TypedProjIndexMap};
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::with_capacity(10);
    /// proj_map.extend([(0_usize, 1_i32), (1_usize, 2_i32), (2_usize, 3_i32)]);
    ///
    /// assert_eq!(proj_map.len(), 3);
    /// assert_eq!(proj_map.capacity(), 10);
    /// assert_eq!(proj_map.as_slice(), &[(0_usize, 1_i32), (1_usize, 2_i32), (2_usize, 3_i32)]);
    ///
    /// let boxed_slice: Box<Slice<usize, i32>, TypedProjAlloc<Global>> = proj_map.into_boxed_slice();
    ///
    /// assert_eq!(boxed_slice.len(), 3);
    /// assert_eq!(boxed_slice.as_ref(), &[(0_usize, 1_i32), (1_usize, 2_i32), (2_usize, 3_i32)]);
    /// ```
    pub fn into_boxed_slice(self) -> Box<Slice<K, V>, TypedProjAlloc<A>> {
        Slice::from_boxed_slice(self.inner.into_boxed_slice())
    }
}

impl<K, V, S, A> TypedProjIndexMap<K, V, S, A>
where
    K: any::Any,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    /// Returns a (key reference, value reference) pair corresponding to the key-value pair stored
    /// at a given storage index in the index map, if it exists.
    ///
    /// If `index < self.len()`, this method returns `Some((&key, &value))`, where `key` is the key
    /// of the entry at index `index` in the map, and `value` is the value of the entry at index
    /// `index`. If `index >= self.len()`, this method returns `None`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with keys of type `K` and values of type `V`.
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { index < map.len() }
    /// map.get_index(index)
    /// { result = Some(map[index]) }
    ///
    /// { index >= map.len() }
    /// map.get_index(index)
    /// { result = None }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map = TypedProjIndexMap::from([
    ///     (1_usize, 10_i32),
    ///     (2_usize, 40_i32),
    ///     (3_usize, 30_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_index(0), Some((&1_usize, &10_i32)));
    /// assert_eq!(proj_map.get_index(1), Some((&2_usize, &40_i32)));
    /// assert_eq!(proj_map.get_index(2), Some((&3_usize, &30_i32)));
    /// assert_eq!(proj_map.get_index(3), None);
    /// ```
    pub fn get_index(&self, index: usize) -> Option<(&K, &V)> {
        self.inner.get_index(index)
    }

    /// Returns a (key reference, mutable value reference) pair corresponding to the key-value pair
    /// stored at a given storage index in the index map, if it exists.
    ///
    /// If `index < self.len()`, this method returns `Some((&key, &mut value))`, where `key` is the
    /// key of the entry at index `index` in the map, and `value` is the value of the entry at
    /// index `index`. If `index >= self.len()`, this method returns `None`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with keys of type `K` and values of type `V`.
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { index < map.len() }
    /// map.get_index_mut(index)
    /// { result = Some(map[index]) }
    ///
    /// { index >= map.len() }
    /// map.get_index_mut(index)
    /// { result = None }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (1_usize, 10_i32),
    ///     (2_usize, 40_i32),
    ///     (3_usize, 30_i32),
    /// ]);
    ///
    /// assert_eq!(proj_map.get_index_mut(0), Some((&1_usize, &mut 10_i32)));
    /// assert_eq!(proj_map.get_index_mut(1), Some((&2_usize, &mut 40_i32)));
    /// assert_eq!(proj_map.get_index_mut(2), Some((&3_usize, &mut 30_i32)));
    /// assert_eq!(proj_map.get_index_mut(3), None);
    /// ```
    pub fn get_index_mut(&mut self, index: usize) -> Option<(&K, &mut V)> {
        self.inner.get_index_mut(index)
    }

    /// Returns the entry in the index map with the given storage index, if it exists.
    ///
    /// If `index < self.len()`, this method returns `Some(entry)`, where `entry` is the entry
    /// storage at the index `index` in the index map. If `index >= self.len()`, this method
    /// returns `None`.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (1_usize, 10_i32),
    ///     (2_usize, 40_i32),
    ///     (3_usize, 30_i32),
    /// ]);
    ///
    /// assert!(proj_map.get_index_entry(0).is_some());
    /// assert!(proj_map.get_index_entry(1).is_some());
    /// assert!(proj_map.get_index_entry(2).is_some());
    ///
    /// assert_eq!(proj_map.get_index_entry(0).unwrap().key(), &1_usize);
    /// assert_eq!(proj_map.get_index_entry(0).unwrap().index(), 0);
    /// assert_eq!(proj_map.get_index_entry(0).unwrap().get(), &10_i32);
    ///
    /// assert_eq!(proj_map.get_index_entry(1).unwrap().key(), &2_usize);
    /// assert_eq!(proj_map.get_index_entry(1).unwrap().index(), 1);
    /// assert_eq!(proj_map.get_index_entry(1).unwrap().get(), &40_i32);
    ///
    /// assert_eq!(proj_map.get_index_entry(2).unwrap().key(), &3_usize);
    /// assert_eq!(proj_map.get_index_entry(2).unwrap().index(), 2);
    /// assert_eq!(proj_map.get_index_entry(2).unwrap().get(), &30_i32);
    ///
    /// assert!(proj_map.get_index_entry(3).is_none());
    /// ```
    pub fn get_index_entry(&mut self, index: usize) -> Option<IndexedEntry<'_, K, V, A>>
    where
        K: Ord,
    {
        self.inner.get_index_entry(index).map(IndexedEntry::new)
    }

    /// Returns multiple references to the values of the entries at multiple storage indices at
    /// once.
    ///
    /// # Panics
    ///
    /// This method panics if there are any duplicate indices.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (1_isize, 'a'),
    ///     (3_isize, 'b'),
    ///     (2_isize, 'c'),
    ///     (6_isize, 'e'),
    ///     (4_isize, 'f'),
    ///     (5_isize, '@'),
    /// ]);
    ///
    /// let maybe_result = proj_map.get_disjoint_indices_mut([2, 1, 5]);
    ///
    /// assert!(maybe_result.is_ok());
    ///
    /// let result = maybe_result.unwrap();
    ///
    /// assert_eq!(result[0], (&2_isize, &mut 'c'));
    /// assert_eq!(result[1], (&3_isize, &mut 'b'));
    /// assert_eq!(result[2], (&5_isize, &mut '@'));
    /// ```
    #[track_caller]
    pub fn get_disjoint_indices_mut<const N: usize>(
        &mut self,
        indices: [usize; N]
    ) -> Result<[(&K, &mut V); N], GetDisjointMutError>
    {
        self.inner.get_disjoint_indices_mut(indices)
    }

    /// Returns a slice of entries in the index map in the given storage range in the map.
    ///
    /// If the range `range` is in bounds, this method returns `Some(&slice)`, where `slice` is the
    /// slice of entries from the index map in the storage range `range`. if the range `range` is
    /// out of bounds, this method returns `None`.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map = TypedProjIndexMap::from([
    ///     (1_usize, 10_i32),
    ///     (2_usize, 40_i32),
    ///     (3_usize, 30_i32),
    ///     (4_usize, 60_i32),
    /// ]);
    ///
    /// let maybe_slice = proj_map.get_range(1..);
    ///
    /// assert!(maybe_slice.is_some());
    ///
    /// let slice = maybe_slice.unwrap();
    ///
    /// assert_eq!(slice.len(), 3);
    /// assert_eq!(slice[0], 40_i32);
    /// assert_eq!(slice[1], 30_i32);
    /// assert_eq!(slice[2], 60_i32);
    /// ```
    pub fn get_range<R>(&self, range: R) -> Option<&Slice<K, V>>
    where
        R: ops::RangeBounds<usize>,
    {
        self.inner.get_range(range).map(Slice::from_slice)
    }

    /// Returns a mutable slice of entries in the index map in the given storage range in the map.
    ///
    /// If the range `range` is in bounds, this method returns `Some(&mut slice)`, where `slice` is
    /// the slice of entries from the index map in the storage range `range`. if the range `range`
    /// is out of bounds, this method returns `None`.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (1_usize, 10_i32),
    ///     (2_usize, 40_i32),
    ///     (3_usize, 30_i32),
    ///     (4_usize, 60_i32),
    /// ]);
    ///
    /// let maybe_slice = proj_map.get_range_mut(1..);
    ///
    /// assert!(maybe_slice.is_some());
    ///
    /// let slice = maybe_slice.unwrap();
    ///
    /// assert_eq!(slice.len(), 3);
    /// assert_eq!(slice[0], 40_i32);
    /// assert_eq!(slice[1], 30_i32);
    /// assert_eq!(slice[2], 60_i32);
    /// ```
    pub fn get_range_mut<R>(&mut self, range: R) -> Option<&mut Slice<K, V>>
    where
        R: ops::RangeBounds<usize>,
    {
        self.inner.get_range_mut(range).map(Slice::from_slice_mut)
    }

    /// Returns a reference to the first entry in the index map as a
    /// (key reference, value reference) pair, if it exists.
    ///
    /// If the index map is nonempty, this method returns `Some((&key, &value))` where `key` is the
    /// key of the first entry in the index map, and `value` is the value of the first entry in the
    /// index map. If the index map is empty, this method returns `None`.
    ///
    /// # Examples
    ///
    /// Getting the first entry of a non-empty index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map = TypedProjIndexMap::from([
    ///     (String::from("foo"),  1_usize),
    ///     (String::from("bar"),  2_usize),
    ///     (String::from("baz"),  3_usize),
    ///     (String::from("quux"), 4_usize),
    /// ]);
    /// let result = proj_map.first();
    ///
    /// assert_eq!(result, Some((&String::from("foo"), &1_usize)));
    /// ```
    ///
    /// Getting the first entry from an empty index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<String, usize> = TypedProjIndexMap::new();
    /// let maybe_entry = proj_map.first();
    ///
    /// assert!(maybe_entry.is_none());
    /// ```
    #[doc(alias = "first_key_value")]
    pub fn first(&self) -> Option<(&K, &V)> {
        self.inner.first()
    }

    /// Returns a reference to the first entry in the index map as a
    /// (key reference, mutable value reference) pair, if it exists.
    ///
    /// If the index map is nonempty, this method returns `Some((&key, &mut value))` where `key` is
    /// the key of the first entry in the index map, and `value` is the value of the first entry in
    /// the index map. If the index map is empty, this method returns `None`.
    ///
    /// # Examples
    ///
    /// Getting the first entry of a non-empty index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (String::from("foo"),  1_usize),
    ///     (String::from("bar"),  2_usize),
    ///     (String::from("baz"),  3_usize),
    ///     (String::from("quux"), 4_usize),
    /// ]);
    /// let result = proj_map.first_mut();
    ///
    /// assert_eq!(result, Some((&String::from("foo"), &mut 1_usize)));
    /// ```
    ///
    /// Getting the first entry from an empty index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<String, usize> = TypedProjIndexMap::new();
    /// let maybe_entry = proj_map.first_mut();
    ///
    /// assert!(maybe_entry.is_none());
    /// ```
    pub fn first_mut(&mut self) -> Option<(&K, &mut V)> {
        self.inner.first_mut()
    }

    /// Returns the first entry in the index map, if it exists.
    ///
    /// If the index map is nonempty, this method returns `Some(entry)` where `entry` is the first
    /// entry in the index map. If the index map is empty, this method returns `None`.
    ///
    /// # Examples
    ///
    /// Getting the first entry of a non-empty index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (String::from("foo"),  1_usize),
    ///     (String::from("bar"),  2_usize),
    ///     (String::from("baz"),  3_usize),
    ///     (String::from("quux"), 4_usize),
    /// ]);
    /// let maybe_entry = proj_map.first_entry();
    ///
    /// assert!(maybe_entry.is_some());
    ///
    /// let entry = maybe_entry.unwrap();
    ///
    /// assert_eq!(entry.key(), "foo");
    /// assert_eq!(entry.index(), 0);
    /// assert_eq!(entry.get(), &1_usize);
    /// ```
    ///
    /// Getting the first entry from an empty index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<String, usize> = TypedProjIndexMap::new();
    /// let entry = proj_map.first_entry();
    ///
    /// assert!(entry.is_none());
    /// ```
    pub fn first_entry(&mut self) -> Option<IndexedEntry<'_, K, V, A>>
    where
        K: Ord,
    {
        self.inner.first_entry().map(IndexedEntry::new)
    }

    /// Returns a reference to the last entry in the index map as a (key reference, value reference)
    /// pair, if it exists.
    ///
    /// If the index map is nonempty, this method returns `Some((&key, &value))` where `key` is the
    /// key of the last entry in the index map, and `value` is the value of the last entry in the
    /// index map. If the index map is empty, this method returns `None`.
    ///
    /// # Examples
    ///
    /// Getting the last entry of a non-empty index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map = TypedProjIndexMap::from([
    ///     (String::from("foo"),  1_usize),
    ///     (String::from("bar"),  2_usize),
    ///     (String::from("baz"),  3_usize),
    ///     (String::from("quux"), 4_usize),
    /// ]);
    /// let result = proj_map.last();
    ///
    /// assert_eq!(result, Some((&String::from("quux"), &4_usize)));
    /// ```
    ///
    /// Getting the last entry from an empty index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<String, usize> = TypedProjIndexMap::new();
    /// let maybe_entry = proj_map.last();
    ///
    /// assert!(maybe_entry.is_none());
    /// ```
    #[doc(alias = "last_key_value")]
    pub fn last(&self) -> Option<(&K, &V)> {
        self.inner.last()
    }

    /// Returns a reference to the last entry in the index map as a
    /// (key reference, mutable value reference) pair, if it exists.
    ///
    /// If the index map is nonempty, this method returns `Some((&key, &mut value))` where `key` is
    /// the key of the last entry in the index map, and `value` is the value of the last entry in
    /// the index map. If the index map is empty, this method returns `None`.
    ///
    /// # Examples
    ///
    /// Getting the last entry of a non-empty index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (String::from("foo"),  1_usize),
    ///     (String::from("bar"),  2_usize),
    ///     (String::from("baz"),  3_usize),
    ///     (String::from("quux"), 4_usize),
    /// ]);
    /// let result = proj_map.last_mut();
    ///
    /// assert_eq!(result, Some((&String::from("quux"), &mut 4_usize)));
    /// ```
    ///
    /// Getting the last entry from an empty index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<String, usize> = TypedProjIndexMap::new();
    /// let maybe_entry = proj_map.last_mut();
    ///
    /// assert!(maybe_entry.is_none());
    /// ```
    pub fn last_mut(&mut self) -> Option<(&K, &mut V)> {
        self.inner.last_mut()
    }

    /// Returns the last entry in the index map, if it exists.
    ///
    /// If the index map is nonempty, this method returns `Some(entry)` where `entry` is the last
    /// entry in the index map. If the index map is empty, this method returns `None`.
    ///
    /// # Examples
    ///
    /// Getting the last entry of a non-empty index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (String::from("foo"),  1_usize),
    ///     (String::from("bar"),  2_usize),
    ///     (String::from("baz"),  3_usize),
    ///     (String::from("quux"), 4_usize),
    /// ]);
    /// let maybe_entry = proj_map.last_entry();
    ///
    /// assert!(maybe_entry.is_some());
    ///
    /// let entry = maybe_entry.unwrap();
    ///
    /// assert_eq!(entry.key(), "quux");
    /// assert_eq!(entry.index(), 3);
    /// assert_eq!(entry.get(), &4_usize);
    /// ```
    ///
    /// Getting the last entry from an empty index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map: TypedProjIndexMap<String, usize> = TypedProjIndexMap::new();
    /// let entry = proj_map.last_entry();
    ///
    /// assert!(entry.is_none());
    /// ```
    pub fn last_entry(&mut self) -> Option<IndexedEntry<'_, K, V, A>>
    where
        K: Ord,
    {
        self.inner.last_entry().map(IndexedEntry::new)
    }

    /// Swap removes an entry from the index map by storage index.
    ///
    /// This method behaves as follows:
    ///
    /// * If `index < self.len() - 1`, this method removes the entry at storage index `index`, and
    ///   swaps the last entry in `self` into the slot at `index`. This method removes and returns
    ///   `Some((key, value))`, where `key` is the key, and `value` is the value from the removed
    ///   entry.
    /// * If `index == self.len() - 1`, this method remove the entry at storage index `index`, and
    ///   returns `Some((key, value))`, where `key` is the key, and `value` is the value from the
    ///   removed entry.
    /// * If `index >= self.len()`, the index `index` is out of bounds, so the method returns
    ///   `None`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Specification Definitions
    ///
    /// The **last entry** in the map `map` when `map` is non-empty is defined by
    ///
    /// ```text
    /// last(map) := map[map.len() - 1].
    /// ```
    ///
    /// We say that two maps `map1` and `map2` are **equal** if and only if
    ///
    /// ```text
    /// map1 = map2 ⇔ (map1.len() = map2.len()) ∧ (∀ i ∈ [0, map1.len()). map1[i] = map2[i]).
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { index < map_before.len() - 1 }
    /// map.swap_remove_index(index)
    /// {
    ///     result = Some(map_before[index])
    ///     ∧ map_after.len() = map_before.len() - 1
    ///     ∧ (∀ i ∈ [0, index). map_after[i] = map_before[i])
    ///     ∧ map_after[index] = last(map_before))
    ///     ∧ (∀ i ∈ [index + 1, map_after.len()). map_after[i] = map_before[i])
    /// }
    ///
    /// { index = map_before.len() - 1 }
    /// map.swap_remove_index(index)
    /// {
    ///     result = Some(map_before[index])
    ///     ∧ map_after.len() = map_before.len() - 1
    ///     ∧ (∀ i ∈ [0, map_after.len()). map_after[i] = map_before[i])
    /// }
    ///
    /// { index ≥ map_before.len() }
    /// map.swap_remove_index(index)
    /// { result = None ∧ map_after = map_before }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (0_usize, ()),
    ///     (1_usize, ()),
    ///     (2_usize, ()),
    ///     (3_usize, ()),
    /// ]);
    /// let removed = proj_map.swap_remove_index(1);
    /// let expected = [(0_usize, ()), (3_usize, ()), (2_usize, ())];
    ///
    /// assert_eq!(removed, Some((1_usize, ())));
    /// assert_eq!(proj_map.as_slice(), expected.as_slice());
    /// ```
    pub fn swap_remove_index(&mut self, index: usize) -> Option<(K, V)> {
        self.inner.swap_remove_index(index)
    }

    /// Shift removes an entry from the index map by storage index.
    ///
    /// This method behaves as follows:
    ///
    /// * If `index < self.len() - 1`, this method removes the entry at storage index `index`, and
    ///   shifts each entry in `(index, self.len() - 1)` down one unit. This method removes and
    ///   returns `Some((key, value))`, where `key` is the key, and `value` is the value from the
    ///   removed entry.
    /// * If `index == self.len() - 1`, this method remove the entry at storage index `index`, and
    ///   returns `Some((key, value))`, where `key` is the key, and `value` is the value from the
    ///   removed entry.
    /// * If `index >= self.len()`, the index `index` is out of bounds, so the method returns
    ///   `None`.
    ///
    /// Note that when `self.len() == 1`, `self` is empty, so no shifting occurs.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Specification Definitions
    ///
    /// We say that two maps `map1` and `map2` are **equal** if and only if
    ///
    /// ```text
    /// map1 = map2 ⇔ (map1.len() = map2.len()) ∧ (∀ i ∈ [0, map1.len()). map1[i] = map2[i]).
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { index < map_before.len() - 1 }
    /// map.shift_remove_index(index)
    /// {
    ///     result = Some(map_before[index])
    ///     ∧ map_after.len() = map_before.len() - 1
    ///     ∧ (∀ i ∈ [0, index). map_after[i] = map_before[i])
    ///     ∧ (∀ i ∈ [index, map_after.len()). map_after[i] = map_before[i + 1])
    /// }
    ///
    /// { index = map_before.len() - 1 }
    /// map.shift_remove_index(index)
    /// {
    ///     result = Some(map_before[index])
    ///     ∧ map_after.len() = map_before.len() - 1
    ///     ∧ (∀ i ∈ [0, map_after.len()). map_after[i] = map_before[i])
    /// }
    ///
    /// { index ≥ map_before.len() }
    /// map.shift_remove_index(index)
    /// { result = None ∧ map_after = map_before }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     (0_usize, ()),
    ///     (1_usize, ()),
    ///     (2_usize, ()),
    ///     (3_usize, ()),
    /// ]);
    /// let removed = proj_map.shift_remove_index(1);
    /// let expected = [(0_usize, ()), (2_usize, ()), (3_usize, ())];
    ///
    /// assert_eq!(removed, Some((1_usize, ())));
    /// assert_eq!(proj_map.as_slice(), expected.as_slice());
    /// ```
    pub fn shift_remove_index(&mut self, index: usize) -> Option<(K, V)> {
        self.inner.shift_remove_index(index)
    }

    /// Moves the storage position of an entry from one index to another by shifting all other
    /// pairs in between.
    ///
    /// This method behaves as follows:
    ///
    /// * If `from < to`, the other pairs will shift up while the targeted pair moves down.
    /// * If `from > to`, the other pairs will shift down while the targeted pair moves up.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Specification Definitions
    ///
    /// We say that two maps `map1` and `map2` are **equal** if and only if
    ///
    /// ```text
    /// map1 = map2 ⇔ (map1.len() = map2.len()) ∧ (∀ i ∈ [0, map1.len()). map1[i] = map2[i]).
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { from < map_before.len() ∧ to < map_before.len() ∧ from < to }
    /// map.move_index(from, to)
    /// {
    ///     map_after.len() = map_before.len()
    ///     ∧ map_after[to] = map_before[from]
    ///     ∧ (∀ i ∈ [0, from). map_after[i] = map_before[i])
    ///     ∧ (∀ i ∈ [from, to). map_after[i] = map_before[i + 1])
    ///     ∧ (∀ i ∈ [to + 1, map_after.len()). map_after[i] = map_before[i])
    /// }
    ///
    /// { from < map_before.len() ∧ to < map_before.len() ∧ from > to }
    /// map.move_index(from, to)
    /// {
    ///     map_after.len() = map_before.len()
    ///     ∧ map_after[to] = map_before[from]
    ///     ∧ (∀ i ∈ [0, to). map_after[i] = map_before[i])
    ///     ∧ (∀ i ∈ [to, from). map_after[i + 1] = map_before[i])
    ///     ∧ (∀ i ∈ [from + 1, map_after.len()). map_after[i] = map_before[i])
    /// }
    ///
    /// { from < map_before.len() ∧ to < map_before.len() ∧ from = to }
    /// map.move_index(from, to)
    /// { map_after = map_before }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if `from` or `to` are out of bounds.
    ///
    /// # Examples
    ///
    /// Moving an index where `from < to`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",    0_usize),
    ///     ("bar",    1_usize),
    ///     ("baz",    2_usize),
    ///     ("quux",   3_usize),
    /// ]);
    /// proj_map.move_index(0, 3);
    /// let expected = [("bar", 1_usize), ("baz", 2_usize), ("quux", 3_usize), ("foo", 0_usize)];
    ///
    /// assert_eq!(proj_map.as_slice(), expected.as_slice());
    /// ```
    ///
    /// Moving an index where `from > to`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",    0_usize),
    ///     ("bar",    1_usize),
    ///     ("baz",    2_usize),
    ///     ("quux",   3_usize),
    /// ]);
    /// proj_map.move_index(3, 0);
    /// let expected = [("quux", 3_usize), ("foo", 0_usize), ("bar", 1_usize), ("baz", 2_usize)];
    ///
    /// assert_eq!(proj_map.as_slice(), expected.as_slice());
    /// ```
    #[track_caller]
    pub fn move_index(&mut self, from: usize, to: usize) {
        self.inner.move_index(from, to);
    }

    /// Swaps the position of two entries in the index map.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { a < map_before.len() ∧ b < map_before.len() }
    /// map.swap_indices(a, b)
    /// {
    ///     map_after.len() = map_before.len()
    ///     ∧ map_after[a] = map_before[b]
    ///     ∧ map_after[b] = map_before[a]
    ///     ∧ (∀ i ∈ [0, map_after.len()). i ∉ {a, b} ⇒ map_after[i] = map_before[i])
    /// }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if either `a` is out of bounds, or `b` is out of bounds.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::TypedProjIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut proj_map = TypedProjIndexMap::from([
    ///     ("foo",    0_usize),
    ///     ("bar",    1_usize),
    ///     ("baz",    2_usize),
    ///     ("quux",   3_usize),
    /// ]);
    /// proj_map.swap_indices(0, 3);
    /// let expected = [("quux", 3_usize), ("bar", 1_usize), ("baz", 2_usize), ("foo", 0_usize)];
    ///
    /// assert_eq!(proj_map.as_slice(), expected.as_slice());
    /// ```
    #[track_caller]
    pub fn swap_indices(&mut self, a: usize, b: usize) {
        self.inner.swap_indices(a, b)
    }
}

impl<Q, K, V, S, A> ops::Index<&Q> for TypedProjIndexMap<K, V, S, A>
where
    Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    K: any::Any,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    type Output = V;

    fn index(&self, key: &Q) -> &Self::Output {
        self.get(key).expect("Entry not found for key")
    }
}


impl<Q, K, V, S, A> ops::IndexMut<&Q> for TypedProjIndexMap<K, V, S, A>
where
    Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    K: any::Any,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    fn index_mut(&mut self, key: &Q) -> &mut Self::Output {
        self.get_mut(key).expect("Entry not found for key")
    }
}

impl<K, V, S, A> ops::Index<usize> for TypedProjIndexMap<K, V, S, A>
where
    K: any::Any,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    type Output = V;

    fn index(&self, index: usize) -> &Self::Output {
        self.get_index(index)
            .unwrap_or_else(|| {
                panic!(
                    "index out of bounds: the len is `{len}` but the index is `{index}`",
                    len = self.len()
                );
            })
            .1
    }
}

impl<K, V, S, A> ops::IndexMut<usize> for TypedProjIndexMap<K, V, S, A>
where
    K: any::Any,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    fn index_mut(&mut self, index: usize) -> &mut Self::Output {
        let len: usize = self.len();

        self.get_index_mut(index)
            .unwrap_or_else(|| {
                panic!("index out of bounds: the len is `{len}` but the index is `{index}`");
            })
            .1
    }
}

macro_rules! impl_index_for_index_map {
    ($($range:ty),*) => {$(
        impl<K, V, S, A> ops::Index<$range> for TypedProjIndexMap<K, V, S, A>
        where
            K: any::Any,
            V: any::Any,
            S: any::Any + hash::BuildHasher + Send + Sync,
            S::Hasher: any::Any + hash::Hasher + Send + Sync,
            A: any::Any + alloc::Allocator + Send + Sync,
        {
            type Output = Slice<K, V>;

            fn index(&self, range: $range) -> &Self::Output {
                Slice::from_slice(self.inner.as_slice().index(range))
            }
        }

        impl<K, V, S, A> ops::IndexMut<$range> for TypedProjIndexMap<K, V, S, A>
        where
            K: any::Any,
            V: any::Any,
            S: any::Any + hash::BuildHasher + Send + Sync,
            S::Hasher: any::Any + hash::Hasher + Send + Sync,
            A: any::Any + alloc::Allocator + Send + Sync,
        {
            fn index_mut(&mut self, range: $range) -> &mut Self::Output {
                Slice::from_slice_mut(self.inner.as_mut_slice().index_mut(range))
            }
        }
    )*}
}

impl_index_for_index_map!(
    ops::Range<usize>,
    ops::RangeFrom<usize>,
    ops::RangeFull,
    ops::RangeInclusive<usize>,
    ops::RangeTo<usize>,
    ops::RangeToInclusive<usize>,
    (ops::Bound<usize>, ops::Bound<usize>)
);

impl<K, V, S, A> fmt::Debug for TypedProjIndexMap<K, V, S, A>
where
    K: any::Any + fmt::Debug,
    V: any::Any + fmt::Debug,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
        formatter.debug_map().entries(self.iter()).finish()
    }
}

impl<K, V, S, A> Clone for TypedProjIndexMap<K, V, S, A>
where
    K: any::Any + Clone,
    V: any::Any + Clone,
    S: any::Any + hash::BuildHasher + Send + Sync + Clone,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync + Clone,
{
    fn clone(&self) -> Self {
        let cloned_inner = Clone::clone(&self.inner);

        Self {
            inner: cloned_inner,
        }
    }

    fn clone_from(&mut self, other: &Self) {
        Clone::clone_from(&mut self.inner, &other.inner);
    }
}

impl<K, V, S, A> Extend<(K, V)> for TypedProjIndexMap<K, V, S, A>
where
    K: any::Any + hash::Hash + Eq,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    fn extend<I>(&mut self, iterable: I)
    where
        I: IntoIterator<Item = (K, V)>,
    {
        self.inner.extend(iterable);
    }
}

impl<'a, K, V, S, A> Extend<(&'a K, &'a V)> for TypedProjIndexMap<K, V, S, A>
where
    K: any::Any + hash::Hash + Eq + Copy,
    V: any::Any + Copy,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    fn extend<I>(&mut self, iterable: I)
    where
        I: IntoIterator<Item = (&'a K, &'a V)>,
    {
        self.inner.extend(iterable);
    }
}

impl<K, V, S> FromIterator<(K, V)> for TypedProjIndexMap<K, V, S, alloc::Global>
where
    K: any::Any + hash::Hash + Eq,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync + Default,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
{
    fn from_iter<I: IntoIterator<Item = (K, V)>>(iterable: I) -> Self {
        let iterator = iterable.into_iter();
        let (low, _) = iterator.size_hint();
        let mut map = Self::with_capacity_and_hasher_in(low, S::default(), alloc::Global::default());
        map.extend(iterator);

        map
    }
}

impl<K, V, const N: usize> From<[(K, V); N]> for TypedProjIndexMap<K, V, hash::RandomState, alloc::Global>
where
    K: any::Any + hash::Hash + Eq,
    V: any::Any,
{
    fn from(array: [(K, V); N]) -> Self {
        Self::from_iter(array)
    }
}

impl<K, V, S, A> Default for TypedProjIndexMap<K, V, S, A>
where
    K: any::Any,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync + Default,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync + Default,
{
    fn default() -> Self {
        Self { inner: TypedProjIndexMapInner::default(), }
    }
}

impl<K, V1, S1, V2, S2, A1, A2> PartialEq<TypedProjIndexMap<K, V2, S2, A2>> for TypedProjIndexMap<K, V1, S1, A1>
where
    K: any::Any + hash::Hash + Eq,
    V1: any::Any + PartialEq<V2>,
    V2: any::Any,
    S1: any::Any + hash::BuildHasher + Send + Sync,
    S1::Hasher: any::Any + hash::Hasher + Send + Sync,
    S2: any::Any + hash::BuildHasher + Send + Sync,
    S2::Hasher: any::Any + hash::Hasher + Send + Sync,
    A1: any::Any + alloc::Allocator + Send + Sync,
    A2: any::Any + alloc::Allocator + Send + Sync,
{
    fn eq(&self, other: &TypedProjIndexMap<K, V2, S2, A2>) -> bool {
        if self.len() != other.len() {
            return false;
        }

        self.iter()
            .all(|(key, value)| other.get(key).map_or(false, |v| *value == *v))
    }
}

impl<K, V, S, A> Eq for TypedProjIndexMap<K, V, S, A>
where
    K: any::Any + Eq + hash::Hash,
    V: any::Any + Eq,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
}

impl<'a, K, V, S, A> IntoIterator for &'a TypedProjIndexMap<K, V, S, A>
where
    K: any::Any,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    type Item = (&'a K, &'a V);
    type IntoIter = Iter<'a, K, V>;

    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}

impl<'a, K, V, S, A> IntoIterator for &'a mut TypedProjIndexMap<K, V, S, A>
where
    K: any::Any,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    type Item = (&'a K, &'a mut V);
    type IntoIter = IterMut<'a, K, V>;

    fn into_iter(self) -> Self::IntoIter {
        self.iter_mut()
    }
}

impl<K, V, S, A> IntoIterator for TypedProjIndexMap<K, V, S, A>
where
    K: any::Any,
    V: any::Any,
    S: any::Any + hash::BuildHasher + Send + Sync,
    S::Hasher: any::Any + hash::Hasher + Send + Sync,
    A: any::Any + alloc::Allocator + Send + Sync,
{
    type Item = (K, V);
    type IntoIter = IntoIter<K, V, A>;

    fn into_iter(self) -> Self::IntoIter {
        IntoIter::new(map_inner::IntoIter::new(self.inner.into_entries()))
    }
}

/// A type-erased hash map where the order of the entries inside the map is independent of the
/// hash values of the keys.
///
/// The interface to this hash map tracks closely with the standard library's [`HashMap`] interface.
/// One feature this hash map has that the standard library one does not is that it is generic over
/// the choice of memory allocator. This type supports type-erasure of generic parameters. The main
/// difference is that a `TypedProjIndexMap` can be converted to an `OpaqueIndexMap` in constant
/// **O(1)** time, hiding its key type, value type, hash builder type, and allocator type, at
/// runtime.
///
/// # Ordering
///
/// The key-value pairs are stored in the map in their insertion order, rather than by their
/// hash value, provided no removal method have been called on an entry in the map. In particular,
/// inserting a new value into the map does not change the **storage order** of the other elements
/// in the map.
///
/// # Indices
///
/// The key-value pairs are stored in a packed range with no holes in the range `[0, self.len())`.
/// Thus, one can always use the [`get_index_of`] or [`get_index`] methods to interact with
/// key-value pairs inside the map by their storage index instead of their key.
///
/// # Type Erasure And Type Projection
///
/// This allows for more flexible and dynamic data handling, especially when working with
/// collections of unknown or dynamic types. Type-erasable collections allow for more efficient
/// runtime dynamic typing, since one has more control over the memory layout of the collection,
/// even for erased types. Some applications of this include implementing heterogeneous data
/// structures, plugin systems, and managing foreign function interface data. There are two data
/// types that are dual to each other: [`TypedProjIndexMap`] and [`OpaqueIndexMap`].
///
/// By laying out both data types identically, we can project the underlying types in **O(1)** time,
/// and erase the underlying types in **O(1)** time, though the conversion is often zero-cost.
///
/// # See Also
///
/// - [`TypedProjIndexMap`]: the type-projected counterpart to [`OpaqueIndexMap`].
///
/// # Examples
///
/// Basic usage of a type-erased index map.
///
/// ```
/// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
/// # use opaque_index_map::OpaqueIndexMap;
/// # use std::hash::RandomState;
/// #
/// # #[cfg(feature = "nightly")]
/// # use std::alloc::Global;
/// #
/// # #[cfg(not(feature = "nightly"))]
/// # use opaque_allocator_api::alloc::Global;
/// #
/// let mut party: OpaqueIndexMap = OpaqueIndexMap::from([
///     (String::from("cloud"),     String::from("protagonist")),
///     (String::from("tifa"),      String::from("fighter")),
///     (String::from("aerith"),    String::from("mage")),
///     (String::from("barret"),    String::from("gunner")),
///     (String::from("cid"),       String::from("pilot")),
///     (String::from("vincent"),   String::from("mysterious brooding sable-clad kind of guy")),
///     (String::from("yuffie"),    String::from("ninja")),
///     (String::from("red xiii"),  String::from("scientist")),
///     (String::from("cait sith"), String::from("fortune teller")),
/// ]);
///
/// assert!(party.has_key_type::<String>());
/// assert!(party.has_value_type::<String>());
/// assert!(party.has_build_hasher_type::<RandomState>());
/// assert!(party.has_allocator_type::<Global>());
///
/// assert_eq!(party.get::<_, String, String, RandomState, Global>("cloud"),     Some(&String::from("protagonist")));
/// assert_eq!(party.get::<_, String, String, RandomState, Global>("tifa"),      Some(&String::from("fighter")));
/// assert_eq!(party.get::<_, String, String, RandomState, Global>("aerith"),    Some(&String::from("mage")));
/// assert_eq!(party.get::<_, String, String, RandomState, Global>("barret"),    Some(&String::from("gunner")));
/// assert_eq!(party.get::<_, String, String, RandomState, Global>("cid"),       Some(&String::from("pilot")));
/// assert_eq!(party.get::<_, String, String, RandomState, Global>("vincent"),   Some(&String::from("mysterious brooding sable-clad kind of guy")));
/// assert_eq!(party.get::<_, String, String, RandomState, Global>("yuffie"),    Some(&String::from("ninja")));
/// assert_eq!(party.get::<_, String, String, RandomState, Global>("red xiii"),  Some(&String::from("scientist")));
/// assert_eq!(party.get::<_ ,String, String, RandomState, Global>("cait sith"), Some(&String::from("fortune teller")));
///
/// assert!(!party.contains_key::<_, String, String, RandomState, Global>("sephiroth"));
/// assert!(!party.contains_key::<_, String, String, RandomState, Global>("jenova"));
/// assert!(!party.contains_key::<_, String, String, RandomState, Global>("emerald weapon"));
///
/// // Elements of an index map` are stored in their insertion order, independent of their keys.
/// assert_eq!(party.get_index_of::<_, String, String, RandomState, Global>("cloud"),     Some(0));
/// assert_eq!(party.get_index_of::<_, String, String, RandomState, Global>("tifa"),      Some(1));
/// assert_eq!(party.get_index_of::<_, String, String, RandomState, Global>("aerith"),    Some(2));
/// assert_eq!(party.get_index_of::<_, String, String, RandomState, Global>("barret"),    Some(3));
/// assert_eq!(party.get_index_of::<_, String, String, RandomState, Global>("cid"),       Some(4));
/// assert_eq!(party.get_index_of::<_, String, String, RandomState, Global>("vincent"),   Some(5));
/// assert_eq!(party.get_index_of::<_, String, String, RandomState, Global>("yuffie"),    Some(6));
/// assert_eq!(party.get_index_of::<_, String, String, RandomState, Global>("red xiii"),  Some(7));
/// assert_eq!(party.get_index_of::<_, String, String, RandomState, Global>("cait sith"), Some(8));
///
/// assert_eq!(party.get_index_of::<_, String, String, RandomState, Global>("sephiroth"),      None);
/// assert_eq!(party.get_index_of::<_, String, String, RandomState, Global>("jenova"),         None);
/// assert_eq!(party.get_index_of::<_, String, String, RandomState, Global>("emerald weapon"), None);
///
/// party.insert::<String, String, RandomState, Global>(String::from("sephiroth"), String::from("one-winged angel"));
///
/// assert!(party.contains_key::<_, String, String, RandomState, Global>("sephiroth"));
///
/// // Elements of an index map are stored in their insertion order, independent of their keys.
/// assert_eq!(party.get_index_of::<_, String, String, RandomState, Global>("cloud"),     Some(0));
/// assert_eq!(party.get_index_of::<_, String, String, RandomState, Global>("tifa"),      Some(1));
/// assert_eq!(party.get_index_of::<_, String, String, RandomState, Global>("aerith"),    Some(2));
/// assert_eq!(party.get_index_of::<_, String, String, RandomState, Global>("barret"),    Some(3));
/// assert_eq!(party.get_index_of::<_, String, String, RandomState, Global>("cid"),       Some(4));
/// assert_eq!(party.get_index_of::<_, String, String, RandomState, Global>("vincent"),   Some(5));
/// assert_eq!(party.get_index_of::<_, String, String, RandomState, Global>("yuffie"),    Some(6));
/// assert_eq!(party.get_index_of::<_, String, String, RandomState, Global>("red xiii"),  Some(7));
/// assert_eq!(party.get_index_of::<_, String, String, RandomState, Global>("cait sith"), Some(8));
/// assert_eq!(party.get_index_of::<_, String, String, RandomState, Global>("sephiroth"), Some(9));
///
/// assert_eq!(party.get::<_, String, String, RandomState, Global>("sephiroth"), Some(&String::from("one-winged angel")));
/// {
///     let value = party.get_mut::<_, String, String, RandomState, Global>("sephiroth").unwrap();
///     *value = String::from("nevermind");
/// }
/// assert_eq!(party.get::<_, String, String, RandomState, Global>("sephiroth"), Some(&String::from("nevermind")));
///
/// party.shift_remove::<_, String, String, RandomState, Global>("sephiroth");
///
/// assert!(!party.contains_key::<_, String, String, RandomState, Global>("sephiroth"));
/// ```
#[repr(transparent)]
pub struct OpaqueIndexMap {
    inner: OpaqueIndexMapInner,
}

impl OpaqueIndexMap {
    /// Returns the [`TypeId`] of the keys contained in the type-erased index map.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::new::<usize, isize>();
    ///
    /// assert_eq!(opaque_map.key_type_id(), TypeId::of::<usize>());
    /// ```
    #[inline]
    pub const fn key_type_id(&self) -> any::TypeId {
        self.inner.key_type_id()
    }

    /// Returns the [`TypeId`] of the values contained in the type-erased index map.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::new::<usize, isize>();
    ///
    /// assert_eq!(opaque_map.value_type_id(), TypeId::of::<isize>());
    /// ```
    #[inline]
    pub const fn value_type_id(&self) -> any::TypeId {
        self.inner.value_type_id()
    }

    /// Returns the [`TypeId`] of the hash builder for the type-erased index map.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::new::<usize, isize>();
    ///
    /// assert_eq!(opaque_map.build_hasher_type_id(), TypeId::of::<RandomState>());
    /// ```
    #[inline]
    pub const fn build_hasher_type_id(&self) -> any::TypeId {
        self.inner.build_hasher_type_id()
    }

    /// Returns the [`TypeId`] of the memory allocator for the type-erased index map.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::new::<usize, isize>();
    ///
    /// assert_eq!(opaque_map.allocator_type_id(), TypeId::of::<Global>());
    /// ```
    #[inline]
    pub const fn allocator_type_id(&self) -> any::TypeId {
        self.inner.allocator_type_id()
    }
}

impl OpaqueIndexMap {
    /// Determines whether the type-erased index map has the given key type.
    ///
    /// Returns `true` if `self` has the specified key type. Returns `false` otherwise.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::new::<usize, isize>();
    ///
    /// assert!(opaque_map.has_key_type::<usize>());
    /// ```
    #[inline]
    pub fn has_key_type<K>(&self) -> bool
    where
        K: any::Any,
    {
        self.inner.key_type_id() == any::TypeId::of::<K>()
    }

    /// Determines whether the type-erased index map has the given value type.
    ///
    /// Returns `true` if `self` has the specified value type. Returns `false` otherwise.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::new::<usize, isize>();
    ///
    /// assert!(opaque_map.has_value_type::<isize>());
    /// ```
    #[inline]
    pub fn has_value_type<V>(&self) -> bool
    where
        V: any::Any,
    {
        self.inner.value_type_id() == any::TypeId::of::<V>()
    }

    /// Determines whether the type-erased index map has the given hash builder type.
    ///
    /// Returns `true` if `self` has the specified hash builder type. Returns `false` otherwise.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::new::<usize, isize>();
    ///
    /// assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// ```
    #[inline]
    pub fn has_build_hasher_type<S>(&self) -> bool
    where
        S: any::Any,
    {
        self.inner.build_hasher_type_id() == any::TypeId::of::<S>()
    }

    /// Determines whether the type-erased index map has the given memory allocator type.
    ///
    /// Returns `true` if `self` has the specified memory allocator type. Returns `false` otherwise.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::new::<usize, isize>();
    ///
    /// assert!(opaque_map.has_allocator_type::<Global>());
    /// ```
    #[inline]
    pub fn has_allocator_type<A>(&self) -> bool
    where
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        self.inner.allocator_type_id() == any::TypeId::of::<A>()
    }

    /// Assert the concrete types underlying a type-erased data type.
    ///
    /// This method's main use case is ensuring the type safety of an operation before projecting
    /// into the type-projected counterpart of the type-erased index map.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    #[inline]
    #[track_caller]
    fn assert_type_safety<K, V, S, A>(&self)
    where
        K: any::Any,
        V: any::Any,
        S: any::Any,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        #[cold]
        #[cfg_attr(feature = "nightly", optimize(size))]
        #[track_caller]
        fn type_check_failed(st: &str, type_id_self: any::TypeId, type_id_other: any::TypeId) -> ! {
            panic!("{:?} type mismatch. Need `{:?}`, got `{:?}`", st, type_id_self, type_id_other);
        }

        if !self.has_key_type::<K>() {
            type_check_failed("Key", self.inner.key_type_id(), any::TypeId::of::<K>());
        }

        if !self.has_value_type::<V>() {
            type_check_failed("Value", self.inner.value_type_id(), any::TypeId::of::<V>());
        }

        if !self.has_build_hasher_type::<S>() {
            type_check_failed("BuildHasher", self.inner.build_hasher_type_id(), any::TypeId::of::<S>());
        }

        if !self.has_allocator_type::<A>() {
            type_check_failed("Allocator", self.inner.allocator_type_id(), any::TypeId::of::<A>());
        }
    }
}

impl OpaqueIndexMap {
    /// Projects the type-erased index map reference into a type-projected index map reference.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::{OpaqueIndexMap, TypedProjIndexMap};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::with_hasher_in::<usize, f64, RandomState, Global>(
    ///     RandomState::new(),
    ///     Global
    /// );
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let proj_map: &TypedProjIndexMap<usize, f64, RandomState, Global> = opaque_map.as_proj::<usize, f64, RandomState, Global>();
    /// ```
    #[inline]
    #[track_caller]
    pub fn as_proj<K, V, S, A>(&self) -> &TypedProjIndexMap<K, V, S, A>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        self.assert_type_safety::<K, V, S, A>();

        unsafe { &*(self as *const OpaqueIndexMap as *const TypedProjIndexMap<K, V, S, A>) }
    }

    /// Projects the mutable type-erased index map reference into a mutable type-projected
    /// index map reference.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::{OpaqueIndexMap, TypedProjIndexMap};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::with_hasher_in::<usize, f64, RandomState, Global>(
    ///     RandomState::new(),
    ///     Global
    /// );
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let proj_map: &mut TypedProjIndexMap<usize, f64, RandomState, Global> = opaque_map.as_proj_mut::<usize, f64, RandomState, Global>();
    /// ```
    #[inline]
    #[track_caller]
    pub fn as_proj_mut<K, V, S, A>(&mut self) -> &mut TypedProjIndexMap<K, V, S, A>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        self.assert_type_safety::<K, V, S, A>();

        unsafe { &mut *(self as *mut OpaqueIndexMap as *mut TypedProjIndexMap<K, V, S, A>) }
    }

    /// Projects the type-erased index map value into a type-projected index map value.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::{OpaqueIndexMap, TypedProjIndexMap};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::with_hasher_in::<usize, f64, RandomState, Global>(
    ///     RandomState::new(),
    ///     Global
    /// );
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let proj_map: TypedProjIndexMap<usize, f64, RandomState, Global> = opaque_map.into_proj::<usize, f64, RandomState, Global>();
    /// ```
    #[inline]
    #[track_caller]
    pub fn into_proj<K, V, S, A>(self) -> TypedProjIndexMap<K, V, S, A>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        self.assert_type_safety::<K, V, S, A>();

        TypedProjIndexMap {
            inner: self.inner.into_proj::<K, V, S, A>(),
        }
    }

    /// Erases the type-projected index map value into a type-erased index map value.
    ///
    /// Unlike the type projection methods [`as_proj`], [`as_proj_mut`], and [`into_proj`], this
    /// method never panics.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::{OpaqueIndexMap, TypedProjIndexMap};
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_map: TypedProjIndexMap<usize, f64, RandomState, Global> = TypedProjIndexMap::with_hasher_in(
    ///     RandomState::new(),
    ///     Global
    /// );
    /// let opaque_map: OpaqueIndexMap = OpaqueIndexMap::from_proj(proj_map);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// ```
    ///
    /// [`as_proj`]: OpaqueIndexMap::as_proj,
    /// [`as_proj_mut`]: OpaqueIndexMap::as_proj_mut
    /// [`into_proj`]: OpaqueIndexMap::into_proj
    #[inline]
    pub fn from_proj<K, V, S, A>(proj_self: TypedProjIndexMap<K, V, S, A>) -> Self
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        Self {
            inner: OpaqueIndexMapInner::from_proj(proj_self.inner),
        }
    }
}

impl OpaqueIndexMap {
    /// Constructs a new index map with the given type-projected hash builder and type-projected
    /// memory allocator.
    ///
    /// This method **does not** allocate memory. In particular, the index map has zero capacity
    /// and will not allocate memory until key-value pairs are inserted into it. The index map will
    /// have length zero until elements are inserted into it.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_alloc = TypedProjAlloc::new(Global);
    /// let proj_build_hasher = TypedProjBuildHasher::new(RandomState::new());
    /// let opaque_map = OpaqueIndexMap::with_hasher_proj_in::<usize, f64, RandomState, Global>(
    ///     proj_build_hasher,
    ///     proj_alloc
    /// );
    ///
    /// assert!(opaque_map.has_key_type::<usize>());
    /// assert!(opaque_map.has_value_type::<f64>());
    /// assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// assert!(opaque_map.has_allocator_type::<Global>());
    ///
    /// assert!(opaque_map.is_empty());
    /// assert_eq!(opaque_map.capacity(), 0);
    /// ```
    #[inline]
    pub fn with_hasher_proj_in<K, V, S, A>(proj_build_hasher: TypedProjBuildHasher<S>, proj_alloc: TypedProjAlloc<A>) -> Self
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_index_map = TypedProjIndexMap::<K, V, S, A>::with_hasher_proj_in(proj_build_hasher, proj_alloc);

        Self::from_proj(proj_index_map)
    }

    /// Constructs a new index map with the given capacity, type-projected hash builder, and type-projected
    /// memory allocator.
    ///
    /// This method **does** allocate memory if the capacity `capacity` is non-zero. In particular,
    /// the index map has capacity at least `capacity`, and will allocate enough memory to store at
    /// least `capacity` keys and values. The index map will have length zero until elements are
    /// inserted into it.
    ///
    /// # Examples
    ///
    /// Creating a type-erased index map with capacity `capacity > 0`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let capacity = 10;
    /// let proj_alloc = TypedProjAlloc::new(Global);
    /// let proj_build_hasher = TypedProjBuildHasher::new(RandomState::new());
    /// let opaque_map = OpaqueIndexMap::with_capacity_and_hasher_proj_in::<usize, f64, RandomState, Global>(
    ///     capacity,
    ///     proj_build_hasher,
    ///     proj_alloc
    /// );
    ///
    /// assert!(opaque_map.has_key_type::<usize>());
    /// assert!(opaque_map.has_value_type::<f64>());
    /// assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// assert!(opaque_map.has_allocator_type::<Global>());
    ///
    /// assert!(opaque_map.is_empty());
    /// assert!(opaque_map.capacity() >= capacity);
    /// ```
    ///
    /// Creating a type-erased index map with capacity `capacity == 0`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_alloc = TypedProjAlloc::new(Global);
    /// let proj_build_hasher = TypedProjBuildHasher::new(RandomState::new());
    /// let opaque_map = OpaqueIndexMap::with_capacity_and_hasher_proj_in::<usize, f64, RandomState, Global>(
    ///     0,
    ///     proj_build_hasher,
    ///     proj_alloc
    /// );
    ///
    /// assert!(opaque_map.has_key_type::<usize>());
    /// assert!(opaque_map.has_value_type::<f64>());
    /// assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// assert!(opaque_map.has_allocator_type::<Global>());
    ///
    /// assert!(opaque_map.is_empty());
    /// assert_eq!(opaque_map.capacity(), 0);
    /// ```
    #[inline]
    pub fn with_capacity_and_hasher_proj_in<K, V, S, A>(capacity: usize, proj_build_hasher: TypedProjBuildHasher<S>, proj_alloc: TypedProjAlloc<A>) -> Self
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_index_map = TypedProjIndexMap::<K, V, S, A>::with_capacity_and_hasher_proj_in(capacity, proj_build_hasher, proj_alloc);

        Self::from_proj(proj_index_map)
    }
}

#[cfg(feature = "std")]
impl OpaqueIndexMap {
    /// Constructs a new index map with the given type-projected memory allocator.
    ///
    /// This method **does not** allocate memory. In particular, the index map has zero capacity and
    /// will not allocate memory until key-value pairs are inserted into it. The index map will have
    /// length zero until elements are inserted into it.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_alloc = TypedProjAlloc::new(Global);
    /// let opaque_map = OpaqueIndexMap::new_proj_in::<usize, f64, Global>(proj_alloc);
    ///
    /// assert!(opaque_map.has_key_type::<usize>());
    /// assert!(opaque_map.has_value_type::<f64>());
    /// assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// assert!(opaque_map.has_allocator_type::<Global>());
    ///
    /// assert!(opaque_map.is_empty());
    /// assert_eq!(opaque_map.capacity(), 0);
    /// ```
    #[inline]
    pub fn new_proj_in<K, V, A>(proj_alloc: TypedProjAlloc<A>) -> Self
    where
        K: any::Any,
        V: any::Any,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_index_map = TypedProjIndexMap::<K, V, hash::RandomState, A>::new_proj_in(proj_alloc);

        Self::from_proj(proj_index_map)
    }

    /// Constructs a new index map with the given capacity and type-projected memory allocator.
    ///
    /// This method **does** allocate memory if the capacity `capacity` is non-zero. In particular,
    /// the index map has capacity at least `capacity`, and will allocate enough memory to store at
    /// least `capacity` keys and values. The index map will have length zero until elements are
    /// inserted into it.
    ///
    /// # Examples
    ///
    /// Creating a type-erased index map with capacity `capacity > 0`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let capacity = 10;
    /// let proj_alloc = TypedProjAlloc::new(Global);
    /// let opaque_map = OpaqueIndexMap::with_capacity_proj_in::<usize, f64, Global>(
    ///     capacity,
    ///     proj_alloc
    /// );
    ///
    /// assert!(opaque_map.has_key_type::<usize>());
    /// assert!(opaque_map.has_value_type::<f64>());
    /// assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// assert!(opaque_map.has_allocator_type::<Global>());
    ///
    /// assert!(opaque_map.is_empty());
    /// assert!(opaque_map.capacity() >= capacity);
    /// ```
    ///
    /// Creating a type-erased index map with capacity `capacity == 0`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let proj_alloc = TypedProjAlloc::new(Global);
    /// let opaque_map = OpaqueIndexMap::with_capacity_proj_in::<usize, f64, Global>(
    ///     0,
    ///     proj_alloc
    /// );
    ///
    /// assert!(opaque_map.has_key_type::<usize>());
    /// assert!(opaque_map.has_value_type::<f64>());
    /// assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// assert!(opaque_map.has_allocator_type::<Global>());
    ///
    /// assert!(opaque_map.is_empty());
    /// assert_eq!(opaque_map.capacity(), 0);
    /// ```
    #[inline]
    pub fn with_capacity_proj_in<K, V, A>(capacity: usize, proj_alloc: TypedProjAlloc<A>) -> Self
    where
        K: any::Any,
        V: any::Any,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_index_map = TypedProjIndexMap::<K, V, hash::RandomState, A>::with_capacity_proj_in(capacity, proj_alloc);

        Self::from_proj(proj_index_map)
    }
}

impl OpaqueIndexMap {
    /// Constructs a new index map with the given hash builder and memory allocator.
    ///
    /// This method **does not** allocate memory. In particular, the index map has zero capacity and
    /// will not allocate memory until key-value pairs are inserted into it. The index map will have
    /// length zero until elements are inserted into it.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::with_hasher_in::<usize, f64, RandomState, Global>(
    ///     RandomState::new(),
    ///     Global
    /// );
    ///
    /// assert!(opaque_map.has_key_type::<usize>());
    /// assert!(opaque_map.has_value_type::<f64>());
    /// assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// assert!(opaque_map.has_allocator_type::<Global>());
    ///
    /// assert!(opaque_map.is_empty());
    /// assert_eq!(opaque_map.capacity(), 0);
    /// ```
    #[inline]
    pub fn with_hasher_in<K, V, S, A>(build_hasher: S, alloc: A) -> Self
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_index_map = TypedProjIndexMap::<K, V, S, A>::with_hasher_in(build_hasher, alloc);

        Self::from_proj(proj_index_map)
    }

    /// Constructs a new index map with the given capacity, hash builder, and memory allocator.
    ///
    /// This method **does** allocate memory if the capacity `capacity` is non-zero. In particular,
    /// the index map has capacity at least `capacity`, and will allocate enough memory to store at
    /// least `capacity` keys and values. The index map will have length zero until elements are
    /// inserted into it.
    ///
    /// # Examples
    ///
    /// Creating a type-erased index map with capacity `capacity > 0`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let capacity = 10;
    /// let opaque_map = OpaqueIndexMap::with_capacity_and_hasher_in::<usize, f64, RandomState, Global>(
    ///     capacity,
    ///     RandomState::new(),
    ///     Global
    /// );
    ///
    /// assert!(opaque_map.has_key_type::<usize>());
    /// assert!(opaque_map.has_value_type::<f64>());
    /// assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// assert!(opaque_map.has_allocator_type::<Global>());
    ///
    /// assert!(opaque_map.is_empty());
    /// assert!(opaque_map.capacity() >= capacity);
    /// ```
    ///
    /// Creating a type-erased index map with capacity `capacity == 0`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::with_capacity_and_hasher_in::<usize, f64, RandomState, Global>(
    ///     0,
    ///     RandomState::new(),
    ///     Global
    /// );
    ///
    /// assert!(opaque_map.has_key_type::<usize>());
    /// assert!(opaque_map.has_value_type::<f64>());
    /// assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// assert!(opaque_map.has_allocator_type::<Global>());
    ///
    /// assert!(opaque_map.is_empty());
    /// assert_eq!(opaque_map.capacity(), 0);
    /// ```
    #[inline]
    pub fn with_capacity_and_hasher_in<K, V, S, A>(capacity: usize, build_hasher: S, alloc: A) -> Self
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_index_map = TypedProjIndexMap::<K, V, S, A>::with_capacity_and_hasher_in(capacity, build_hasher, alloc);

        Self::from_proj(proj_index_map)
    }
}

#[cfg(feature = "std")]
impl OpaqueIndexMap {
    /// Constructs a new index map with the given memory allocator.
    ///
    /// This method **does not** allocate memory. In particular, the index map has zero capacity and
    /// will not allocate memory until key-value pairs are inserted into it. The index map will have
    /// length zero until elements are inserted into it.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::new_in::<usize, f64, Global>(Global);
    ///
    /// assert!(opaque_map.has_key_type::<usize>());
    /// assert!(opaque_map.has_value_type::<f64>());
    /// assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// assert!(opaque_map.has_allocator_type::<Global>());
    ///
    /// assert!(opaque_map.is_empty());
    /// assert_eq!(opaque_map.capacity(), 0);
    /// ```
    #[inline]
    pub fn new_in<K, V, A>(alloc: A) -> Self
    where
        K: any::Any,
        V: any::Any,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_index_map = TypedProjIndexMap::<K, V, _, A>::new_in(alloc);

        Self::from_proj(proj_index_map)
    }

    /// Constructs a new index map with the given capacity and memory allocator.
    ///
    /// This method **does** allocate memory if the capacity `capacity` is non-zero. In particular,
    /// the index map has capacity at least `capacity`, and will allocate enough memory to store at
    /// least `capacity` keys and values. The index map will have length zero until elements are
    /// inserted into it.
    ///
    /// # Examples
    ///
    /// Creating a type-erased index map with capacity `capacity > 0`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let capacity = 10;
    /// let opaque_map = OpaqueIndexMap::with_capacity_in::<usize, f64, Global>(
    ///     capacity,
    ///     Global
    /// );
    ///
    /// assert!(opaque_map.has_key_type::<usize>());
    /// assert!(opaque_map.has_value_type::<f64>());
    /// assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// assert!(opaque_map.has_allocator_type::<Global>());
    ///
    /// assert!(opaque_map.is_empty());
    /// assert!(opaque_map.capacity() >= capacity);
    /// ```
    ///
    /// Creating a type-erased index map with capacity `capacity == 0`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::with_capacity_in::<usize, f64, Global>(
    ///     0,
    ///     Global
    /// );
    ///
    /// assert!(opaque_map.has_key_type::<usize>());
    /// assert!(opaque_map.has_value_type::<f64>());
    /// assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// assert!(opaque_map.has_allocator_type::<Global>());
    ///
    /// assert!(opaque_map.is_empty());
    /// assert_eq!(opaque_map.capacity(), 0);
    /// ```
    #[inline]
    pub fn with_capacity_in<K, V, A>(capacity: usize, alloc: A) -> Self
    where
        K: any::Any,
        V: any::Any,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_index_map = TypedProjIndexMap::<K, V, _, A>::with_capacity_in(capacity, alloc);

        Self::from_proj(proj_index_map)
    }
}

impl OpaqueIndexMap {
    /// Constructs a new index map with the given hash builder.
    ///
    /// This method **does not** allocate memory. In particular, the index map has zero capacity and
    /// will not allocate memory until key-value pairs are inserted into it. The index map will have
    /// length zero until elements are inserted into it.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::with_hasher::<usize, f64, RandomState>(RandomState::new());
    ///
    /// assert!(opaque_map.has_key_type::<usize>());
    /// assert!(opaque_map.has_value_type::<f64>());
    /// assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// assert!(opaque_map.has_allocator_type::<Global>());
    ///
    /// assert!(opaque_map.is_empty());
    /// assert_eq!(opaque_map.capacity(), 0);
    /// ```
    #[inline]
    pub fn with_hasher<K, V, S>(build_hasher: S) -> Self
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
    {
        let proj_index_map = TypedProjIndexMap::<K, V, S, _>::with_hasher(build_hasher);

        Self::from_proj(proj_index_map)
    }

    /// Constructs a new index map with the given capacity and hash builder.
    ///
    /// This method **does** allocate memory if the capacity `capacity` is non-zero. In particular,
    /// the index map has capacity at least `capacity`, and will allocate enough memory to store at
    /// least `capacity` keys and values. The index map will have length zero until elements are
    /// inserted into it.
    ///
    /// # Examples
    ///
    /// Creating a type-erased index map with capacity `capacity > 0`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let capacity = 10;
    /// let opaque_map = OpaqueIndexMap::with_capacity_and_hasher::<usize, f64, RandomState>(
    ///     capacity,
    ///     RandomState::new(),
    /// );
    ///
    /// assert!(opaque_map.has_key_type::<usize>());
    /// assert!(opaque_map.has_value_type::<f64>());
    /// assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// assert!(opaque_map.has_allocator_type::<Global>());
    ///
    /// assert!(opaque_map.is_empty());
    /// assert!(opaque_map.capacity() >= capacity);
    /// ```
    ///
    /// Creating a type-erased index map with capacity `capacity == 0`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::with_capacity_and_hasher::<usize, f64, RandomState>(
    ///     0,
    ///     RandomState::new(),
    /// );
    ///
    /// assert!(opaque_map.has_key_type::<usize>());
    /// assert!(opaque_map.has_value_type::<f64>());
    /// assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// assert!(opaque_map.has_allocator_type::<Global>());
    ///
    /// assert!(opaque_map.is_empty());
    /// assert_eq!(opaque_map.capacity(), 0);
    /// ```
    #[inline]
    pub fn with_capacity_and_hasher<K, V, S>(capacity: usize, build_hasher: S) -> Self
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
    {
        let proj_index_map = TypedProjIndexMap::<K, V, S, _>::with_capacity_and_hasher(capacity, build_hasher);

        Self::from_proj(proj_index_map)
    }
}

#[cfg(feature = "std")]
impl OpaqueIndexMap {
    /// Constructs a new index map.
    ///
    /// This method **does not** allocate memory. In particular, the index map has zero capacity and
    /// will not allocate memory until key-value pairs are inserted into it. The index map will have
    /// length zero until elements are inserted into it.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::new::<usize, f64>();
    ///
    /// assert!(opaque_map.has_key_type::<usize>());
    /// assert!(opaque_map.has_value_type::<f64>());
    /// assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// assert!(opaque_map.has_allocator_type::<Global>());
    ///
    /// assert!(opaque_map.is_empty());
    /// assert_eq!(opaque_map.capacity(), 0);
    /// ```
    #[inline]
    pub fn new<K, V>() -> Self
    where
        K: any::Any,
        V: any::Any,
    {
        Self::new_in::<K, V, alloc::Global>(alloc::Global)
    }

    /// Constructs a new index map with the given capacity.
    ///
    /// This method **does** allocate memory if the capacity `capacity` is non-zero. In particular,
    /// the index map has capacity at least `capacity`, and will allocate enough memory to store at
    /// least `capacity` keys and values. The index map will have length zero until elements are
    /// inserted into it.
    ///
    /// # Examples
    ///
    /// Creating a type-erased index map with capacity `capacity > 0`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let capacity = 10;
    /// let opaque_map = OpaqueIndexMap::with_capacity::<usize, f64>(
    ///     capacity,
    /// );
    ///
    /// assert!(opaque_map.has_key_type::<usize>());
    /// assert!(opaque_map.has_value_type::<f64>());
    /// assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// assert!(opaque_map.has_allocator_type::<Global>());
    ///
    /// assert!(opaque_map.is_empty());
    /// assert!(opaque_map.capacity() >= capacity);
    /// ```
    ///
    /// Creating a type-erased index map with capacity `capacity == 0`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::with_capacity::<usize, f64>(
    ///     0,
    /// );
    ///
    /// assert!(opaque_map.has_key_type::<usize>());
    /// assert!(opaque_map.has_value_type::<f64>());
    /// assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// assert!(opaque_map.has_allocator_type::<Global>());
    ///
    /// assert!(opaque_map.is_empty());
    /// assert_eq!(opaque_map.capacity(), 0);
    /// ```
    #[inline]
    pub fn with_capacity<K, V>(capacity: usize) -> Self
    where
        K: any::Any,
        V: any::Any,
    {
        Self::with_capacity_in::<K, V, alloc::Global>(capacity, alloc::Global)
    }
}

impl OpaqueIndexMap {
    /// Returns the capacity of the type-erased index map.
    ///
    /// The **capacity** of a type-erased index map is the number of key-value pairs the index
    /// map can hold without reallocating memory.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let capacity = 32;
    /// let mut opaque_map = OpaqueIndexMap::with_capacity_in::<usize, f64, Global>(
    ///     capacity,
    ///     Global,
    /// );
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert_eq!(opaque_map.len(), 0);
    /// assert!(opaque_map.capacity() >= capacity);
    ///
    /// for i in 0..capacity {
    ///     opaque_map.insert::<usize, f64, RandomState, Global>(i, i as f64);
    /// }
    ///
    /// assert_eq!(opaque_map.len(), capacity);
    /// assert!(opaque_map.capacity() >= capacity);
    /// ```
    #[inline]
    pub fn capacity(&self) -> usize {
        self.inner.capacity()
    }

    /// Returns the length of the type-erased index map.
    ///
    /// The **length** of a type-erased index map is the number of key-value pairs stored inside
    /// it. The length satisfies the following. Given an index map `map`
    ///
    /// ```text
    /// map.len() ≤ map.capacity().
    /// ```
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let len = 32;
    /// let mut opaque_map = OpaqueIndexMap::with_capacity_in::<usize, f64, Global>(
    ///     len,
    ///     Global,
    /// );
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert_eq!(opaque_map.len(), 0);
    ///
    /// for i in 0..len {
    ///     opaque_map.insert::<usize, f64, RandomState, Global>(i, i as f64);
    /// }
    ///
    /// assert_eq!(opaque_map.len(), len);
    /// ```
    #[inline]
    pub fn len(&self) -> usize {
        self.inner.len()
    }

    /// Determines whether the type-erased index map is empty.
    ///
    /// A type-erased index map is **empty** if it contains no key-value pairs, i.e. its length
    /// is zero. This method satisfies the following. Given an index map `map`
    ///
    /// ```text
    /// map.is_empty() ⇔ map.len() = 0.
    /// ```
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::with_capacity_in::<usize, f64, Global>(
    ///     1,
    ///     Global,
    /// );
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert!(opaque_map.is_empty());
    ///
    /// opaque_map.insert::<usize, f64, RandomState, Global>(1, 1_f64);
    ///
    /// assert!(!opaque_map.is_empty());
    /// ```
    #[inline]
    pub fn is_empty(&self) -> bool {
        self.inner.is_empty()
    }
}

impl OpaqueIndexMap {
    /// Returns a reference to the type-projected hash builder used by the index map.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::new::<usize, f64>();
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert!(opaque_map.is_empty());
    ///
    /// let build_hasher: &TypedProjBuildHasher<RandomState> = opaque_map.hasher::<usize, f64, RandomState, Global>();
    /// ```
    #[inline]
    #[track_caller]
    pub fn hasher<K, V, S, A>(&self) -> &TypedProjBuildHasher<S>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj::<K, V, S, A>();

        proj_self.hasher()
    }

    /// Returns a reference to the type-projected memory allocator from the index map.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::new::<usize, f64>();
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert!(opaque_map.is_empty());
    ///
    /// let alloc: &TypedProjAlloc<Global> = opaque_map.allocator::<usize, f64, RandomState, Global>();
    /// ```
    #[inline]
    #[track_caller]
    pub fn allocator<K, V, S, A>(&self) -> &TypedProjAlloc<A>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj::<K, V, S, A>();

        proj_self.allocator()
    }
}

impl OpaqueIndexMap {
    /// Returns the storage index of the key-value pair with the given lookup key, if it exists
    /// in the index map.
    ///
    /// This method returns `Some(index)`, where `index` is the storage index of the key-value pair,
    /// if the equivalent key to `key` exists in `self`. This method returns `None` if the lookup
    /// key `key` does not exist in `self`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with keys of type `K` and values of type `V`.
    ///
    /// ## Hashing And Equivalence
    ///
    /// A **hashing type** is a triple `(X, ~, h)` where `~` is an equivalence relation on
    /// `X`, and `h` is a hash function such that
    ///
    /// ```text
    /// ∀ a :: X. ∀ b :: X. a ~ b ⇒ h(a) = h(b).
    /// ```
    ///
    /// A type `X` is a **hashable type** if there is an equivalence relation `~` and a hashing
    /// function `h` such that `(X, ~, h)` is a hashing type.
    ///
    /// Let `K` be the type of the keys of the index map `map`. Let `Q` be a data type. Let
    /// `q :: Q` be a value of type `Q`, and let `k :: K` be a key. let `X` be a hashable type. Let
    /// `f: Q → X` and `g: K → X` be functions. We say that
    /// **`q` is equivalent to `k` using `f` and `g`** if and only if
    ///
    /// ```test
    /// equiv(X, f, g)(q, k) := f(q) ∼ g(k).
    /// ```
    ///
    /// Note that by the definition of `~`
    ///
    /// ```text
    /// ∀ q :: Q. ∀ k :: K. f(q) ∼ g(k) ⇒ h(f(q)) = h(g(k)).
    /// ```
    ///
    /// This is an implication, not an equivalence, because practical hashing functions can have
    /// collisions, i.e. for a practical hashing function `h`,
    /// `∃ a, b :: X. ¬(a ~ b) ∧ h(a) = h(b)`. We say that the type
    /// **`Q` is equivalent to `K` using `f` and `g`** if and only if
    ///
    /// ```text
    /// equiv(X, f, g)(Q, K) :=
    ///     (∀ q :: Q. ∃ k :: K. equiv(X, f, g)(q, k))
    ///     ∧ (∀ k :: K. ∃ q :: Q. equiv(X, f, g)(q, k)).
    /// ```
    ///
    /// Let `X` be a hashable type. Then the type **`Q` is equivalent to the type `K` using `X`**
    /// if and only if
    ///
    /// ```text
    /// equiv(X, Q, K) := ∃ f: Q → X. ∃ g: K → X. equiv(X, f, g)(Q, K).
    /// ```
    ///
    /// Key equality is a special case of key equivalence. Let `K` be a hashable data type. Let
    /// `Q = K`, and `f = g = id`. Then
    ///
    /// ```text
    /// ∀ k1, k2 :: K. k1 = k2 = id(k1) = id(k2) ⇒ h(id(k1)) = h(id(k2)) = h(k1) = h(k2)
    /// ```
    ///
    /// so that we have `equiv(K, id, id)(K, K)` which implies `equiv(K, K, K)`, i.e. `K` is
    /// equivalent to `K` using `K` when `K` is a hashable type.
    ///
    /// Let `Q` be a type equivalent to the key type `K` using `K`. Let `f: Q → K` and `id: K → K`
    /// be the identity. We say that **`q` is equivalent to `k`** if and only if
    ///
    /// ```text
    /// equiv(q, k) := equiv(K, f, id)(q, k).
    /// ```
    ///
    /// Let `Q` be a data type equivalent to key type `K` using `K`. We say that `q` is an
    /// **equivalent element of** the map `map`, or that **`map` equivalently contains `q`** if and
    /// only if
    ///
    /// ```text
    /// q ~∈ map ⇔ ∃ i ∈ [0, map.len()). equiv(q, map[i].key()).
    /// ```
    ///
    /// If `q` is not an equivalent element of `map`, we write `q ~∉ map`.
    ///
    /// When `K` is a hashable type, we see that `k ~∈ map ⇔ k ∈ map`, so that equivalent
    /// containment indeed generalizes containment.
    ///
    /// ## Specification Definitions
    ///
    /// The **index** of an equivalent key `q :: Q` in `map` is defined by
    ///
    /// ```text
    /// index(map, q) := i such that equiv(q, map[i].key()).
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ~∈ map }
    /// map.get_index_of(key)
    /// { result = Some(index(map, key)) }
    ///
    /// { key ~∉ map }
    /// map.get_index_of(key)
    /// { result = None }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert_eq!(opaque_map.get_index_of::<_, usize, f64, RandomState, Global>(&1_usize), Some(0));
    /// assert_eq!(opaque_map.get_index_of::<_, usize, f64, RandomState, Global>(&2_usize), Some(1));
    /// assert_eq!(opaque_map.get_index_of::<_, usize, f64, RandomState, Global>(&3_usize), Some(2));
    /// assert_eq!(opaque_map.get_index_of::<_, usize, f64, RandomState, Global>(&4_usize), None);
    /// assert_eq!(opaque_map.get_index_of::<_, usize, f64, RandomState, Global>(&usize::MAX), None);
    /// ```
    #[track_caller]
    pub fn get_index_of<Q, K, V, S, A>(&self, key: &Q) -> Option<usize>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
        Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    {
        let proj_self = self.as_proj::<K, V, S, A>();

        proj_self.get_index_of(key)
    }

    /// Determines whether a given lookup key exists in the index map.
    ///
    /// This method returns `true` if the equivalent key to `key` exists in `self`. This method
    /// returns `false` if the equivalent key to `key` does not exist in `self`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with keys of type `K` and values of type `V`.
    ///
    /// ## Hashing And Equivalence
    ///
    /// A **hashing type** is a triple `(X, ~, h)` where `~` is an equivalence relation on
    /// `X`, and `h` is a hash function such that
    ///
    /// ```text
    /// ∀ a :: X. ∀ b :: X. a ~ b ⇒ h(a) = h(b).
    /// ```
    ///
    /// A type `X` is a **hashable type** if there is an equivalence relation `~` and a hashing
    /// function `h` such that `(X, ~, h)` is a hashing type.
    ///
    /// Let `K` be the type of the keys of the index map `map`. Let `Q` be a data type. Let
    /// `q :: Q` be a value of type `Q`, and let `k :: K` be a key. let `X` be a hashable type. Let
    /// `f: Q → X` and `g: K → X` be functions. We say that
    /// **`q` is equivalent to `k` using `f` and `g`** if and only if
    ///
    /// ```test
    /// equiv(X, f, g)(q, k) := f(q) ∼ g(k).
    /// ```
    ///
    /// Note that by the definition of `~`
    ///
    /// ```text
    /// ∀ q :: Q. ∀ k :: K. f(q) ∼ g(k) ⇒ h(f(q)) = h(g(k)).
    /// ```
    ///
    /// This is an implication, not an equivalence, because practical hashing functions can have
    /// collisions, i.e. for a practical hashing function `h`,
    /// `∃ a, b :: X. ¬(a ~ b) ∧ h(a) = h(b)`. We say that the type
    /// **`Q` is equivalent to `K` using `f` and `g`** if and only if
    ///
    /// ```text
    /// equiv(X, f, g)(Q, K) :=
    ///     (∀ q :: Q. ∃ k :: K. equiv(X, f, g)(q, k))
    ///     ∧ (∀ k :: K. ∃ q :: Q. equiv(X, f, g)(q, k)).
    /// ```
    ///
    /// Let `X` be a hashable type. Then the type **`Q` is equivalent to the type `K` using `X`**
    /// if and only if
    ///
    /// ```text
    /// equiv(X, Q, K) := ∃ f: Q → X. ∃ g: K → X. equiv(X, f, g)(Q, K).
    /// ```
    ///
    /// Key equality is a special case of key equivalence. Let `K` be a hashable data type. Let
    /// `Q = K`, and `f = g = id`. Then
    ///
    /// ```text
    /// ∀ k1, k2 :: K. k1 = k2 = id(k1) = id(k2) ⇒ h(id(k1)) = h(id(k2)) = h(k1) = h(k2)
    /// ```
    ///
    /// so that we have `equiv(K, id, id)(K, K)` which implies `equiv(K, K, K)`, i.e. `K` is
    /// equivalent to `K` using `K` when `K` is a hashable type.
    ///
    /// Let `Q` be a type equivalent to the key type `K` using `K`. Let `f: Q → K` and `id: K → K`
    /// be the identity. We say that **`q` is equivalent to `k`** if and only if
    ///
    /// ```text
    /// equiv(q, k) := equiv(K, f, id)(q, k).
    /// ```
    ///
    /// Let `Q` be a data type equivalent to key type `K` using `K`. We say that `q` is an
    /// **equivalent element of** the map `map`, or that **`map` equivalently contains `q`** if and
    /// only if
    ///
    /// ```text
    /// q ~∈ map ⇔ ∃ i ∈ [0, map.len()). equiv(q, map[i].key()).
    /// ```
    ///
    /// If `q` is not an equivalent element of `map`, we write `q ~∉ map`.
    ///
    /// When `K` is a hashable type, we see that `k ~∈ map ⇔ k ∈ map`, so that equivalent
    /// containment indeed generalizes containment.
    ///
    /// ## Specification Definitions
    ///
    /// Let `e :: (K, V)` be an entry of type `(K, V)`. We say that `map` **contains** a key-value
    /// pair `e :: (K, V)`, or that `e` is an **entry of** `map` if the following holds:
    ///
    /// ```text
    /// ∀ e :: (K, V). (e ∈ map) ⇔ (∃ i ∈ [0, map.len()). map[i] = e ∧ map[e.key()] = e.value())
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies the following:
    ///
    /// ```text
    /// { key ~∈ map }
    /// map.contains_key(key)
    /// { result = true }
    ///
    /// { key ~∉ map }
    /// map.contains_key(key)
    /// { result = false }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert!(opaque_map.contains_key::<_, usize, f64, RandomState, Global>(&1_usize));
    /// assert!(opaque_map.contains_key::<_, usize, f64, RandomState, Global>(&2_usize));
    /// assert!(opaque_map.contains_key::<_, usize, f64, RandomState, Global>(&3_usize));
    /// assert!(!opaque_map.contains_key::<_, usize, f64, RandomState, Global>(&4_usize));
    /// assert!(!opaque_map.contains_key::<_, usize, f64, RandomState, Global>(&usize::MAX));
    /// ```
    #[track_caller]
    pub fn contains_key<Q, K, V, S, A>(&self, key: &Q) -> bool
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
        Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    {
        let proj_self = self.as_proj::<K, V, S, A>();

        proj_self.contains_key(key)
    }

    /// Returns a reference to the value corresponding to a key-value pair with the given lookup
    /// key, if it exists in the index map.
    ///
    /// This method returns `Some(&value)` where `value` is the value corresponding to the
    /// equivalent key to `key` in `self` if the equivalent key to key exists in `self`. This
    /// method returns `None` if the equivalent key to `key` does not exist in `self`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with keys of type `K` and values of type `V`.
    ///
    /// ## Hashing And Equivalence
    ///
    /// A **hashing type** is a triple `(X, ~, h)` where `~` is an equivalence relation on
    /// `X`, and `h` is a hash function such that
    ///
    /// ```text
    /// ∀ a :: X. ∀ b :: X. a ~ b ⇒ h(a) = h(b).
    /// ```
    ///
    /// A type `X` is a **hashable type** if there is an equivalence relation `~` and a hashing
    /// function `h` such that `(X, ~, h)` is a hashing type.
    ///
    /// Let `K` be the type of the keys of the index map `map`. Let `Q` be a data type. Let
    /// `q :: Q` be a value of type `Q`, and let `k :: K` be a key. let `X` be a hashable type. Let
    /// `f: Q → X` and `g: K → X` be functions. We say that
    /// **`q` is equivalent to `k` using `f` and `g`** if and only if
    ///
    /// ```test
    /// equiv(X, f, g)(q, k) := f(q) ∼ g(k).
    /// ```
    ///
    /// Note that by the definition of `~`
    ///
    /// ```text
    /// ∀ q :: Q. ∀ k :: K. f(q) ∼ g(k) ⇒ h(f(q)) = h(g(k)).
    /// ```
    ///
    /// This is an implication, not an equivalence, because practical hashing functions can have
    /// collisions, i.e. for a practical hashing function `h`,
    /// `∃ a, b :: X. ¬(a ~ b) ∧ h(a) = h(b)`. We say that the type
    /// **`Q` is equivalent to `K` using `f` and `g`** if and only if
    ///
    /// ```text
    /// equiv(X, f, g)(Q, K) :=
    ///     (∀ q :: Q. ∃ k :: K. equiv(X, f, g)(q, k))
    ///     ∧ (∀ k :: K. ∃ q :: Q. equiv(X, f, g)(q, k)).
    /// ```
    ///
    /// Let `X` be a hashable type. Then the type **`Q` is equivalent to the type `K` using `X`**
    /// if and only if
    ///
    /// ```text
    /// equiv(X, Q, K) := ∃ f: Q → X. ∃ g: K → X. equiv(X, f, g)(Q, K).
    /// ```
    ///
    /// Key equality is a special case of key equivalence. Let `K` be a hashable data type. Let
    /// `Q = K`, and `f = g = id`. Then
    ///
    /// ```text
    /// ∀ k1, k2 :: K. k1 = k2 = id(k1) = id(k2) ⇒ h(id(k1)) = h(id(k2)) = h(k1) = h(k2)
    /// ```
    ///
    /// so that we have `equiv(K, id, id)(K, K)` which implies `equiv(K, K, K)`, i.e. `K` is
    /// equivalent to `K` using `K` when `K` is a hashable type.
    ///
    /// Let `Q` be a type equivalent to the key type `K` using `K`. Let `f: Q → K` and `id: K → K`
    /// be the identity. We say that **`q` is equivalent to `k`** if and only if
    ///
    /// ```text
    /// equiv(q, k) := equiv(K, f, id)(q, k).
    /// ```
    ///
    /// Let `Q` be a data type equivalent to key type `K` using `K`. We say that `q` is an
    /// **equivalent element of** the map `map`, or that **`map` equivalently contains `q`** if and
    /// only if
    ///
    /// ```text
    /// q ~∈ map ⇔ ∃ i ∈ [0, map.len()). equiv(q, map[i].key()).
    /// ```
    ///
    /// If `q` is not an equivalent element of `map`, we write `q ~∉ map`.
    ///
    /// When `K` is a hashable type, we see that `k ~∈ map ⇔ k ∈ map`, so that equivalent
    /// containment indeed generalizes containment.
    ///
    /// ## Specification Definitions
    ///
    /// The **index** of an equivalent key `q :: Q` in `map` is defined by
    ///
    /// ```text
    /// index(map, q) := i such that equiv(q, map[i].key()).
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ~∈ map }
    /// map.get(key)
    /// { result = Some(map[index(map, key)]) }
    ///
    /// { key ~∉ map }
    /// map.get(key)
    /// { result = None }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert_eq!(opaque_map.get::<_, usize, f64, RandomState, Global>(&1_usize), Some(&2_f64));
    /// assert_eq!(opaque_map.get::<_, usize, f64, RandomState, Global>(&2_usize), Some(&3_f64));
    /// assert_eq!(opaque_map.get::<_, usize, f64, RandomState, Global>(&3_usize), Some(&4_f64));
    /// assert_eq!(opaque_map.get::<_, usize, f64, RandomState, Global>(&4_usize), None);
    /// assert_eq!(opaque_map.get::<_, usize, f64, RandomState, Global>(&usize::MAX), None);
    /// ```
    #[track_caller]
    pub fn get<Q, K, V, S, A>(&self, key: &Q) -> Option<&V>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
        Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    {
        let proj_self = self.as_proj::<K, V, S, A>();

        proj_self.get(key)
    }

    /// Returns a reference to the key and a reference to the value, of the key-value pair with the
    /// given lookup key, if it exists in the index map.
    ///
    /// This method returns `Some((&eq_key, &value))` where `eq_key` is the equivalent key to `key`
    /// stored in the map, and `value` is the value corresponding to the key `eq_key` in `self`,
    /// if the equivalent key `eq_key` to `key` exists in `self`. This method returns `None` if the
    /// equivalent key to `key` does not exist in `self`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with keys of type `K` and values of type `V`.
    ///
    /// ## Hashing And Equivalence
    ///
    /// A **hashing type** is a triple `(X, ~, h)` where `~` is an equivalence relation on
    /// `X`, and `h` is a hash function such that
    ///
    /// ```text
    /// ∀ a :: X. ∀ b :: X. a ~ b ⇒ h(a) = h(b).
    /// ```
    ///
    /// A type `X` is a **hashable type** if there is an equivalence relation `~` and a hashing
    /// function `h` such that `(X, ~, h)` is a hashing type.
    ///
    /// Let `K` be the type of the keys of the index map `map`. Let `Q` be a data type. Let
    /// `q :: Q` be a value of type `Q`, and let `k :: K` be a key. let `X` be a hashable type. Let
    /// `f: Q → X` and `g: K → X` be functions. We say that
    /// **`q` is equivalent to `k` using `f` and `g`** if and only if
    ///
    /// ```test
    /// equiv(X, f, g)(q, k) := f(q) ∼ g(k).
    /// ```
    ///
    /// Note that by the definition of `~`
    ///
    /// ```text
    /// ∀ q :: Q. ∀ k :: K. f(q) ∼ g(k) ⇒ h(f(q)) = h(g(k)).
    /// ```
    ///
    /// This is an implication, not an equivalence, because practical hashing functions can have
    /// collisions, i.e. for a practical hashing function `h`,
    /// `∃ a, b :: X. ¬(a ~ b) ∧ h(a) = h(b)`. We say that the type
    /// **`Q` is equivalent to `K` using `f` and `g`** if and only if
    ///
    /// ```text
    /// equiv(X, f, g)(Q, K) :=
    ///     (∀ q :: Q. ∃ k :: K. equiv(X, f, g)(q, k))
    ///     ∧ (∀ k :: K. ∃ q :: Q. equiv(X, f, g)(q, k)).
    /// ```
    ///
    /// Let `X` be a hashable type. Then the type **`Q` is equivalent to the type `K` using `X`**
    /// if and only if
    ///
    /// ```text
    /// equiv(X, Q, K) := ∃ f: Q → X. ∃ g: K → X. equiv(X, f, g)(Q, K).
    /// ```
    ///
    /// Key equality is a special case of key equivalence. Let `K` be a hashable data type. Let
    /// `Q = K`, and `f = g = id`. Then
    ///
    /// ```text
    /// ∀ k1, k2 :: K. k1 = k2 = id(k1) = id(k2) ⇒ h(id(k1)) = h(id(k2)) = h(k1) = h(k2)
    /// ```
    ///
    /// so that we have `equiv(K, id, id)(K, K)` which implies `equiv(K, K, K)`, i.e. `K` is
    /// equivalent to `K` using `K` when `K` is a hashable type.
    ///
    /// Let `Q` be a type equivalent to the key type `K` using `K`. Let `f: Q → K` and `id: K → K`
    /// be the identity. We say that **`q` is equivalent to `k`** if and only if
    ///
    /// ```text
    /// equiv(q, k) := equiv(K, f, id)(q, k).
    /// ```
    ///
    /// Let `Q` be a data type equivalent to key type `K` using `K`. We say that `q` is an
    /// **equivalent element of** the map `map`, or that **`map` equivalently contains `q`** if and
    /// only if
    ///
    /// ```text
    /// q ~∈ map ⇔ ∃ i ∈ [0, map.len()). equiv(q, map[i].key()).
    /// ```
    ///
    /// If `q` is not an equivalent element of `map`, we write `q ~∉ map`.
    ///
    /// When `K` is a hashable type, we see that `k ~∈ map ⇔ k ∈ map`, so that equivalent
    /// containment indeed generalizes containment.
    ///
    /// ## Specification Definitions
    ///
    /// The **index** of an equivalent key `q :: Q` in `map` is defined by
    ///
    /// ```text
    /// index(map, q) := i such that equiv(q, map[i].key()).
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ~∈ map }
    /// map.get_key_value(key)
    /// { result = Some(map[index(map, key)]) }
    ///
    /// { key ~∉ map }
    /// map.get_key_value(key)
    /// { result = None }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert_eq!(opaque_map.get_key_value::<_, usize, f64, RandomState, Global>(&1_usize), Some((&1_usize, &2_f64)));
    /// assert_eq!(opaque_map.get_key_value::<_, usize, f64, RandomState, Global>(&2_usize), Some((&2_usize, &3_f64)));
    /// assert_eq!(opaque_map.get_key_value::<_, usize, f64, RandomState, Global>(&3_usize), Some((&3_usize, &4_f64)));
    /// assert_eq!(opaque_map.get_key_value::<_, usize, f64, RandomState, Global>(&4_usize), None);
    /// assert_eq!(opaque_map.get_key_value::<_, usize, f64, RandomState, Global>(&usize::MAX), None);
    /// ```
    #[track_caller]
    pub fn get_key_value<Q, K, V, S, A>(&self, key: &Q) -> Option<(&K, &V)>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
        Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    {
        let proj_self = self.as_proj::<K, V, S, A>();

        proj_self.get_key_value(key)
    }

    /// Returns the storage index, a reference to the key and a reference to the value, of the
    /// key-value pair with the given lookup key, if it exists in the index map.
    ///
    /// This method returns `Some((index, &eq_key, &value))` where `index` is the storage index of
    /// the key-value pair, `eq_key` is the equivalent key to `key` stored in the map, and `value`
    /// is the value corresponding to the key `eq_key` in `self`, if the equivalent key `eq_key`
    /// to `key` exists in `self`. This method returns `None` if the equivalent key to `key` does
    /// not exist in `self`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with keys of type `K` and values of type `V`.
    ///
    /// ## Hashing And Equivalence
    ///
    /// A **hashing type** is a triple `(X, ~, h)` where `~` is an equivalence relation on
    /// `X`, and `h` is a hash function such that
    ///
    /// ```text
    /// ∀ a :: X. ∀ b :: X. a ~ b ⇒ h(a) = h(b).
    /// ```
    ///
    /// A type `X` is a **hashable type** if there is an equivalence relation `~` and a hashing
    /// function `h` such that `(X, ~, h)` is a hashing type.
    ///
    /// Let `K` be the type of the keys of the index map `map`. Let `Q` be a data type. Let
    /// `q :: Q` be a value of type `Q`, and let `k :: K` be a key. let `X` be a hashable type. Let
    /// `f: Q → X` and `g: K → X` be functions. We say that
    /// **`q` is equivalent to `k` using `f` and `g`** if and only if
    ///
    /// ```test
    /// equiv(X, f, g)(q, k) := f(q) ∼ g(k).
    /// ```
    ///
    /// Note that by the definition of `~`
    ///
    /// ```text
    /// ∀ q :: Q. ∀ k :: K. f(q) ∼ g(k) ⇒ h(f(q)) = h(g(k)).
    /// ```
    ///
    /// This is an implication, not an equivalence, because practical hashing functions can have
    /// collisions, i.e. for a practical hashing function `h`,
    /// `∃ a, b :: X. ¬(a ~ b) ∧ h(a) = h(b)`. We say that the type
    /// **`Q` is equivalent to `K` using `f` and `g`** if and only if
    ///
    /// ```text
    /// equiv(X, f, g)(Q, K) :=
    ///     (∀ q :: Q. ∃ k :: K. equiv(X, f, g)(q, k))
    ///     ∧ (∀ k :: K. ∃ q :: Q. equiv(X, f, g)(q, k)).
    /// ```
    ///
    /// Let `X` be a hashable type. Then the type **`Q` is equivalent to the type `K` using `X`**
    /// if and only if
    ///
    /// ```text
    /// equiv(X, Q, K) := ∃ f: Q → X. ∃ g: K → X. equiv(X, f, g)(Q, K).
    /// ```
    ///
    /// Key equality is a special case of key equivalence. Let `K` be a hashable data type. Let
    /// `Q = K`, and `f = g = id`. Then
    ///
    /// ```text
    /// ∀ k1, k2 :: K. k1 = k2 = id(k1) = id(k2) ⇒ h(id(k1)) = h(id(k2)) = h(k1) = h(k2)
    /// ```
    ///
    /// so that we have `equiv(K, id, id)(K, K)` which implies `equiv(K, K, K)`, i.e. `K` is
    /// equivalent to `K` using `K` when `K` is a hashable type.
    ///
    /// Let `Q` be a type equivalent to the key type `K` using `K`. Let `f: Q → K` and `id: K → K`
    /// be the identity. We say that **`q` is equivalent to `k`** if and only if
    ///
    /// ```text
    /// equiv(q, k) := equiv(K, f, id)(q, k).
    /// ```
    ///
    /// Let `Q` be a data type equivalent to key type `K` using `K`. We say that `q` is an
    /// **equivalent element of** the map `map`, or that **`map` equivalently contains `q`** if and
    /// only if
    ///
    /// ```text
    /// q ~∈ map ⇔ ∃ i ∈ [0, map.len()). equiv(q, map[i].key()).
    /// ```
    ///
    /// If `q` is not an equivalent element of `map`, we write `q ~∉ map`.
    ///
    /// When `K` is a hashable type, we see that `k ~∈ map ⇔ k ∈ map`, so that equivalent
    /// containment indeed generalizes containment.
    ///
    /// ## Specification Definitions
    ///
    /// The **index** of an equivalent key `q :: Q` in `map` is defined by
    ///
    /// ```text
    /// index(map, q) := i such that equiv(q, map[i].key()).
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ~∈ map }
    /// map.get_full(key)
    /// { result = Some((index(map, key), map[index(map, key)])) }
    ///
    /// { key ~∉ map }
    /// map.get_full(key)
    /// { result = None }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert_eq!(opaque_map.get_full::<_, usize, f64, RandomState, Global>(&1_usize), Some((0, &1_usize, &2_f64)));
    /// assert_eq!(opaque_map.get_full::<_, usize, f64, RandomState, Global>(&2_usize), Some((1, &2_usize, &3_f64)));
    /// assert_eq!(opaque_map.get_full::<_, usize, f64, RandomState, Global>(&3_usize), Some((2, &3_usize, &4_f64)));
    /// assert_eq!(opaque_map.get_full::<_, usize, f64, RandomState, Global>(&4_usize), None);
    /// assert_eq!(opaque_map.get_full::<_, usize, f64, RandomState, Global>(&usize::MAX), None);
    /// ```
    #[track_caller]
    pub fn get_full<Q, K, V, S, A>(&self, key: &Q) -> Option<(usize, &K, &V)>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
        Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    {
        let proj_self = self.as_proj::<K, V, S, A>();

        proj_self.get_full(key)
    }

    /// Returns a mutable reference to the value corresponding to a key-value pair with the given
    /// lookup key, if it exists in the index map.
    ///
    /// This method returns `Some(&mut value)` where `value` is the value corresponding to the
    /// equivalent key to `key` in `self`. This method returns `None` if the equivalent key to
    /// `key` does not exist in `self`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with keys of type `K` and values of type `V`.
    ///
    /// ## Hashing And Equivalence
    ///
    /// A **hashing type** is a triple `(X, ~, h)` where `~` is an equivalence relation on
    /// `X`, and `h` is a hash function such that
    ///
    /// ```text
    /// ∀ a :: X. ∀ b :: X. a ~ b ⇒ h(a) = h(b).
    /// ```
    ///
    /// A type `X` is a **hashable type** if there is an equivalence relation `~` and a hashing
    /// function `h` such that `(X, ~, h)` is a hashing type.
    ///
    /// Let `K` be the type of the keys of the index map `map`. Let `Q` be a data type. Let
    /// `q :: Q` be a value of type `Q`, and let `k :: K` be a key. let `X` be a hashable type. Let
    /// `f: Q → X` and `g: K → X` be functions. We say that
    /// **`q` is equivalent to `k` using `f` and `g`** if and only if
    ///
    /// ```test
    /// equiv(X, f, g)(q, k) := f(q) ∼ g(k).
    /// ```
    ///
    /// Note that by the definition of `~`
    ///
    /// ```text
    /// ∀ q :: Q. ∀ k :: K. f(q) ∼ g(k) ⇒ h(f(q)) = h(g(k)).
    /// ```
    ///
    /// This is an implication, not an equivalence, because practical hashing functions can have
    /// collisions, i.e. for a practical hashing function `h`,
    /// `∃ a, b :: X. ¬(a ~ b) ∧ h(a) = h(b)`. We say that the type
    /// **`Q` is equivalent to `K` using `f` and `g`** if and only if
    ///
    /// ```text
    /// equiv(X, f, g)(Q, K) :=
    ///     (∀ q :: Q. ∃ k :: K. equiv(X, f, g)(q, k))
    ///     ∧ (∀ k :: K. ∃ q :: Q. equiv(X, f, g)(q, k)).
    /// ```
    ///
    /// Let `X` be a hashable type. Then the type **`Q` is equivalent to the type `K` using `X`**
    /// if and only if
    ///
    /// ```text
    /// equiv(X, Q, K) := ∃ f: Q → X. ∃ g: K → X. equiv(X, f, g)(Q, K).
    /// ```
    ///
    /// Key equality is a special case of key equivalence. Let `K` be a hashable data type. Let
    /// `Q = K`, and `f = g = id`. Then
    ///
    /// ```text
    /// ∀ k1, k2 :: K. k1 = k2 = id(k1) = id(k2) ⇒ h(id(k1)) = h(id(k2)) = h(k1) = h(k2)
    /// ```
    ///
    /// so that we have `equiv(K, id, id)(K, K)` which implies `equiv(K, K, K)`, i.e. `K` is
    /// equivalent to `K` using `K` when `K` is a hashable type.
    ///
    /// Let `Q` be a type equivalent to the key type `K` using `K`. Let `f: Q → K` and `id: K → K`
    /// be the identity. We say that **`q` is equivalent to `k`** if and only if
    ///
    /// ```text
    /// equiv(q, k) := equiv(K, f, id)(q, k).
    /// ```
    ///
    /// Let `Q` be a data type equivalent to key type `K` using `K`. We say that `q` is an
    /// **equivalent element of** the map `map`, or that **`map` equivalently contains `q`** if and
    /// only if
    ///
    /// ```text
    /// q ~∈ map ⇔ ∃ i ∈ [0, map.len()). equiv(q, map[i].key()).
    /// ```
    ///
    /// If `q` is not an equivalent element of `map`, we write `q ~∉ map`.
    ///
    /// When `K` is a hashable type, we see that `k ~∈ map ⇔ k ∈ map`, so that equivalent
    /// containment indeed generalizes containment.
    ///
    /// ## Specification Definitions
    ///
    /// The **index** of an equivalent key `q :: Q` in `map` is defined by
    ///
    /// ```text
    /// index(map, q) := i such that equiv(q, map[i].key()).
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ~∈ map }
    /// map.get_mut(key)
    /// { result = Some(map[index(map, key)]) }
    ///
    /// { key ~∉ map }
    /// map.get_mut(key)
    /// { result = None }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert_eq!(opaque_map.get_mut::<_, usize, f64, RandomState, Global>(&1_usize), Some(&mut 2_f64));
    /// assert_eq!(opaque_map.get_mut::<_, usize, f64, RandomState, Global>(&2_usize), Some(&mut 3_f64));
    /// assert_eq!(opaque_map.get_mut::<_, usize, f64, RandomState, Global>(&3_usize), Some(&mut 4_f64));
    /// assert_eq!(opaque_map.get_mut::<_, usize, f64, RandomState, Global>(&4_usize), None);
    /// assert_eq!(opaque_map.get_mut::<_, usize, f64, RandomState, Global>(&usize::MAX), None);
    /// ```
    #[track_caller]
    pub fn get_mut<Q, K, V, S, A>(&mut self, key: &Q) -> Option<&mut V>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
        Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.get_mut(key)
    }

    /// Returns the storage index, a reference to the key and a mutable reference to the value, of
    /// the key-value pair with the given lookup key, if it exists in the index map.
    ///
    /// This method returns `Some((index, &eq_key, &mut value))` where `index` is the storage index
    /// of the key-value pair, `eq_key` is the equivalent key to `key` stored in the map and
    /// `value` is the value corresponding to the key `eq_key` in `self`, if the equivalent key to
    /// `key` exists in `self`. This method returns `None` if the equivalent key to `key` does
    /// not exist in `self`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with keys of type `K` and values of type `V`.
    ///
    /// ## Hashing And Equivalence
    ///
    /// A **hashing type** is a triple `(X, ~, h)` where `~` is an equivalence relation on
    /// `X`, and `h` is a hash function such that
    ///
    /// ```text
    /// ∀ a :: X. ∀ b :: X. a ~ b ⇒ h(a) = h(b).
    /// ```
    ///
    /// A type `X` is a **hashable type** if there is an equivalence relation `~` and a hashing
    /// function `h` such that `(X, ~, h)` is a hashing type.
    ///
    /// Let `K` be the type of the keys of the index map `map`. Let `Q` be a data type. Let
    /// `q :: Q` be a value of type `Q`, and let `k :: K` be a key. let `X` be a hashable type. Let
    /// `f: Q → X` and `g: K → X` be functions. We say that
    /// **`q` is equivalent to `k` using `f` and `g`** if and only if
    ///
    /// ```test
    /// equiv(X, f, g)(q, k) := f(q) ∼ g(k).
    /// ```
    ///
    /// Note that by the definition of `~`
    ///
    /// ```text
    /// ∀ q :: Q. ∀ k :: K. f(q) ∼ g(k) ⇒ h(f(q)) = h(g(k)).
    /// ```
    ///
    /// This is an implication, not an equivalence, because practical hashing functions can have
    /// collisions, i.e. for a practical hashing function `h`,
    /// `∃ a, b :: X. ¬(a ~ b) ∧ h(a) = h(b)`. We say that the type
    /// **`Q` is equivalent to `K` using `f` and `g`** if and only if
    ///
    /// ```text
    /// equiv(X, f, g)(Q, K) :=
    ///     (∀ q :: Q. ∃ k :: K. equiv(X, f, g)(q, k))
    ///     ∧ (∀ k :: K. ∃ q :: Q. equiv(X, f, g)(q, k)).
    /// ```
    ///
    /// Let `X` be a hashable type. Then the type **`Q` is equivalent to the type `K` using `X`**
    /// if and only if
    ///
    /// ```text
    /// equiv(X, Q, K) := ∃ f: Q → X. ∃ g: K → X. equiv(X, f, g)(Q, K).
    /// ```
    ///
    /// Key equality is a special case of key equivalence. Let `K` be a hashable data type. Let
    /// `Q = K`, and `f = g = id`. Then
    ///
    /// ```text
    /// ∀ k1, k2 :: K. k1 = k2 = id(k1) = id(k2) ⇒ h(id(k1)) = h(id(k2)) = h(k1) = h(k2)
    /// ```
    ///
    /// so that we have `equiv(K, id, id)(K, K)` which implies `equiv(K, K, K)`, i.e. `K` is
    /// equivalent to `K` using `K` when `K` is a hashable type.
    ///
    /// Let `Q` be a type equivalent to the key type `K` using `K`. Let `f: Q → K` and `id: K → K`
    /// be the identity. We say that **`q` is equivalent to `k`** if and only if
    ///
    /// ```text
    /// equiv(q, k) := equiv(K, f, id)(q, k).
    /// ```
    ///
    /// Let `Q` be a data type equivalent to key type `K` using `K`. We say that `q` is an
    /// **equivalent element of** the map `map`, or that **`map` equivalently contains `q`** if and
    /// only if
    ///
    /// ```text
    /// q ~∈ map ⇔ ∃ i ∈ [0, map.len()). equiv(q, map[i].key()).
    /// ```
    ///
    /// If `q` is not an equivalent element of `map`, we write `q ~∉ map`.
    ///
    /// When `K` is a hashable type, we see that `k ~∈ map ⇔ k ∈ map`, so that equivalent
    /// containment indeed generalizes containment.
    ///
    /// ## Specification Definitions
    ///
    /// The **index** of an equivalent key `q :: Q` in `map` is defined by
    ///
    /// ```text
    /// index(map, q) := i such that equiv(q, map[i].key()).
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ~∈ map }
    /// map.get_full_mut(key)
    /// { result = Some((index(map, key), map[index(map, key)])) }
    ///
    /// { key ~∉ map }
    /// map.get_full_mut(key)
    /// { result = None }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert_eq!(opaque_map.get_full_mut::<_, usize, f64, RandomState, Global>(&1_usize), Some((0, &1_usize, &mut 2_f64)));
    /// assert_eq!(opaque_map.get_full_mut::<_, usize, f64, RandomState, Global>(&2_usize), Some((1, &2_usize, &mut 3_f64)));
    /// assert_eq!(opaque_map.get_full_mut::<_, usize, f64, RandomState, Global>(&3_usize), Some((2, &3_usize, &mut 4_f64)));
    /// assert_eq!(opaque_map.get_full_mut::<_, usize, f64, RandomState, Global>(&4_usize), None);
    /// assert_eq!(opaque_map.get_full_mut::<_, usize, f64, RandomState, Global>(&usize::MAX), None);
    /// ```
    #[track_caller]
    pub fn get_full_mut<Q, K, V, S, A>(&mut self, key: &Q) -> Option<(usize, &K, &mut V)>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
        Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.get_full_mut(key)
    }

    /// Returns multiple references to the values of multiple lookup keys at once.
    ///
    /// # Panics
    ///
    /// This method panics if there are any duplicate lookup keys.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_isize, 'a'),
    ///     (3_isize, 'b'),
    ///     (2_isize, 'c'),
    ///     (6_isize, 'e'),
    ///     (4_isize, 'f'),
    ///     (5_isize, '@'),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<isize>());
    /// # assert!(opaque_map.has_value_type::<char>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert_eq!(opaque_map.get_disjoint_mut::<_, 3, isize, char, RandomState, Global>([&2, &1, &5]), [Some(&mut 'c'), Some(&mut 'a'), Some(&mut '@')]);
    /// ```
    #[track_caller]
    pub fn get_disjoint_mut<Q, const N: usize, K, V, S, A>(&mut self, keys: [&Q; N]) -> [Option<&mut V>; N]
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
        Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.get_disjoint_mut(keys)
    }

    /// Returns an iterator over the keys in the index map.
    ///
    /// The iterator returns the keys in the storage order of the entries in the index map.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// let keys: TypedProjVec<usize> = opaque_map
    ///     .keys::<usize, f64, RandomState, Global>()
    ///     .cloned()
    ///     .collect();
    ///
    /// assert_eq!(keys.as_slice(), &[1_usize, 2_usize, 3_usize]);
    ///
    /// // The keys come back in storage or insertion order from the index map.
    /// for i in 0..keys.len() {
    ///     let expected = i;
    ///     let result = opaque_map.get_index_of::<_, usize, f64, RandomState, Global>(&keys[i]).unwrap();
    ///     assert_eq!(result, expected);
    /// }
    /// ```
    #[track_caller]
    pub fn keys<K, V, S, A>(&self) -> Keys<'_, K, V>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj::<K, V, S, A>();

        proj_self.keys()
    }

    /// Returns a moving iterator over the keys in the index map.
    ///
    /// The iterator returns the keys in the storage order of the entries in the index map.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// let keys: TypedProjVec<usize> = opaque_map
    ///     .clone::<usize, f64, RandomState, Global>()
    ///     .into_keys::<usize, f64, RandomState, Global>()
    ///     .collect();
    ///
    /// assert_eq!(keys.as_slice(), &[1_usize, 2_usize, 3_usize]);
    ///
    /// // The keys come back in storage or insertion order from the index map.
    /// for i in 0..keys.len() {
    ///     let expected = i;
    ///     let result = opaque_map.get_index_of::<_, usize, f64, RandomState, Global>(&keys[i]).unwrap();
    ///     assert_eq!(result, expected);
    /// }
    /// ```
    #[track_caller]
    pub fn into_keys<K, V, S, A>(self) -> IntoKeys<K, V, A>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.into_proj::<K, V, S, A>();

        proj_self.into_keys()
    }

    /// Returns an iterator over the entries in the index map.
    ///
    /// The iterator returns the entries in their storage order in the index map.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// let entries: TypedProjVec<(usize, f64)> = opaque_map
    ///     .iter::<usize, f64, RandomState, Global>()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(entries.as_slice(), &[(1_usize, 2_f64), (2_usize, 3_f64), (3_usize, 4_f64)]);
    ///
    /// // The entries come back in storage or insertion order from the index map.
    /// for i in 0..entries.len() {
    ///     let expected = i;
    ///     let result = opaque_map.get_index_of::<_, usize, f64, RandomState, Global>(&entries[i].0).unwrap();
    ///     assert_eq!(result, expected);
    /// }
    /// ```
    #[track_caller]
    pub fn iter<K, V, S, A>(&self) -> Iter<'_, K, V>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj::<K, V, S, A>();

        proj_self.iter()
    }

    /// Returns a mutable iterator over the keys/value pairs in the index map.
    ///
    /// The iterator returns the entries in their storage order in the index map.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// Iterating over the entries of a type-erased index map without mutating them.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// let entries: TypedProjVec<(usize, f64)> = opaque_map
    ///     .iter_mut::<usize, f64, RandomState, Global>()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(entries.as_slice(), &[(1_usize, 2_f64), (2_usize, 3_f64), (3_usize, 4_f64)]);
    ///
    /// // The entries come back in storage or insertion order from the index map.
    /// for i in 0..entries.len() {
    ///     let expected = i;
    ///     let result = opaque_map.get_index_of::<_, usize, f64, RandomState, Global>(&entries[i].0).unwrap();
    ///     assert_eq!(result, expected);
    /// }
    /// ```
    ///
    /// Iterating over the entries of a type-erased index map while mutating them.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// let entries: TypedProjVec<(usize, f64)> = opaque_map
    ///     .iter_mut::<usize, f64, RandomState, Global>()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(entries.as_slice(), &[(1_usize, 2_f64), (2_usize, 3_f64), (3_usize, 4_f64)]);
    ///
    /// for (key, value) in opaque_map.iter_mut::<usize, f64, RandomState, Global>() {
    ///     *value *= 2_f64;
    /// }
    ///
    /// let new_entries: TypedProjVec<(usize, f64)> = opaque_map
    ///     .iter_mut::<usize, f64, RandomState, Global>()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(new_entries.as_slice(), &[(1_usize, 4_f64), (2_usize, 6_f64), (3_usize, 8_f64)]);
    /// ```
    #[track_caller]
    pub fn iter_mut<K, V, S, A>(&mut self) -> IterMut<'_, K, V>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.iter_mut()
    }

    /// Returns an iterator over the values in the index map.
    ///
    /// The iterator returns the values in the storage order of the entries in the index map.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// let values: TypedProjVec<f64> = opaque_map
    ///     .values::<usize, f64, RandomState, Global>()
    ///     .cloned()
    ///     .collect();
    ///
    /// assert_eq!(values.as_slice(), &[2_f64, 3_f64, 4_f64]);
    ///
    /// // The keys come back in storage or insertion order from the index map.
    /// for key in opaque_map.keys::<usize, f64, RandomState, Global>() {
    ///     let (index, _, value) = opaque_map.get_full::<_, usize, f64, RandomState, Global>(key).unwrap();
    ///     assert_eq!(&values[index], value);
    /// }
    /// ```
    #[track_caller]
    pub fn values<K, V, S, A>(&self) -> Values<'_, K, V>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj::<K, V, S, A>();

        proj_self.values()
    }

    /// Returns a mutable iterator over the values in the index map.
    ///
    /// The iterator returns the values in the storage order of the entries in the index map.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// Iterating over the entries of a type-erased index map without mutating them.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// let values: TypedProjVec<f64> = opaque_map
    ///     .values_mut::<usize, f64, RandomState, Global>()
    ///     .map(|v| v.clone())
    ///     .collect();
    ///
    /// assert_eq!(values.as_slice(), &[2_f64, 3_f64, 4_f64]);
    ///
    /// // The keys come back in storage or insertion order from the index map.
    /// for key in opaque_map.keys::<usize, f64, RandomState, Global>() {
    ///     let (index, _, value) = opaque_map.get_full::<_, usize, f64, RandomState, Global>(key).unwrap();
    ///     assert_eq!(&values[index], value);
    /// }
    /// ```
    ///
    /// Iterating over the entries of a type-erased index map while mutating them.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    ///
    /// let values: TypedProjVec<f64> = opaque_map
    ///     .values_mut::<usize, f64, RandomState, Global>()
    ///     .map(|v| v.clone())
    ///     .collect();
    ///
    /// assert_eq!(values.as_slice(), &[2_f64, 3_f64, 4_f64]);
    ///
    /// for value in opaque_map.values_mut::<usize, f64, RandomState, Global>() {
    ///     *value *= 2_f64;
    /// }
    ///
    /// let new_values: TypedProjVec<f64> = opaque_map
    ///     .values_mut::<usize, f64, RandomState, Global>()
    ///     .map(|v| v.clone())
    ///     .collect();
    ///
    /// assert_eq!(new_values.as_slice(), &[4_f64, 6_f64, 8_f64]);
    /// ```
    #[track_caller]
    pub fn values_mut<K, V, S, A>(&mut self) -> ValuesMut<'_, K, V>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.values_mut()
    }

    /// Returns a moving iterator over the values in the index map.
    ///
    /// The iterator returns the values in the storage order of the entries in the index map.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// let values: TypedProjVec<f64> = opaque_map
    ///     .clone::<usize, f64, RandomState, Global>()
    ///     .into_values::<usize, f64, RandomState, Global>()
    ///     .collect();
    ///
    /// assert_eq!(values.as_slice(), &[2_f64, 3_f64, 4_f64]);
    ///
    /// // The keys come back in storage or insertion order from the index map.
    /// for key in opaque_map.keys::<usize, f64, RandomState, Global>() {
    ///     let (index, _, value) = opaque_map.get_full::<_, usize, f64, RandomState, Global>(key).unwrap();
    ///     assert_eq!(&values[index], value);
    /// }
    /// ```
    #[track_caller]
    pub fn into_values<K, V, S, A>(self) -> IntoValues<K, V, A>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.into_proj::<K, V, S, A>();

        proj_self.into_values()
    }

    /// Removes all the entries from the index map.
    ///
    /// After calling this method, the collection will be empty. This method does not change the
    /// allocated capacity of the type-erased index map.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, and `map_after` be the state of `map` after
    /// this method completes.
    ///
    /// ## Specification Definitions
    ///
    /// We say that a key-value pair `e :: (K, V)` is an **entry** in the map `map` if and only if
    ///
    /// ```text
    /// ∀ e :: (K, V). e ∈ map ⇔ (∃ i ∈ [0, map.len()). map[i] = e).
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { true }
    /// map.clear()
    /// { map_after.len() = 0 ∧ (∀ e ∈ map_before. e ∉ map_after) }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let capacity = 10;
    /// let mut opaque_map = OpaqueIndexMap::with_capacity::<String, isize>(10);
    /// #
    /// # assert!(opaque_map.has_key_type::<String>());
    /// # assert!(opaque_map.has_value_type::<isize>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert!(opaque_map.is_empty());
    ///
    /// opaque_map.insert::<String, isize, RandomState, Global>(String::from("foo"), -1_isize);
    /// opaque_map.insert::<String, isize, RandomState, Global>(String::from("bar"),  0_isize);
    /// opaque_map.insert::<String, isize, RandomState, Global>(String::from("baz"),  1_isize);
    ///
    /// assert!(!opaque_map.is_empty());
    /// assert_eq!(opaque_map.len(), 3);
    ///
    /// let old_capacity = opaque_map.capacity();
    ///
    /// opaque_map.clear::<String, isize, RandomState, Global>();
    ///
    /// assert!(opaque_map.is_empty());
    /// assert_eq!(opaque_map.capacity(), old_capacity);
    /// ```
    #[track_caller]
    pub fn clear<K, V, S, A>(&mut self)
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.clear();
    }

    /// Shortens an index map to the supplied length, dropping the remaining elements.
    ///
    /// This method keeps the entries of `self` in the range `[0, len)`. In particular,
    /// this method drops every entry with storage index in the range `[len, self.len())`.
    /// This method does nothing when `self.len() <= len`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// Truncating a type-erased index map when `len < self.len()`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    ///     (4_usize, 5_f64),
    ///     (5_usize, 6_f64),
    ///     (6_usize, 7_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// opaque_map.truncate::<usize, f64, RandomState, Global>(2);
    ///
    /// assert_eq!(opaque_map.len(), 2);
    ///
    /// let expected = TypedProjVec::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    /// ]);
    /// let result: TypedProjVec<(usize, f64)> = opaque_map
    ///     .iter::<usize, f64, RandomState, Global>()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result, expected);
    /// ```
    ///
    /// No truncation occurs when `len == self.len()`
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    ///     (4_usize, 5_f64),
    ///     (5_usize, 6_f64),
    ///     (6_usize, 7_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// opaque_map.truncate::<usize, f64, RandomState, Global>(6);
    ///
    /// assert_eq!(opaque_map.len(), 6);
    ///
    /// let expected = TypedProjVec::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    ///     (4_usize, 5_f64),
    ///     (5_usize, 6_f64),
    ///     (6_usize, 7_f64),
    /// ]);
    /// let result: TypedProjVec<(usize, f64)> = opaque_map
    ///     .iter::<usize, f64, RandomState, Global>()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result, expected);
    /// ```
    ///
    /// No truncation occurs when `len > self.len()`
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    ///     (4_usize, 5_f64),
    ///     (5_usize, 6_f64),
    ///     (6_usize, 7_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// opaque_map.truncate::<usize, f64, RandomState, Global>(7);
    ///
    /// assert_eq!(opaque_map.len(), 6);
    ///
    /// let expected = TypedProjVec::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    ///     (4_usize, 5_f64),
    ///     (5_usize, 6_f64),
    ///     (6_usize, 7_f64),
    /// ]);
    /// let result: TypedProjVec<(usize, f64)> = opaque_map
    ///     .iter::<usize, f64, RandomState, Global>()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result, expected);
    /// ```
    ///
    /// Truncating when `len == 0` is equivalent to calling the [`clear`] method.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    ///     (4_usize, 5_f64),
    ///     (5_usize, 6_f64),
    ///     (6_usize, 7_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// opaque_map.truncate::<usize, f64, RandomState, Global>(0);
    ///
    /// assert_eq!(opaque_map.len(), 0);
    ///
    /// let expected = TypedProjVec::from([]);
    /// let result: TypedProjVec<(usize, f64)> = opaque_map
    ///     .iter::<usize, f64, RandomState, Global>()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result, expected);
    /// ```
    ///
    /// [`clear`]: TypedProjIndexMap::clear
    #[track_caller]
    pub fn truncate<K, V, S, A>(&mut self, len: usize)
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.truncate(len);
    }

    /// Removes the subslice indicated by the given range from the index map,
    /// returning a double-ended iterator over the removed subslice.
    ///
    /// If the iterator is dropped before being fully consumed, it drops the remaining removed
    /// elements. The draining iterator shifts the remaining entries in the index map above the
    /// range down to fill in the removed entries.
    ///
    /// The returned iterator keeps a mutable borrow on the index map to optimize its
    /// implementation.
    ///
    /// # Panics
    ///
    /// This method panics under one of the following conditions:
    ///
    /// * If the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    ///   `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    ///   allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    ///   type `S`, and allocator type `A`, respectively.
    /// * If the range of the subslice falls outside the bounds of the collection.
    ///   That is, if the starting point of the subslice being removed starts after the end of
    ///   `self`, or if the ending point is larger than the length of the index map.
    ///
    /// # Leaking
    ///
    /// If the returned iterator goes out of scope without being dropped (due to
    /// [`mem::forget`], for example), the index map may have lost and leaked
    /// elements arbitrarily, including elements outside the range.
    ///
    /// # Examples
    ///
    /// Draining part of a type-erased index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    ///     (4_usize, 5_f64),
    ///     (5_usize, 6_f64),
    ///     (6_usize, 7_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert_eq!(opaque_map.len(), 6);
    ///
    /// let drained_entries: TypedProjVec<(usize, f64)> = opaque_map
    ///     .drain::<_, usize, f64, RandomState, Global>(2..)
    ///     .collect();
    ///
    /// assert_eq!(opaque_map.len(), 2);
    /// assert_eq!(drained_entries.len(), 4);
    ///
    /// let expected_map_entries = TypedProjVec::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    /// ]);
    /// let result_map_entries: TypedProjVec<(usize, f64)> = opaque_map
    ///     .iter::<usize, f64, RandomState, Global>()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result_map_entries, expected_map_entries);
    ///
    /// let expected_drained_entries: TypedProjVec<(usize, f64)> = TypedProjVec::from([
    ///     (3_usize, 4_f64),
    ///     (4_usize, 5_f64),
    ///     (5_usize, 6_f64),
    ///     (6_usize, 7_f64),
    /// ]);
    ///
    /// assert_eq!(drained_entries.as_slice(), expected_drained_entries.as_slice());
    /// ```
    ///
    /// Draining an entire type-erased index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    ///     (4_usize, 5_f64),
    ///     (5_usize, 6_f64),
    ///     (6_usize, 7_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert_eq!(opaque_map.len(), 6);
    ///
    /// let drained_entries: TypedProjVec<(usize, f64)> = opaque_map
    ///     .drain::<_, usize, f64, RandomState, Global>(..)
    ///     .collect();
    ///
    /// assert_eq!(opaque_map.len(), 0);
    /// assert_eq!(drained_entries.len(), 6);
    ///
    /// let expected_map_entries = TypedProjVec::from([]);
    /// let result_map_entries: TypedProjVec<(usize, f64)> = opaque_map
    ///     .iter::<usize, f64, RandomState, Global>()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result_map_entries, expected_map_entries);
    ///
    /// let expected_drained_entries: TypedProjVec<(usize, f64)> = TypedProjVec::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    ///     (4_usize, 5_f64),
    ///     (5_usize, 6_f64),
    ///     (6_usize, 7_f64),
    /// ]);
    ///
    /// assert_eq!(drained_entries.as_slice(), expected_drained_entries.as_slice());
    /// ```
    ///
    /// Draining no part of a type-erased index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    ///     (4_usize, 5_f64),
    ///     (5_usize, 6_f64),
    ///     (6_usize, 7_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert_eq!(opaque_map.len(), 6);
    ///
    /// let drained_entries: TypedProjVec<(usize, f64)> = opaque_map
    ///     .drain::<_, usize, f64, RandomState, Global>(0..0)
    ///     .collect();
    ///
    /// assert_eq!(opaque_map.len(), 6);
    /// assert_eq!(drained_entries.len(), 0);
    ///
    /// let expected_map_entries: TypedProjVec<(usize, f64)> = TypedProjVec::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    ///     (4_usize, 5_f64),
    ///     (5_usize, 6_f64),
    ///     (6_usize, 7_f64),
    /// ]);
    /// let result_map_entries: TypedProjVec<(usize, f64)> = opaque_map
    ///     .iter::<usize, f64, RandomState, Global>()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result_map_entries, expected_map_entries);
    ///
    /// let expected_drained_entries: TypedProjVec<(usize, f64)> = TypedProjVec::from([]);
    ///
    /// assert_eq!(drained_entries.as_slice(), expected_drained_entries.as_slice());
    /// ```
    #[track_caller]
    pub fn drain<R, K, V, S, A>(&mut self, range: R) -> Drain<'_, K, V, A>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
        R: ops::RangeBounds<usize>,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.drain(range)
    }

    /// Splits a type-erased index map into two type-erased index maps at the given index.
    ///
    /// This method returns a newly allocated type-erased index map consisting of every entry
    /// from the original type-erased index map in the storage range `[at, len)`. The original
    /// type-erased index map will consist of the entries in the range `[0, at)` with its
    /// capacity unchanged.
    ///
    /// # Panics
    ///
    /// This method panics under one of the following conditions:
    ///
    /// * If the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    ///  `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    ///   allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    ///   type `S`, and allocator type `A`, respectively.
    /// * If the splitting index `at > self.len()`.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    ///     (4_usize, 5_f64),
    ///     (5_usize, 6_f64),
    ///     (6_usize, 7_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert_eq!(opaque_map.len(), 6);
    ///
    /// let old_capacity = opaque_map.capacity();
    /// let opaque_split_map = opaque_map.split_off::<usize, f64, RandomState, Global>(4);
    /// #
    /// # assert!(opaque_split_map.has_key_type::<usize>());
    /// # assert!(opaque_split_map.has_value_type::<f64>());
    /// # assert!(opaque_split_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_split_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert_eq!(opaque_map.len(), 4);
    /// assert_eq!(opaque_map.capacity(), old_capacity);
    ///
    /// let expected_opaque_map_entries: TypedProjVec<(usize, f64)> = TypedProjVec::from([
    ///     (1_usize, 2_f64),
    ///     (2_usize, 3_f64),
    ///     (3_usize, 4_f64),
    ///     (4_usize, 5_f64),
    /// ]);
    /// let result_opaque_map_entries: TypedProjVec<(usize, f64)> = opaque_map
    ///     .iter::<usize, f64, RandomState, Global>()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result_opaque_map_entries, expected_opaque_map_entries);
    ///
    /// assert_eq!(opaque_split_map.len(), 2);
    ///
    /// let expected_split_map_entries: TypedProjVec<(usize, f64)> = TypedProjVec::from([
    ///     (5_usize, 6_f64),
    ///     (6_usize, 7_f64),
    /// ]);
    /// let result_split_map_entries: TypedProjVec<(usize, f64)> = opaque_split_map
    ///     .iter::<usize, f64, RandomState, Global>()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result_split_map_entries, expected_split_map_entries);
    /// ```
    #[must_use = "use `.truncate()` if you don't need the other map"]
    #[track_caller]
    pub fn split_off<K, V, S, A>(&mut self, at: usize) -> Self
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync + Clone,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync + Clone,
    {
        let proj_self =  self.as_proj_mut::<K, V, S, A>();
        let proj_split = proj_self.split_off(at);

        Self::from_proj(proj_split)
    }

    /// Removes an entry from a type-erased index map, moving the last entry in storage order in
    /// the collection to the index where the removed entry occupies the collection.
    ///
    /// This method behaves with respect to the lookup key `key` as follows:
    ///
    /// * If the equivalent key to `key` exists in the index map, let `index` be its storage index.
    ///   If `index < self.len() - 1`, it moves the last entry in the collection to the slot at
    ///   `index`, leaving the rest of the entries in place. If `index == self.len() - 1`, it
    ///   removes the entry from end of the collection with no reordering of the remaining entries
    ///   in the collection. The method then returns `Some(value)`, where `value` is the value
    ///   stored in the index map corresponding to the equivalent key to `key`.
    /// * If the equivalent key to `key` does not exist in the index map, the method returns
    ///   `None`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Hashing And Equivalence
    ///
    /// A **hashing type** is a triple `(X, ~, h)` where `~` is an equivalence relation on
    /// `X`, and `h` is a hash function such that
    ///
    /// ```text
    /// ∀ a :: X. ∀ b :: X. a ~ b ⇒ h(a) = h(b).
    /// ```
    ///
    /// A type `X` is a **hashable type** if there is an equivalence relation `~` and a hashing
    /// function `h` such that `(X, ~, h)` is a hashing type.
    ///
    /// Let `K` be the type of the keys of the index map `map`. Let `Q` be a data type. Let
    /// `q :: Q` be a value of type `Q`, and let `k :: K` be a key. let `X` be a hashable type. Let
    /// `f: Q → X` and `g: K → X` be functions. We say that
    /// **`q` is equivalent to `k` using `f` and `g`** if and only if
    ///
    /// ```test
    /// equiv(X, f, g)(q, k) := f(q) ∼ g(k).
    /// ```
    ///
    /// Note that by the definition of `~`
    ///
    /// ```text
    /// ∀ q :: Q. ∀ k :: K. f(q) ∼ g(k) ⇒ h(f(q)) = h(g(k)).
    /// ```
    ///
    /// This is an implication, not an equivalence, because practical hashing functions can have
    /// collisions, i.e. for a practical hashing function `h`,
    /// `∃ a, b :: X. ¬(a ~ b) ∧ h(a) = h(b)`. We say that the type
    /// **`Q` is equivalent to `K` using `f` and `g`** if and only if
    ///
    /// ```text
    /// equiv(X, f, g)(Q, K) :=
    ///     (∀ q :: Q. ∃ k :: K. equiv(X, f, g)(q, k))
    ///     ∧ (∀ k :: K. ∃ q :: Q. equiv(X, f, g)(q, k)).
    /// ```
    ///
    /// Let `X` be a hashable type. Then the type **`Q` is equivalent to the type `K` using `X`**
    /// if and only if
    ///
    /// ```text
    /// equiv(X, Q, K) := ∃ f: Q → X. ∃ g: K → X. equiv(X, f, g)(Q, K).
    /// ```
    ///
    /// Key equality is a special case of key equivalence. Let `K` be a hashable data type. Let
    /// `Q = K`, and `f = g = id`. Then
    ///
    /// ```text
    /// ∀ k1, k2 :: K. k1 = k2 = id(k1) = id(k2) ⇒ h(id(k1)) = h(id(k2)) = h(k1) = h(k2)
    /// ```
    ///
    /// so that we have `equiv(K, id, id)(K, K)` which implies `equiv(K, K, K)`, i.e. `K` is
    /// equivalent to `K` using `K` when `K` is a hashable type.
    ///
    /// Let `Q` be a type equivalent to the key type `K` using `K`. Let `f: Q → K` and `id: K → K`
    /// be the identity. We say that **`q` is equivalent to `k`** if and only if
    ///
    /// ```text
    /// equiv(q, k) := equiv(K, f, id)(q, k).
    /// ```
    ///
    /// Let `Q` be a data type equivalent to key type `K` using `K`. We say that `q` is an
    /// **equivalent element of** the map `map`, or that **`map` equivalently contains `q`** if and
    /// only if
    ///
    /// ```text
    /// q ~∈ map ⇔ ∃ i ∈ [0, map.len()). equiv(q, map[i].key()).
    /// ```
    ///
    /// If `q` is not an equivalent element of `map`, we write `q ~∉ map`.
    ///
    /// When `K` is a hashable type, we see that `k ~∈ map ⇔ k ∈ map`, so that equivalent
    /// containment indeed generalizes containment.
    ///
    /// ## Specification Definitions
    ///
    /// The set of **keys** in the map `map` is defined as
    ///
    /// ```text
    /// keys(map) := { k :: K | ∃ i ∈ [0, map.len()). map[i].key() = k }
    /// ```
    ///
    /// or equivalently
    ///
    /// ```text
    /// ∀ k :: K. (k ∈ keys(map)) ⇔ (∃ i ∈ [0, map.len()). map[i].key() = k).
    /// ```
    ///
    /// We also say that a key `k` is in the map `map` provided that
    ///
    /// ```text
    /// ∀ k :: K. k ∈ map ⇔ k ∈ keys(map).
    /// ```
    ///
    /// We say that two maps `map1` and `map2` are **equal** if and only if
    ///
    /// ```text
    /// map1 = map2 ⇔ (map1.len() = map2.len()) ∧ (∀ i ∈ [0, map1.len()). map1[i] = map2[i]).
    /// ```
    ///
    /// The **index** of an equivalent key `q :: Q` in `map` is defined by
    ///
    /// ```text
    /// index(map, q) := i such that equiv(q, map[i].key()).
    /// ```
    ///
    /// The **last entry** in the map `map` when `map` is non-empty is defined by
    ///
    /// ```text
    /// last(map) := map[map.len() - 1].
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ~∈ map_before }
    /// map.swap_remove(key)
    /// {
    ///     result = Some(map_before[index(map, key)])
    ///     ∧ map_after.len() = map_before.len() - 1
    ///     ∧ key ~∉ map_after
    ///     ∧ (map_after[index(map_before, key)] = last(map_before)
    ///       ∧ (∀ k ∈ keys(map_after). k ≠ last(map_before).key() ∧ ¬equiv(key, k)
    ///         ⇒ map_after[index(map_after, k)] = map_before[index(map_before, k)]
    ///       )
    ///     )
    /// }
    ///
    /// { key ~∉ map_before }
    /// map.swap_remove(key)
    /// { result = None ∧ map_after = map_before }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// Showing how swap removal happens.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    ///     (isize::MAX, f64::MAX),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<isize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// {
    ///     let expected = OpaqueIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (2_isize, 3_f64),
    ///         (3_isize, 4_f64),
    ///     ]);
    /// #
    /// #   assert!(expected.has_key_type::<isize>());
    /// #   assert!(expected.has_value_type::<f64>());
    /// #   assert!(expected.has_build_hasher_type::<RandomState>());
    /// #   assert!(expected.has_allocator_type::<Global>());
    /// #
    ///     let mut result = opaque_map.clone::<isize, f64, RandomState, Global>();
    /// #
    /// #   assert!(result.has_key_type::<isize>());
    /// #   assert!(result.has_value_type::<f64>());
    /// #   assert!(result.has_build_hasher_type::<RandomState>());
    /// #   assert!(result.has_allocator_type::<Global>());
    /// #
    ///     let removed = result.swap_remove::<_, isize, f64, RandomState, Global>(&isize::MAX);
    ///     assert_eq!(result.as_slice::<isize, f64, RandomState, Global>(), expected.as_slice::<isize, f64, RandomState, Global>());
    ///     assert_eq!(removed, Some(f64::MAX));
    /// }
    /// {
    ///     let expected = OpaqueIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (2_isize, 3_f64),
    ///         (isize::MAX, f64::MAX),
    ///     ]);
    /// #
    /// #   assert!(expected.has_key_type::<isize>());
    /// #   assert!(expected.has_value_type::<f64>());
    /// #   assert!(expected.has_build_hasher_type::<RandomState>());
    /// #   assert!(expected.has_allocator_type::<Global>());
    /// #
    ///     let mut result = opaque_map.clone::<isize, f64, RandomState, Global>();
    /// #
    /// #   assert!(result.has_key_type::<isize>());
    /// #   assert!(result.has_value_type::<f64>());
    /// #   assert!(result.has_build_hasher_type::<RandomState>());
    /// #   assert!(result.has_allocator_type::<Global>());
    /// #
    ///     let removed = result.swap_remove::<_, isize, f64, RandomState, Global>(&3_isize);
    ///     assert_eq!(result.as_slice::<isize, f64, RandomState, Global>(), expected.as_slice::<isize, f64, RandomState, Global>());
    ///     assert_eq!(removed, Some(4_f64));
    /// }
    /// {
    ///     let expected = OpaqueIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (isize::MAX, f64::MAX),
    ///         (3_isize, 4_f64),
    ///     ]);
    /// #
    /// #   assert!(expected.has_key_type::<isize>());
    /// #   assert!(expected.has_value_type::<f64>());
    /// #   assert!(expected.has_build_hasher_type::<RandomState>());
    /// #   assert!(expected.has_allocator_type::<Global>());
    /// #
    ///     let mut result = opaque_map.clone::<isize, f64, RandomState, Global>();
    /// #
    /// #   assert!(result.has_key_type::<isize>());
    /// #   assert!(result.has_value_type::<f64>());
    /// #   assert!(result.has_build_hasher_type::<RandomState>());
    /// #   assert!(result.has_allocator_type::<Global>());
    /// #
    ///     let removed = result.swap_remove::<_, isize, f64, RandomState, Global>(&2_isize);
    ///     assert_eq!(result.as_slice::<isize, f64, RandomState, Global>(), expected.as_slice::<isize, f64, RandomState, Global>());
    ///     assert_eq!(removed, Some(3_f64));
    /// }
    /// {
    ///     let expected = OpaqueIndexMap::from([
    ///         (isize::MAX, f64::MAX),
    ///         (2_isize, 3_f64),
    ///         (3_isize, 4_f64),
    ///     ]);
    /// #
    /// #   assert!(expected.has_key_type::<isize>());
    /// #   assert!(expected.has_value_type::<f64>());
    /// #   assert!(expected.has_build_hasher_type::<RandomState>());
    /// #   assert!(expected.has_allocator_type::<Global>());
    /// #
    ///     let mut result = opaque_map.clone::<isize, f64, RandomState, Global>();
    /// #
    /// #   assert!(result.has_key_type::<isize>());
    /// #   assert!(result.has_value_type::<f64>());
    /// #   assert!(result.has_build_hasher_type::<RandomState>());
    /// #   assert!(result.has_allocator_type::<Global>());
    /// #
    ///     let removed = result.swap_remove::<_, isize, f64, RandomState, Global>(&1_isize);
    ///     assert_eq!(result.as_slice::<isize, f64, RandomState, Global>(), expected.as_slice::<isize, f64, RandomState, Global>());
    ///     assert_eq!(removed, Some(2_f64));
    /// }
    /// ```
    #[track_caller]
    pub fn swap_remove<Q, K, V, S, A>(&mut self, key: &Q) -> Option<V>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
        Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.swap_remove(key)
    }

    /// Removes an entry from a type-erased index map, moving the last entry in storage order in
    /// the collection to the index where the removed entry occupies the collection.
    ///
    /// This method behaves with respect to the lookup key `key` as follows:
    ///
    /// * If the equivalent key to `key` exists in the index map, let `index` be its storage index.
    ///   If `index < self.len() - 1`, it moves the last entry in the collection to the slot at
    ///   `index`, leaving the rest of the entries in place. If `index == self.len() - 1`, it
    ///   removes the entry from end of the collection with no reordering of the remaining entries
    ///   in the collection. The method then returns `Some((eq_key, value))`, where
    ///   `(eq_key, value)` is the key-value pair with equivalent key `eq_key` to `key` in the
    ///   index map.
    /// * If the equivalent key to `key` does not exist in the index map, the method returns
    ///   `None`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Hashing And Equivalence
    ///
    /// A **hashing type** is a triple `(X, ~, h)` where `~` is an equivalence relation on
    /// `X`, and `h` is a hash function such that
    ///
    /// ```text
    /// ∀ a :: X. ∀ b :: X. a ~ b ⇒ h(a) = h(b).
    /// ```
    ///
    /// A type `X` is a **hashable type** if there is an equivalence relation `~` and a hashing
    /// function `h` such that `(X, ~, h)` is a hashing type.
    ///
    /// Let `K` be the type of the keys of the index map `map`. Let `Q` be a data type. Let
    /// `q :: Q` be a value of type `Q`, and let `k :: K` be a key. let `X` be a hashable type. Let
    /// `f: Q → X` and `g: K → X` be functions. We say that
    /// **`q` is equivalent to `k` using `f` and `g`** if and only if
    ///
    /// ```test
    /// equiv(X, f, g)(q, k) := f(q) ∼ g(k).
    /// ```
    ///
    /// Note that by the definition of `~`
    ///
    /// ```text
    /// ∀ q :: Q. ∀ k :: K. f(q) ∼ g(k) ⇒ h(f(q)) = h(g(k)).
    /// ```
    ///
    /// This is an implication, not an equivalence, because practical hashing functions can have
    /// collisions, i.e. for a practical hashing function `h`,
    /// `∃ a, b :: X. ¬(a ~ b) ∧ h(a) = h(b)`. We say that the type
    /// **`Q` is equivalent to `K` using `f` and `g`** if and only if
    ///
    /// ```text
    /// equiv(X, f, g)(Q, K) :=
    ///     (∀ q :: Q. ∃ k :: K. equiv(X, f, g)(q, k))
    ///     ∧ (∀ k :: K. ∃ q :: Q. equiv(X, f, g)(q, k)).
    /// ```
    ///
    /// Let `X` be a hashable type. Then the type **`Q` is equivalent to the type `K` using `X`**
    /// if and only if
    ///
    /// ```text
    /// equiv(X, Q, K) := ∃ f: Q → X. ∃ g: K → X. equiv(X, f, g)(Q, K).
    /// ```
    ///
    /// Key equality is a special case of key equivalence. Let `K` be a hashable data type. Let
    /// `Q = K`, and `f = g = id`. Then
    ///
    /// ```text
    /// ∀ k1, k2 :: K. k1 = k2 = id(k1) = id(k2) ⇒ h(id(k1)) = h(id(k2)) = h(k1) = h(k2)
    /// ```
    ///
    /// so that we have `equiv(K, id, id)(K, K)` which implies `equiv(K, K, K)`, i.e. `K` is
    /// equivalent to `K` using `K` when `K` is a hashable type.
    ///
    /// Let `Q` be a type equivalent to the key type `K` using `K`. Let `f: Q → K` and `id: K → K`
    /// be the identity. We say that **`q` is equivalent to `k`** if and only if
    ///
    /// ```text
    /// equiv(q, k) := equiv(K, f, id)(q, k).
    /// ```
    ///
    /// Let `Q` be a data type equivalent to key type `K` using `K`. We say that `q` is an
    /// **equivalent element of** the map `map`, or that **`map` equivalently contains `q`** if and
    /// only if
    ///
    /// ```text
    /// q ~∈ map ⇔ ∃ i ∈ [0, map.len()). equiv(q, map[i].key()).
    /// ```
    ///
    /// If `q` is not an equivalent element of `map`, we write `q ~∉ map`.
    ///
    /// When `K` is a hashable type, we see that `k ~∈ map ⇔ k ∈ map`, so that equivalent
    /// containment indeed generalizes containment.
    ///
    /// ## Specification Definitions
    ///
    /// The set of **keys** in the map `map` is defined as
    ///
    /// ```text
    /// keys(map) := { k :: K | ∃ i ∈ [0, map.len()). map[i].key() = k }
    /// ```
    ///
    /// or equivalently
    ///
    /// ```text
    /// ∀ k :: K. (k ∈ keys(map)) ⇔ (∃ i ∈ [0, map.len()). map[i].key() = k).
    /// ```
    ///
    /// We also say that a key `k` is in the map `map` provided that
    ///
    /// ```text
    /// ∀ k :: K. k ∈ map ⇔ k ∈ keys(map).
    /// ```
    ///
    /// We say that two maps `map1` and `map2` are **equal** if and only if
    ///
    /// ```text
    /// map1 = map2 ⇔ (map1.len() = map2.len()) ∧ (∀ i ∈ [0, map1.len()). map1[i] = map2[i]).
    /// ```
    ///
    /// The **index** of an equivalent key `q` in `map` is defined by
    ///
    /// ```text
    /// index(map, q) := i such that equiv(q, map[i].key()).
    /// ```
    ///
    /// The **last entry** in the map `map` when `map` is non-empty is defined by
    ///
    /// ```text
    /// last(map) := map[map.len() - 1].
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ~∈ map_before }
    /// map.swap_remove_entry(key)
    /// {
    ///     result = Some(map_before[index(map_before, key)])
    ///     ∧ map_after.len() = map_before.len() - 1
    ///     ∧ key ~∉ map_after
    ///     ∧ (map_after[index(map_before, key)] = last(map_before)
    ///       ∧ (∀ k ∈ keys(map_after). k ≠ last(map_before).key() ∧ ¬equiv(key, k)
    ///         ⇒ index(map_after, k) ≠ index(map_before, k)
    ///         ∧ map_after[index(map_after, k)] = map_before[index(map_before, k)]
    ///       )
    ///     )
    /// }
    ///
    /// { key ~∉ map_before }
    /// map.swap_remove_entry(key)
    /// { result = None ∧ map_after = map_before }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// Showing how swap removal happens.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    ///     (isize::MAX, f64::MAX),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<isize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// {
    ///     let expected = OpaqueIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (2_isize, 3_f64),
    ///         (3_isize, 4_f64),
    ///     ]);
    /// #
    /// #   assert!(expected.has_key_type::<isize>());
    /// #   assert!(expected.has_value_type::<f64>());
    /// #   assert!(expected.has_build_hasher_type::<RandomState>());
    /// #   assert!(expected.has_allocator_type::<Global>());
    /// #
    ///     let mut result = opaque_map.clone::<isize, f64, RandomState, Global>();
    /// #
    /// #   assert!(result.has_key_type::<isize>());
    /// #   assert!(result.has_value_type::<f64>());
    /// #   assert!(result.has_build_hasher_type::<RandomState>());
    /// #   assert!(result.has_allocator_type::<Global>());
    /// #
    ///     let removed = result.swap_remove_entry::<_, isize, f64, RandomState, Global>(&isize::MAX);
    ///     assert_eq!(result.as_slice::<isize, f64, RandomState, Global>(), expected.as_slice::<isize, f64, RandomState, Global>());
    ///     assert_eq!(removed, Some((isize::MAX, f64::MAX)));
    /// }
    /// {
    ///     let expected = OpaqueIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (2_isize, 3_f64),
    ///         (isize::MAX, f64::MAX),
    ///     ]);
    /// #
    /// #   assert!(expected.has_key_type::<isize>());
    /// #   assert!(expected.has_value_type::<f64>());
    /// #   assert!(expected.has_build_hasher_type::<RandomState>());
    /// #   assert!(expected.has_allocator_type::<Global>());
    /// #
    ///     let mut result = opaque_map.clone::<isize, f64, RandomState, Global>();
    /// #
    /// #   assert!(result.has_key_type::<isize>());
    /// #   assert!(result.has_value_type::<f64>());
    /// #   assert!(result.has_build_hasher_type::<RandomState>());
    /// #   assert!(result.has_allocator_type::<Global>());
    /// #
    ///     let removed = result.swap_remove_entry::<_, isize, f64, RandomState, Global>(&3_isize);
    ///     assert_eq!(result.as_slice::<isize, f64, RandomState, Global>(), expected.as_slice::<isize, f64, RandomState, Global>());
    ///     assert_eq!(removed, Some((3_isize, 4_f64)));
    /// }
    /// {
    ///     let expected = OpaqueIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (isize::MAX, f64::MAX),
    ///         (3_isize, 4_f64),
    ///     ]);
    /// #
    /// #   assert!(expected.has_key_type::<isize>());
    /// #   assert!(expected.has_value_type::<f64>());
    /// #   assert!(expected.has_build_hasher_type::<RandomState>());
    /// #   assert!(expected.has_allocator_type::<Global>());
    /// #
    ///     let mut result = opaque_map.clone::<isize, f64, RandomState, Global>();
    /// #
    /// #   assert!(result.has_key_type::<isize>());
    /// #   assert!(result.has_value_type::<f64>());
    /// #   assert!(result.has_build_hasher_type::<RandomState>());
    /// #   assert!(result.has_allocator_type::<Global>());
    /// #
    ///     let removed = result.swap_remove_entry::<_, isize, f64, RandomState, Global>(&2_isize);
    ///     assert_eq!(result.as_slice::<isize, f64, RandomState, Global>(), expected.as_slice::<isize, f64, RandomState, Global>());
    ///     assert_eq!(removed, Some((2_isize, 3_f64)));
    /// }
    /// {
    ///     let expected = OpaqueIndexMap::from([
    ///         (isize::MAX, f64::MAX),
    ///         (2_isize, 3_f64),
    ///         (3_isize, 4_f64),
    ///     ]);
    /// #
    /// #   assert!(expected.has_key_type::<isize>());
    /// #   assert!(expected.has_value_type::<f64>());
    /// #   assert!(expected.has_build_hasher_type::<RandomState>());
    /// #   assert!(expected.has_allocator_type::<Global>());
    /// #
    ///     let mut result = opaque_map.clone::<isize, f64, RandomState, Global>();
    /// #
    /// #   assert!(result.has_key_type::<isize>());
    /// #   assert!(result.has_value_type::<f64>());
    /// #   assert!(result.has_build_hasher_type::<RandomState>());
    /// #   assert!(result.has_allocator_type::<Global>());
    /// #
    ///     let removed = result.swap_remove_entry::<_, isize, f64, RandomState, Global>(&1_isize);
    ///     assert_eq!(result.as_slice::<isize, f64, RandomState, Global>(), expected.as_slice::<isize, f64, RandomState, Global>());
    ///     assert_eq!(removed, Some((1_isize, 2_f64)));
    /// }
    /// ```
    #[track_caller]
    pub fn swap_remove_entry<Q, K, V, S, A>(&mut self, key: &Q) -> Option<(K, V)>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
        Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.swap_remove_entry(key)
    }

    /// Removes an entry from a type-erased index map, moving the last entry in storage order in
    /// the collection to the index where the removed entry occupies the collection.
    ///
    /// This method behaves with respect to the lookup key `key` as follows:
    ///
    /// * If the equivalent key to `key` exists in the index map, let `index` be its storage index.
    ///   If `index < self.len() - 1`, it moves the last entry in the collection to the slot at
    ///   `index`, leaving the rest of the entries in place. If `index == self.len() - 1`, it
    ///   removes the entry from end of the collection with no reordering of the remaining entries
    ///   in the collection. The method then returns `Some((index, eq_key, value))`, where
    ///   `(eq_key, value)` is the key-value pair with the equivalent key `eq_key` to `key `stored
    ///   in the index map.
    /// * If the equivalent key to `key` does not exist in the index map, the method returns
    ///   `None`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Hashing And Equivalence
    ///
    /// A **hashing type** is a triple `(X, ~, h)` where `~` is an equivalence relation on
    /// `X`, and `h` is a hash function such that
    ///
    /// ```text
    /// ∀ a :: X. ∀ b :: X. a ~ b ⇒ h(a) = h(b).
    /// ```
    ///
    /// A type `X` is a **hashable type** if there is an equivalence relation `~` and a hashing
    /// function `h` such that `(X, ~, h)` is a hashing type.
    ///
    /// Let `K` be the type of the keys of the index map `map`. Let `Q` be a data type. Let
    /// `q :: Q` be a value of type `Q`, and let `k :: K` be a key. let `X` be a hashable type. Let
    /// `f: Q → X` and `g: K → X` be functions. We say that
    /// **`q` is equivalent to `k` using `f` and `g`** if and only if
    ///
    /// ```test
    /// equiv(X, f, g)(q, k) := f(q) ∼ g(k).
    /// ```
    ///
    /// Note that by the definition of `~`
    ///
    /// ```text
    /// ∀ q :: Q. ∀ k :: K. f(q) ∼ g(k) ⇒ h(f(q)) = h(g(k)).
    /// ```
    ///
    /// This is an implication, not an equivalence, because practical hashing functions can have
    /// collisions, i.e. for a practical hashing function `h`,
    /// `∃ a, b :: X. ¬(a ~ b) ∧ h(a) = h(b)`. We say that the type
    /// **`Q` is equivalent to `K` using `f` and `g`** if and only if
    ///
    /// ```text
    /// equiv(X, f, g)(Q, K) :=
    ///     (∀ q :: Q. ∃ k :: K. equiv(X, f, g)(q, k))
    ///     ∧ (∀ k :: K. ∃ q :: Q. equiv(X, f, g)(q, k)).
    /// ```
    ///
    /// Let `X` be a hashable type. Then the type **`Q` is equivalent to the type `K` using `X`**
    /// if and only if
    ///
    /// ```text
    /// equiv(X, Q, K) := ∃ f: Q → X. ∃ g: K → X. equiv(X, f, g)(Q, K).
    /// ```
    ///
    /// Key equality is a special case of key equivalence. Let `K` be a hashable data type. Let
    /// `Q = K`, and `f = g = id`. Then
    ///
    /// ```text
    /// ∀ k1, k2 :: K. k1 = k2 = id(k1) = id(k2) ⇒ h(id(k1)) = h(id(k2)) = h(k1) = h(k2)
    /// ```
    ///
    /// so that we have `equiv(K, id, id)(K, K)` which implies `equiv(K, K, K)`, i.e. `K` is
    /// equivalent to `K` using `K` when `K` is a hashable type.
    ///
    /// Let `Q` be a type equivalent to the key type `K` using `K`. Let `f: Q → K` and `id: K → K`
    /// be the identity. We say that **`q` is equivalent to `k`** if and only if
    ///
    /// ```text
    /// equiv(q, k) := equiv(K, f, id)(q, k).
    /// ```
    ///
    /// Let `Q` be a data type equivalent to key type `K` using `K`. We say that `q` is an
    /// **equivalent element of** the map `map`, or that **`map` equivalently contains `q`** if and
    /// only if
    ///
    /// ```text
    /// q ~∈ map ⇔ ∃ i ∈ [0, map.len()). equiv(q, map[i].key()).
    /// ```
    ///
    /// If `q` is not an equivalent element of `map`, we write `q ~∉ map`.
    ///
    /// When `K` is a hashable type, we see that `k ~∈ map ⇔ k ∈ map`, so that equivalent
    /// containment indeed generalizes containment.
    ///
    /// ## Specification Definitions
    ///
    /// The set of **keys** in the map `map` is defined as
    ///
    /// ```text
    /// keys(map) := { k :: K | ∃ i ∈ [0, map.len()). map[i].key() = k }
    /// ```
    ///
    /// or equivalently
    ///
    /// ```text
    /// ∀ k :: K. (k ∈ keys(map)) ⇔ (∃ i ∈ [0, map.len()). map[i].key() = k).
    /// ```
    ///
    /// We also say that a key `k` is in the map `map` provided that
    ///
    /// ```text
    /// ∀ k :: K. k ∈ map ⇔ k ∈ keys(map).
    /// ```
    ///
    /// We say that two maps `map1` and `map2` are **equal** if and only if
    ///
    /// ```text
    /// map1 = map2 ⇔ (map1.len() = map2.len()) ∧ (∀ i ∈ [0, map1.len()). map1[i] = map2[i]).
    /// ```
    ///
    /// The **index** of an equivalent key `q` in `map` is defined by
    ///
    /// ```text
    /// index(map, q) := i such that equiv(q, map[i].key()).
    /// ```
    ///
    /// The **last entry** in the map `map` when `map` is non-empty is defined by
    ///
    /// ```text
    /// last(map) := map[map.len() - 1].
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ~∈ map_before }
    /// map.swap_remove_full(key)
    /// {
    ///     result = Some(map_before[index(map_before, key)])
    ///     ∧ map_after.len() = map_before.len() - 1
    ///     ∧ key ~∉ map_after
    ///     ∧ (map_after[index(map_before, key)] = last(map_before)
    ///       ∧ (∀ k ∈ keys(map_after). k ≠ last(map_before).key() ∧ ¬equiv(key, k)
    ///         ⇒ index(map_after, k) = index(map_before, k)
    ///         ∧ map_after[index(map_after, k)] = map_before[index(map_before, k)]
    ///       )
    ///     )
    /// }
    ///
    /// { key ~∉ map_before }
    /// map.swap_remove_full(key)
    /// { result = None ∧ map_after = map_before }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// Showing how swap removal happens.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    ///     (isize::MAX, f64::MAX),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<isize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// {
    ///     let expected = OpaqueIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (2_isize, 3_f64),
    ///         (3_isize, 4_f64),
    ///     ]);
    /// #
    /// #   assert!(expected.has_key_type::<isize>());
    /// #   assert!(expected.has_value_type::<f64>());
    /// #   assert!(expected.has_build_hasher_type::<RandomState>());
    /// #   assert!(expected.has_allocator_type::<Global>());
    /// #
    ///     let mut result = opaque_map.clone::<isize, f64, RandomState, Global>();
    /// #
    /// #   assert!(result.has_key_type::<isize>());
    /// #   assert!(result.has_value_type::<f64>());
    /// #   assert!(result.has_build_hasher_type::<RandomState>());
    /// #   assert!(result.has_allocator_type::<Global>());
    /// #
    ///     let removed = result.swap_remove_full::<_, isize, f64, RandomState, Global>(&isize::MAX);
    ///     assert_eq!(result.as_slice::<isize, f64, RandomState, Global>(), expected.as_slice::<isize, f64, RandomState, Global>());
    ///     assert_eq!(removed, Some((3, isize::MAX, f64::MAX)));
    /// }
    /// {
    ///     let expected = OpaqueIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (2_isize, 3_f64),
    ///         (isize::MAX, f64::MAX),
    ///     ]);
    /// #
    /// #   assert!(expected.has_key_type::<isize>());
    /// #   assert!(expected.has_value_type::<f64>());
    /// #   assert!(expected.has_build_hasher_type::<RandomState>());
    /// #   assert!(expected.has_allocator_type::<Global>());
    /// #
    ///     let mut result = opaque_map.clone::<isize, f64, RandomState, Global>();
    /// #
    /// #   assert!(result.has_key_type::<isize>());
    /// #   assert!(result.has_value_type::<f64>());
    /// #   assert!(result.has_build_hasher_type::<RandomState>());
    /// #   assert!(result.has_allocator_type::<Global>());
    /// #
    ///     let removed = result.swap_remove_full::<_, isize, f64, RandomState, Global>(&3_isize);
    ///     assert_eq!(result.as_slice::<isize, f64, RandomState, Global>(), expected.as_slice::<isize, f64, RandomState, Global>());
    ///     assert_eq!(removed, Some((2, 3_isize, 4_f64)));
    /// }
    /// {
    ///     let expected = OpaqueIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (isize::MAX, f64::MAX),
    ///         (3_isize, 4_f64),
    ///     ]);
    /// #
    /// #   assert!(expected.has_key_type::<isize>());
    /// #   assert!(expected.has_value_type::<f64>());
    /// #   assert!(expected.has_build_hasher_type::<RandomState>());
    /// #   assert!(expected.has_allocator_type::<Global>());
    /// #
    ///     let mut result = opaque_map.clone::<isize, f64, RandomState, Global>();
    /// #
    /// #   assert!(result.has_key_type::<isize>());
    /// #   assert!(result.has_value_type::<f64>());
    /// #   assert!(result.has_build_hasher_type::<RandomState>());
    /// #   assert!(result.has_allocator_type::<Global>());
    /// #
    ///     let removed = result.swap_remove_full::<_, isize, f64, RandomState, Global>(&2_isize);
    ///     assert_eq!(result.as_slice::<isize, f64, RandomState, Global>(), expected.as_slice::<isize, f64, RandomState, Global>());
    ///     assert_eq!(removed, Some((1, 2_isize, 3_f64)));
    /// }
    /// {
    ///     let expected = OpaqueIndexMap::from([
    ///         (isize::MAX, f64::MAX),
    ///         (2_isize, 3_f64),
    ///         (3_isize, 4_f64),
    ///     ]);
    /// #
    /// #   assert!(expected.has_key_type::<isize>());
    /// #   assert!(expected.has_value_type::<f64>());
    /// #   assert!(expected.has_build_hasher_type::<RandomState>());
    /// #   assert!(expected.has_allocator_type::<Global>());
    /// #
    ///     let mut result = opaque_map.clone::<isize, f64, RandomState, Global>();
    /// #
    /// #   assert!(result.has_key_type::<isize>());
    /// #   assert!(result.has_value_type::<f64>());
    /// #   assert!(result.has_build_hasher_type::<RandomState>());
    /// #   assert!(result.has_allocator_type::<Global>());
    /// #
    ///     let removed = result.swap_remove_full::<_, isize, f64, RandomState, Global>(&1_isize);
    ///     assert_eq!(result.as_slice::<isize, f64, RandomState, Global>(), expected.as_slice::<isize, f64, RandomState, Global>());
    ///     assert_eq!(removed, Some((0, 1_isize, 2_f64)));
    /// }
    /// ```
    #[track_caller]
    pub fn swap_remove_full<Q, K, V, S, A>(&mut self, key: &Q) -> Option<(usize, K, V)>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
        Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.swap_remove_full(key)
    }

    /// Removes an entry from a type-erased index map, shifting every successive entry in the
    /// collection in storage order down one index to fill where the removed entry occupies the
    /// collection.
    ///
    /// This method behaves with respect to the lookup key `key` as follows:
    ///
    /// * If the equivalent key to `key` exists in the index map, let `index` be its storage index.
    ///   If `index < self.len() - 1`, it moves every successive entry in the collection to the
    ///   entry at storage index `index` down one unit. Every entry preceding the entry at index
    ///   `index` remains in the same location. The method returns `Some(value)`, where `value` is
    ///    the value stored in the entry with equivalent key to key `key` in the index map.
    /// * If the equivalent key to `key` does not exist in the index map, the method returns
    ///   `None`.
    ///
    /// In particular, the method acts like a [`pop`] when the last value in the collection is
    /// shift-removed, because the sub-collection of successor entries in the entry storage is
    /// empty.
    ///
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Hashing And Equivalence
    ///
    /// A **hashing type** is a triple `(X, ~, h)` where `~` is an equivalence relation on
    /// `X`, and `h` is a hash function such that
    ///
    /// ```text
    /// ∀ a :: X. ∀ b :: X. a ~ b ⇒ h(a) = h(b).
    /// ```
    ///
    /// A type `X` is a **hashable type** if there is an equivalence relation `~` and a hashing
    /// function `h` such that `(X, ~, h)` is a hashing type.
    ///
    /// Let `K` be the type of the keys of the index map `map`. Let `Q` be a data type. Let
    /// `q :: Q` be a value of type `Q`, and let `k :: K` be a key. let `X` be a hashable type. Let
    /// `f: Q → X` and `g: K → X` be functions. We say that
    /// **`q` is equivalent to `k` using `f` and `g`** if and only if
    ///
    /// ```test
    /// equiv(X, f, g)(q, k) := f(q) ∼ g(k).
    /// ```
    ///
    /// Note that by the definition of `~`
    ///
    /// ```text
    /// ∀ q :: Q. ∀ k :: K. f(q) ∼ g(k) ⇒ h(f(q)) = h(g(k)).
    /// ```
    ///
    /// This is an implication, not an equivalence, because practical hashing functions can have
    /// collisions, i.e. for a practical hashing function `h`,
    /// `∃ a, b :: X. ¬(a ~ b) ∧ h(a) = h(b)`. We say that the type
    /// **`Q` is equivalent to `K` using `f` and `g`** if and only if
    ///
    /// ```text
    /// equiv(X, f, g)(Q, K) :=
    ///     (∀ q :: Q. ∃ k :: K. equiv(X, f, g)(q, k))
    ///     ∧ (∀ k :: K. ∃ q :: Q. equiv(X, f, g)(q, k)).
    /// ```
    ///
    /// Let `X` be a hashable type. Then the type **`Q` is equivalent to the type `K` using `X`**
    /// if and only if
    ///
    /// ```text
    /// equiv(X, Q, K) := ∃ f: Q → X. ∃ g: K → X. equiv(X, f, g)(Q, K).
    /// ```
    ///
    /// Key equality is a special case of key equivalence. Let `K` be a hashable data type. Let
    /// `Q = K`, and `f = g = id`. Then
    ///
    /// ```text
    /// ∀ k1, k2 :: K. k1 = k2 = id(k1) = id(k2) ⇒ h(id(k1)) = h(id(k2)) = h(k1) = h(k2)
    /// ```
    ///
    /// so that we have `equiv(K, id, id)(K, K)` which implies `equiv(K, K, K)`, i.e. `K` is
    /// equivalent to `K` using `K` when `K` is a hashable type.
    ///
    /// Let `Q` be a type equivalent to the key type `K` using `K`. Let `f: Q → K` and `id: K → K`
    /// be the identity. We say that **`q` is equivalent to `k`** if and only if
    ///
    /// ```text
    /// equiv(q, k) := equiv(K, f, id)(q, k).
    /// ```
    ///
    /// Let `Q` be a data type equivalent to key type `K` using `K`. We say that `q` is an
    /// **equivalent element of** the map `map`, or that **`map` equivalently contains `q`** if and
    /// only if
    ///
    /// ```text
    /// q ~∈ map ⇔ ∃ i ∈ [0, map.len()). equiv(q, map[i].key()).
    /// ```
    ///
    /// If `q` is not an equivalent element of `map`, we write `q ~∉ map`.
    ///
    /// When `K` is a hashable type, we see that `k ~∈ map ⇔ k ∈ map`, so that equivalent
    /// containment indeed generalizes containment.
    ///
    /// ## Specification Definitions
    ///
    /// The set of **keys** in the map `map` is defined as
    ///
    /// ```text
    /// keys(map) := { k :: K | ∃ i ∈ [0, map.len()). map[i].key() = k }
    /// ```
    ///
    /// or equivalently
    ///
    /// ```text
    /// ∀ k :: K. (k ∈ keys(map)) ⇔ (∃ i ∈ [0, map.len()). map[i].key() = k).
    /// ```
    ///
    /// We also say that a key `k` is in the map `map` provided that
    ///
    /// ```text
    /// ∀ k :: K. k ∈ map ⇔ k ∈ keys(map).
    /// ```
    ///
    /// We say that two maps `map1` and `map2` are **equal** if and only if
    ///
    /// ```text
    /// map1 = map2 ⇔ (map1.len() = map2.len()) ∧ (∀ i ∈ [0, map1.len()). map1[i] = map2[i]).
    /// ```
    ///
    /// The **index** of an equivalent key `q` in `map` is defined by
    ///
    /// ```text
    /// index(map, q) := i such that equiv(q, map[i].key()).
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ~∈ map_before }
    /// map.shift_remove(key)
    /// {
    ///     result = Some(map_before[index(map_before, key)])
    ///     ∧ map_after.len() = map_before.len() - 1
    ///     ∧ key ~∉ map_after
    ///     ∧ ((∀ j ∈ [0, index(map_before, key)). map_after[j] = map_before[j])
    ///        ∧ (∀ j ∈ [index(map_before, key), map_after.len()). map_after[j] = map_before[j + 1])
    ///     )
    /// }
    ///
    /// { key ~∉ map_before }
    /// map.shift_remove(key)
    /// { result = None ∧ map_after = map_before }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// Showing how shift removal happens.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    ///     (isize::MAX, f64::MAX),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<isize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// {
    ///     let expected = OpaqueIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (2_isize, 3_f64),
    ///         (3_isize, 4_f64),
    ///     ]);
    /// #
    /// #   assert!(expected.has_key_type::<isize>());
    /// #   assert!(expected.has_value_type::<f64>());
    /// #   assert!(expected.has_build_hasher_type::<RandomState>());
    /// #   assert!(expected.has_allocator_type::<Global>());
    /// #
    ///     let mut result = opaque_map.clone::<isize, f64, RandomState, Global>();
    /// #
    /// #   assert!(result.has_key_type::<isize>());
    /// #   assert!(result.has_value_type::<f64>());
    /// #   assert!(result.has_build_hasher_type::<RandomState>());
    /// #   assert!(result.has_allocator_type::<Global>());
    /// #
    ///     let removed = result.shift_remove::<_, isize, f64, RandomState, Global>(&isize::MAX);
    ///     assert_eq!(result.as_slice::<isize, f64, RandomState, Global>(), expected.as_slice::<isize, f64, RandomState, Global>());
    ///     assert_eq!(removed, Some(f64::MAX));
    /// }
    /// {
    ///     let expected = OpaqueIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (2_isize, 3_f64),
    ///         (isize::MAX, f64::MAX),
    ///     ]);
    /// #
    /// #   assert!(expected.has_key_type::<isize>());
    /// #   assert!(expected.has_value_type::<f64>());
    /// #   assert!(expected.has_build_hasher_type::<RandomState>());
    /// #   assert!(expected.has_allocator_type::<Global>());
    /// #
    ///     let mut result = opaque_map.clone::<isize, f64, RandomState, Global>();
    /// #
    /// #   assert!(result.has_key_type::<isize>());
    /// #   assert!(result.has_value_type::<f64>());
    /// #   assert!(result.has_build_hasher_type::<RandomState>());
    /// #   assert!(result.has_allocator_type::<Global>());
    /// #
    ///     let removed = result.shift_remove::<_, isize, f64, RandomState, Global>(&3_isize);
    ///     assert_eq!(result.as_slice::<isize, f64, RandomState, Global>(), expected.as_slice::<isize, f64, RandomState, Global>());
    ///     assert_eq!(removed, Some(4_f64));
    /// }
    /// {
    ///     let expected = OpaqueIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (3_isize, 4_f64),
    ///         (isize::MAX, f64::MAX),
    ///     ]);
    /// #
    /// #   assert!(expected.has_key_type::<isize>());
    /// #   assert!(expected.has_value_type::<f64>());
    /// #   assert!(expected.has_build_hasher_type::<RandomState>());
    /// #   assert!(expected.has_allocator_type::<Global>());
    /// #
    ///     let mut result = opaque_map.clone::<isize, f64, RandomState, Global>();
    /// #
    /// #   assert!(result.has_key_type::<isize>());
    /// #   assert!(result.has_value_type::<f64>());
    /// #   assert!(result.has_build_hasher_type::<RandomState>());
    /// #   assert!(result.has_allocator_type::<Global>());
    /// #
    ///     let removed = result.shift_remove::<_, isize, f64, RandomState, Global>(&2_isize);
    ///     assert_eq!(result.as_slice::<isize, f64, RandomState, Global>(), expected.as_slice::<isize, f64, RandomState, Global>());
    ///     assert_eq!(removed, Some(3_f64));
    /// }
    /// {
    ///     let expected = OpaqueIndexMap::from([
    ///         (2_isize, 3_f64),
    ///         (3_isize, 4_f64),
    ///         (isize::MAX, f64::MAX),
    ///     ]);
    /// #
    /// #   assert!(expected.has_key_type::<isize>());
    /// #   assert!(expected.has_value_type::<f64>());
    /// #   assert!(expected.has_build_hasher_type::<RandomState>());
    /// #   assert!(expected.has_allocator_type::<Global>());
    /// #
    ///     let mut result = opaque_map.clone::<isize, f64, RandomState, Global>();
    /// #
    /// #   assert!(result.has_key_type::<isize>());
    /// #   assert!(result.has_value_type::<f64>());
    /// #   assert!(result.has_build_hasher_type::<RandomState>());
    /// #   assert!(result.has_allocator_type::<Global>());
    /// #
    ///     let removed = result.shift_remove::<_, isize, f64, RandomState, Global>(&1_isize);
    ///     assert_eq!(result.as_slice::<isize, f64, RandomState, Global>(), expected.as_slice::<isize, f64, RandomState, Global>());
    ///     assert_eq!(removed, Some(2_f64));
    /// }
    /// ```
    ///
    /// [`pop`]: OpaqueIndexMap::pop
    #[track_caller]
    pub fn shift_remove<Q, K, V, S, A>(&mut self, key: &Q) -> Option<V>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
        Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.shift_remove(key)
    }

    /// Removes an entry from a type-erased index map, shifting every successive entry in the
    /// collection in storage order down one index to fill where the removed entry occupies the
    /// collection.
    ///
    /// This method behaves with respect to the lookup key `key` as follows:
    ///
    /// * If the equivalent key to `key` exists in the index map, let `index` be its storage index.
    ///   If `index < self.len() - 1`, it moves every successive entry in the collection to the
    ///   entry at storage index `index` down one unit. Every entry preceding the entry at index
    ///   `index` remains in the same location. The method returns `Some((eq_key, value))`, where
    ///   `(eq_key, value)` is the key-value pair with equivalent key `eq_key` to `key` in the
    ///   index map.
    /// * If the equivalent key to `key` does not exist in the index map, the method returns
    ///   `None`.
    ///
    /// In particular, the method acts like a [`pop`] when the last value in the collection is
    /// shift-removed, because the sub-collection of successor entries in the entry storage is
    /// empty.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Hashing And Equivalence
    ///
    /// A **hashing type** is a triple `(X, ~, h)` where `~` is an equivalence relation on
    /// `X`, and `h` is a hash function such that
    ///
    /// ```text
    /// ∀ a :: X. ∀ b :: X. a ~ b ⇒ h(a) = h(b).
    /// ```
    ///
    /// A type `X` is a **hashable type** if there is an equivalence relation `~` and a hashing
    /// function `h` such that `(X, ~, h)` is a hashing type.
    ///
    /// Let `K` be the type of the keys of the index map `map`. Let `Q` be a data type. Let
    /// `q :: Q` be a value of type `Q`, and let `k :: K` be a key. let `X` be a hashable type. Let
    /// `f: Q → X` and `g: K → X` be functions. We say that
    /// **`q` is equivalent to `k` using `f` and `g`** if and only if
    ///
    /// ```test
    /// equiv(X, f, g)(q, k) := f(q) ∼ g(k).
    /// ```
    ///
    /// Note that by the definition of `~`
    ///
    /// ```text
    /// ∀ q :: Q. ∀ k :: K. f(q) ∼ g(k) ⇒ h(f(q)) = h(g(k)).
    /// ```
    ///
    /// This is an implication, not an equivalence, because practical hashing functions can have
    /// collisions, i.e. for a practical hashing function `h`,
    /// `∃ a, b :: X. ¬(a ~ b) ∧ h(a) = h(b)`. We say that the type
    /// **`Q` is equivalent to `K` using `f` and `g`** if and only if
    ///
    /// ```text
    /// equiv(X, f, g)(Q, K) :=
    ///     (∀ q :: Q. ∃ k :: K. equiv(X, f, g)(q, k))
    ///     ∧ (∀ k :: K. ∃ q :: Q. equiv(X, f, g)(q, k)).
    /// ```
    ///
    /// Let `X` be a hashable type. Then the type **`Q` is equivalent to the type `K` using `X`**
    /// if and only if
    ///
    /// ```text
    /// equiv(X, Q, K) := ∃ f: Q → X. ∃ g: K → X. equiv(X, f, g)(Q, K).
    /// ```
    ///
    /// Key equality is a special case of key equivalence. Let `K` be a hashable data type. Let
    /// `Q = K`, and `f = g = id`. Then
    ///
    /// ```text
    /// ∀ k1, k2 :: K. k1 = k2 = id(k1) = id(k2) ⇒ h(id(k1)) = h(id(k2)) = h(k1) = h(k2)
    /// ```
    ///
    /// so that we have `equiv(K, id, id)(K, K)` which implies `equiv(K, K, K)`, i.e. `K` is
    /// equivalent to `K` using `K` when `K` is a hashable type.
    ///
    /// Let `Q` be a type equivalent to the key type `K` using `K`. Let `f: Q → K` and `id: K → K`
    /// be the identity. We say that **`q` is equivalent to `k`** if and only if
    ///
    /// ```text
    /// equiv(q, k) := equiv(K, f, id)(q, k).
    /// ```
    ///
    /// Let `Q` be a data type equivalent to key type `K` using `K`. We say that `q` is an
    /// **equivalent element of** the map `map`, or that **`map` equivalently contains `q`** if and
    /// only if
    ///
    /// ```text
    /// q ~∈ map ⇔ ∃ i ∈ [0, map.len()). equiv(q, map[i].key()).
    /// ```
    ///
    /// If `q` is not an equivalent element of `map`, we write `q ~∉ map`.
    ///
    /// When `K` is a hashable type, we see that `k ~∈ map ⇔ k ∈ map`, so that equivalent
    /// containment indeed generalizes containment.
    ///
    /// ## Specification Definitions
    ///
    /// The set of **keys** in the map `map` is defined as
    ///
    /// ```text
    /// keys(map) := { k :: K | ∃ i ∈ [0, map.len()). map[i].key() = k }
    /// ```
    ///
    /// or equivalently
    ///
    /// ```text
    /// ∀ k :: K. (k ∈ keys(map)) ⇔ (∃ i ∈ [0, map.len()). map[i].key() = k).
    /// ```
    ///
    /// We also say that a key `k` is in the map `map` provided that
    ///
    /// ```text
    /// ∀ k :: K. k ∈ map ⇔ k ∈ keys(map).
    /// ```
    ///
    /// We say that two maps `map1` and `map2` are **equal** if and only if
    ///
    /// ```text
    /// map1 = map2 ⇔ (map1.len() = map2.len()) ∧ (∀ i ∈ [0, map1.len()). map1[i] = map2[i]).
    /// ```
    ///
    /// The **index** of an equivalent key `q` in `map` is defined by
    ///
    /// ```text
    /// index(map, q) := i such that equiv(q, map[i].key()).
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ~∈ map_before }
    /// map.shift_remove_entry(key)
    /// {
    ///     result = Some(map_before[index(map_before, key)])
    ///     ∧ map_after.len() = map_before.len() - 1
    ///     ∧ key ∉ map_after
    ///     ∧ ((∀ j ∈ [0, index(map_before, key)). map_after[j] = map_before[j])
    ///        ∧ (∀ j ∈ [index(map_before, key), map_after.len()). map_after[j] = map_before[j + 1])
    ///     )
    /// }
    ///
    /// { key ~∉ map_before }
    /// map.shift_remove_entry(key)
    /// { result = None ∧ map_after = map_before }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// Showing how shift removal happens.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    ///     (isize::MAX, f64::MAX),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<isize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// {
    ///     let expected = OpaqueIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (2_isize, 3_f64),
    ///         (3_isize, 4_f64),
    ///     ]);
    /// #
    /// #   assert!(expected.has_key_type::<isize>());
    /// #   assert!(expected.has_value_type::<f64>());
    /// #   assert!(expected.has_build_hasher_type::<RandomState>());
    /// #   assert!(expected.has_allocator_type::<Global>());
    /// #
    ///     let mut result = opaque_map.clone::<isize, f64, RandomState, Global>();
    /// #
    /// #   assert!(result.has_key_type::<isize>());
    /// #   assert!(result.has_value_type::<f64>());
    /// #   assert!(result.has_build_hasher_type::<RandomState>());
    /// #   assert!(result.has_allocator_type::<Global>());
    /// #
    ///     let removed = result.shift_remove_entry::<_, isize, f64, RandomState, Global>(&isize::MAX);
    ///     assert_eq!(result.as_slice::<isize, f64, RandomState, Global>(), expected.as_slice::<isize, f64, RandomState, Global>());
    ///     assert_eq!(removed, Some((isize::MAX, f64::MAX)));
    /// }
    /// {
    ///     let expected = OpaqueIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (2_isize, 3_f64),
    ///         (isize::MAX, f64::MAX),
    ///     ]);
    /// #
    /// #   assert!(expected.has_key_type::<isize>());
    /// #   assert!(expected.has_value_type::<f64>());
    /// #   assert!(expected.has_build_hasher_type::<RandomState>());
    /// #   assert!(expected.has_allocator_type::<Global>());
    /// #
    ///     let mut result = opaque_map.clone::<isize, f64, RandomState, Global>();
    /// #
    /// #   assert!(result.has_key_type::<isize>());
    /// #   assert!(result.has_value_type::<f64>());
    /// #   assert!(result.has_build_hasher_type::<RandomState>());
    /// #   assert!(result.has_allocator_type::<Global>());
    /// #
    ///     let removed = result.shift_remove_entry::<_, isize, f64, RandomState, Global>(&3_isize);
    ///     assert_eq!(result.as_slice::<isize, f64, RandomState, Global>(), expected.as_slice::<isize, f64, RandomState, Global>());
    ///     assert_eq!(removed, Some((3_isize, 4_f64)));
    /// }
    /// {
    ///     let expected = OpaqueIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (3_isize, 4_f64),
    ///         (isize::MAX, f64::MAX),
    ///     ]);
    /// #
    /// #   assert!(expected.has_key_type::<isize>());
    /// #   assert!(expected.has_value_type::<f64>());
    /// #   assert!(expected.has_build_hasher_type::<RandomState>());
    /// #   assert!(expected.has_allocator_type::<Global>());
    /// #
    ///     let mut result = opaque_map.clone::<isize, f64, RandomState, Global>();
    /// #
    /// #   assert!(result.has_key_type::<isize>());
    /// #   assert!(result.has_value_type::<f64>());
    /// #   assert!(result.has_build_hasher_type::<RandomState>());
    /// #   assert!(result.has_allocator_type::<Global>());
    /// #
    ///     let removed = result.shift_remove_entry::<_, isize, f64, RandomState, Global>(&2_isize);
    ///     assert_eq!(result.as_slice::<isize, f64, RandomState, Global>(), expected.as_slice::<isize, f64, RandomState, Global>());
    ///     assert_eq!(removed, Some((2_isize, 3_f64)));
    /// }
    /// {
    ///     let expected = OpaqueIndexMap::from([
    ///         (2_isize, 3_f64),
    ///         (3_isize, 4_f64),
    ///         (isize::MAX, f64::MAX),
    ///     ]);
    /// #
    /// #   assert!(expected.has_key_type::<isize>());
    /// #   assert!(expected.has_value_type::<f64>());
    /// #   assert!(expected.has_build_hasher_type::<RandomState>());
    /// #   assert!(expected.has_allocator_type::<Global>());
    /// #
    ///     let mut result = opaque_map.clone::<isize, f64, RandomState, Global>();
    /// #
    /// #   assert!(result.has_key_type::<isize>());
    /// #   assert!(result.has_value_type::<f64>());
    /// #   assert!(result.has_build_hasher_type::<RandomState>());
    /// #   assert!(result.has_allocator_type::<Global>());
    /// #
    ///     let removed = result.shift_remove_entry::<_, isize, f64, RandomState, Global>(&1_isize);
    ///     assert_eq!(result.as_slice::<isize, f64, RandomState, Global>(), expected.as_slice::<isize, f64, RandomState, Global>());
    ///     assert_eq!(removed, Some((1_isize, 2_f64)));
    /// }
    /// ```
    ///
    /// [`pop`]: OpaqueIndexMap::pop
    #[track_caller]
    pub fn shift_remove_entry<Q, K, V, S, A>(&mut self, key: &Q) -> Option<(K, V)>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
        Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.shift_remove_entry(key)
    }

    /// Removes an entry from a type-erased index map, shifting every successive entry in the
    /// collection in storage order down one index to fill where the removed entry occupies the
    /// collection.
    ///
    /// This method behaves with respect to the lookup key `key` as follows:
    ///
    /// * If the equivalent key to `key` exists in the index map, let `index` be its storage index.
    ///   If `index < self.len() - 1`, it moves every successive entry in the collection to the
    ///   entry at storage index `index` down one unit. Every entry preceding the entry at index
    ///   `index` remains in the same location. The method returns `Some((index, eq_key, value))`,
    ///   where `(eq_key, value)` is the key-value pair with equivalent key `eq_key` to `key` in
    ///   the index map.
    /// * If the key `key` does not exist in the index map, the method returns `None`.
    ///
    /// In particular, the method acts like a [`pop`] when the last value in the collection is
    /// shift-removed, because the sub-collection of successor entries in the entry storage is
    /// empty.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Hashing And Equivalence
    ///
    /// A **hashing type** is a triple `(X, ~, h)` where `~` is an equivalence relation on
    /// `X`, and `h` is a hash function such that
    ///
    /// ```text
    /// ∀ a :: X. ∀ b :: X. a ~ b ⇒ h(a) = h(b).
    /// ```
    ///
    /// A type `X` is a **hashable type** if there is an equivalence relation `~` and a hashing
    /// function `h` such that `(X, ~, h)` is a hashing type.
    ///
    /// Let `K` be the type of the keys of the index map `map`. Let `Q` be a data type. Let
    /// `q :: Q` be a value of type `Q`, and let `k :: K` be a key. let `X` be a hashable type. Let
    /// `f: Q → X` and `g: K → X` be functions. We say that
    /// **`q` is equivalent to `k` using `f` and `g`** if and only if
    ///
    /// ```test
    /// equiv(X, f, g)(q, k) := f(q) ∼ g(k).
    /// ```
    ///
    /// Note that by the definition of `~`
    ///
    /// ```text
    /// ∀ q :: Q. ∀ k :: K. f(q) ∼ g(k) ⇒ h(f(q)) = h(g(k)).
    /// ```
    ///
    /// This is an implication, not an equivalence, because practical hashing functions can have
    /// collisions, i.e. for a practical hashing function `h`,
    /// `∃ a, b :: X. ¬(a ~ b) ∧ h(a) = h(b)`. We say that the type
    /// **`Q` is equivalent to `K` using `f` and `g`** if and only if
    ///
    /// ```text
    /// equiv(X, f, g)(Q, K) :=
    ///     (∀ q :: Q. ∃ k :: K. equiv(X, f, g)(q, k))
    ///     ∧ (∀ k :: K. ∃ q :: Q. equiv(X, f, g)(q, k)).
    /// ```
    ///
    /// Let `X` be a hashable type. Then the type **`Q` is equivalent to the type `K` using `X`**
    /// if and only if
    ///
    /// ```text
    /// equiv(X, Q, K) := ∃ f: Q → X. ∃ g: K → X. equiv(X, f, g)(Q, K).
    /// ```
    ///
    /// Key equality is a special case of key equivalence. Let `K` be a hashable data type. Let
    /// `Q = K`, and `f = g = id`. Then
    ///
    /// ```text
    /// ∀ k1, k2 :: K. k1 = k2 = id(k1) = id(k2) ⇒ h(id(k1)) = h(id(k2)) = h(k1) = h(k2)
    /// ```
    ///
    /// so that we have `equiv(K, id, id)(K, K)` which implies `equiv(K, K, K)`, i.e. `K` is
    /// equivalent to `K` using `K` when `K` is a hashable type.
    ///
    /// Let `Q` be a type equivalent to the key type `K` using `K`. Let `f: Q → K` and `id: K → K`
    /// be the identity. We say that **`q` is equivalent to `k`** if and only if
    ///
    /// ```text
    /// equiv(q, k) := equiv(K, f, id)(q, k).
    /// ```
    ///
    /// Let `Q` be a data type equivalent to key type `K` using `K`. We say that `q` is an
    /// **equivalent element of** the map `map`, or that **`map` equivalently contains `q`** if and
    /// only if
    ///
    /// ```text
    /// q ~∈ map ⇔ ∃ i ∈ [0, map.len()). equiv(q, map[i].key()).
    /// ```
    ///
    /// If `q` is not an equivalent element of `map`, we write `q ~∉ map`.
    ///
    /// When `K` is a hashable type, we see that `k ~∈ map ⇔ k ∈ map`, so that equivalent
    /// containment indeed generalizes containment.
    ///
    /// ## Specification Definitions
    ///
    /// The set of **keys** in the map `map` is defined as
    ///
    /// ```text
    /// keys(map) := { k :: K | ∃ i ∈ [0, map.len()). map[i].key() = k }
    /// ```
    ///
    /// or equivalently
    ///
    /// ```text
    /// ∀ k :: K. (k ∈ keys(map)) ⇔ (∃ i ∈ [0, map.len()). map[i].key() = k).
    /// ```
    ///
    /// We also say that a key `k` is in the map `map` provided that
    ///
    /// ```text
    /// ∀ k :: K. k ∈ map ⇔ k ∈ keys(map).
    /// ```
    ///
    /// We say that two maps `map1` and `map2` are **equal** if and only if
    ///
    /// ```text
    /// map1 = map2 ⇔ (map1.len() = map2.len()) ∧ (∀ i ∈ [0, map1.len()). map1[i] = map2[i]).
    /// ```
    ///
    /// The **index** of an equivalent key `q` in `map` is defined by
    ///
    /// ```text
    /// index(map, q) := i such that equiv(q, map[i].key()).
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ∈ map_before }
    /// map.shift_remove_full(key)
    /// {
    ///     result = Some(map_before[index(map_before, key)])
    ///     ∧ map_after.len() = map_before.len() - 1
    ///     ∧ key ∉ map_after
    ///     ∧ ((∀ j ∈ [0, index(map_before, key)). map_after[j] = map_before[j])
    ///        ∧ (∀ j ∈ [index(map_before, key), map_after.len()). map_after[j] = map_before[j + 1])
    ///     )
    /// }
    ///
    /// { key ∉ map_before }
    /// map.shift_remove_full(key)
    /// { result = None ∧ map_after = map_before }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// Showing how shift removal happens.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    ///     (isize::MAX, f64::MAX),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<isize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// {
    ///     let expected = OpaqueIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (2_isize, 3_f64),
    ///         (3_isize, 4_f64),
    ///     ]);
    /// #
    /// #   assert!(expected.has_key_type::<isize>());
    /// #   assert!(expected.has_value_type::<f64>());
    /// #   assert!(expected.has_build_hasher_type::<RandomState>());
    /// #   assert!(expected.has_allocator_type::<Global>());
    /// #
    ///     let mut result = opaque_map.clone::<isize, f64, RandomState, Global>();
    /// #
    /// #   assert!(result.has_key_type::<isize>());
    /// #   assert!(result.has_value_type::<f64>());
    /// #   assert!(result.has_build_hasher_type::<RandomState>());
    /// #   assert!(result.has_allocator_type::<Global>());
    /// #
    ///     let removed = result.shift_remove_full::<_, isize, f64, RandomState, Global>(&isize::MAX);
    ///     assert_eq!(result.as_slice::<isize, f64, RandomState, Global>(), expected.as_slice::<isize, f64, RandomState, Global>());
    ///     assert_eq!(removed, Some((3, isize::MAX, f64::MAX)));
    /// }
    /// {
    ///     let expected = OpaqueIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (2_isize, 3_f64),
    ///         (isize::MAX, f64::MAX),
    ///     ]);
    /// #
    /// #   assert!(expected.has_key_type::<isize>());
    /// #   assert!(expected.has_value_type::<f64>());
    /// #   assert!(expected.has_build_hasher_type::<RandomState>());
    /// #   assert!(expected.has_allocator_type::<Global>());
    /// #
    ///     let mut result = opaque_map.clone::<isize, f64, RandomState, Global>();
    /// #
    /// #   assert!(result.has_key_type::<isize>());
    /// #   assert!(result.has_value_type::<f64>());
    /// #   assert!(result.has_build_hasher_type::<RandomState>());
    /// #   assert!(result.has_allocator_type::<Global>());
    /// #
    ///     let removed = result.shift_remove_full::<_, isize, f64, RandomState, Global>(&3_isize);
    ///     assert_eq!(result.as_slice::<isize, f64, RandomState, Global>(), expected.as_slice::<isize, f64, RandomState, Global>());
    ///     assert_eq!(removed, Some((2, 3_isize, 4_f64)));
    /// }
    /// {
    ///     let expected = OpaqueIndexMap::from([
    ///         (1_isize, 2_f64),
    ///         (3_isize, 4_f64),
    ///         (isize::MAX, f64::MAX),
    ///     ]);
    /// #
    /// #   assert!(expected.has_key_type::<isize>());
    /// #   assert!(expected.has_value_type::<f64>());
    /// #   assert!(expected.has_build_hasher_type::<RandomState>());
    /// #   assert!(expected.has_allocator_type::<Global>());
    /// #
    ///     let mut result = opaque_map.clone::<isize, f64, RandomState, Global>();
    /// #
    /// #   assert!(result.has_key_type::<isize>());
    /// #   assert!(result.has_value_type::<f64>());
    /// #   assert!(result.has_build_hasher_type::<RandomState>());
    /// #   assert!(result.has_allocator_type::<Global>());
    /// #
    ///     let removed = result.shift_remove_full::<_, isize, f64, RandomState, Global>(&2_isize);
    ///     assert_eq!(result.as_slice::<isize, f64, RandomState, Global>(), expected.as_slice::<isize, f64, RandomState, Global>());
    ///     assert_eq!(removed, Some((1, 2_isize, 3_f64)));
    /// }
    /// {
    ///     let expected = OpaqueIndexMap::from([
    ///         (2_isize, 3_f64),
    ///         (3_isize, 4_f64),
    ///         (isize::MAX, f64::MAX),
    ///     ]);
    /// #
    /// #   assert!(expected.has_key_type::<isize>());
    /// #   assert!(expected.has_value_type::<f64>());
    /// #   assert!(expected.has_build_hasher_type::<RandomState>());
    /// #   assert!(expected.has_allocator_type::<Global>());
    /// #
    ///     let mut result = opaque_map.clone::<isize, f64, RandomState, Global>();
    /// #
    /// #   assert!(result.has_key_type::<isize>());
    /// #   assert!(result.has_value_type::<f64>());
    /// #   assert!(result.has_build_hasher_type::<RandomState>());
    /// #   assert!(result.has_allocator_type::<Global>());
    /// #
    ///     let removed = result.shift_remove_full::<_, isize, f64, RandomState, Global>(&1_isize);
    ///     assert_eq!(result.as_slice::<isize, f64, RandomState, Global>(), expected.as_slice::<isize, f64, RandomState, Global>());
    ///     assert_eq!(removed, Some((0, 1_isize, 2_f64)));
    /// }
    /// ```
    ///
    /// [`pop`]: OpaqueIndexMap::pop
    #[track_caller]
    pub fn shift_remove_full<Q, K, V, S, A>(&mut self, key: &Q) -> Option<(usize, K, V)>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
        Q: any::Any + ?Sized + hash::Hash + Equivalent<K>,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.shift_remove_full(key)
    }

    /// Returns a slice of all the key-value pairs in the index map.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (-1_isize, "foo"),
    ///     ( 0_isize, "bar"),
    ///     ( 1_isize, "baz"),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<isize>());
    /// # assert!(opaque_map.has_value_type::<&str>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let slice = opaque_map.as_slice::<isize, &str, RandomState, Global>();
    ///
    /// assert_eq!(slice.get_index(0), Some((&-1_isize, &"foo")));
    /// assert_eq!(slice.get_index(1), Some((&0_isize,  &"bar")));
    /// assert_eq!(slice.get_index(2), Some((&1_isize,  &"baz")));
    ///
    /// assert_eq!(slice[0], "foo");
    /// assert_eq!(slice[1], "bar");
    /// assert_eq!(slice[2], "baz");
    /// ```
    #[track_caller]
    pub fn as_slice<K, V, S, A>(&self) -> &'_ Slice<K, V>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj::<K, V, S, A>();

        proj_self.as_slice()
    }

    /// Returns a mutable slice of all the key-value pairs in the index map.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (-1_isize, "foo"),
    ///     ( 0_isize, "bar"),
    ///     ( 1_isize, "baz"),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<isize>());
    /// # assert!(opaque_map.has_value_type::<&str>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let slice = opaque_map.as_mut_slice::<isize, &str, RandomState, Global>();
    ///
    /// assert_eq!(slice.get_index(0), Some((&-1_isize, &"foo")));
    /// assert_eq!(slice.get_index(1), Some((&0_isize,  &"bar")));
    /// assert_eq!(slice.get_index(2), Some((&1_isize,  &"baz")));
    ///
    /// assert_eq!(slice[0], "foo");
    /// assert_eq!(slice[1], "bar");
    /// assert_eq!(slice[2], "baz");
    /// ```
    #[track_caller]
    pub fn as_mut_slice<K, V, S, A>(&mut self) -> &mut Slice<K, V>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.as_mut_slice()
    }
}

impl OpaqueIndexMap {
    /// Inserts a new entry into the index map.
    ///
    /// This method behaves as follows:
    ///
    /// * If the equivalent key already exists in the index map, this method replaces the old value
    ///   with the new value in the map, and returns the old value as `Some(old_value)`. The entry
    ///   retains its position in the storage order of the index map.
    /// * If the entry with the equivalent key does not exist in the map, it is appended to the end
    ///   of the map, so the resulting entry is in last place in the storage order, and the method
    ///   returns `None`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Specification Definitions
    ///
    /// We say that a key `k` is in the map `map` provided that
    ///
    /// ```text
    /// ∀ k :: K. (k ∈ map) ⇔ (∃ i ∈ [0, map.len()). map[i].key() = k).
    /// ```
    ///
    /// The **index** of a key `k` in `map` is defined by
    ///
    /// ```text
    /// index(map, k) := i such that map[i].key() = k.
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ∈ map_before }
    /// map.insert(key, value)
    /// {
    ///     result = Some(map_before[index(map_before, key)])
    ///     ∧ map_after.len() = map_before.len()
    ///     ∧ map_after[index(map_after, key)] = value
    ///     ∧ (∀ k ∈ map_before. k ≠ key ⇒ index(map_after, k) = index(map_before, k)
    ///       ∧ map_after[index(map_after, k)] = map_before[index(map_before, k)]
    ///     )
    /// }
    ///
    /// { key ∉ map_before }
    /// map.insert(key, value)
    /// {
    ///     result = None
    ///     ∧ map_after.len() = map_before.len() + 1
    ///     ∧ map_after[index(map_after, key)] = value
    ///     ∧ (∀ k ∈ map_before. index(map_after, k) = index(map_before, k)
    ///       ∧ map_after[index(map_after, k)] = map_before[index(map_before, k)]
    ///     )
    /// }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<isize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// let result = opaque_map.insert::<isize, f64, RandomState, Global>(isize::MAX, f64::MAX);
    ///
    /// assert_eq!(result, None);
    ///
    /// let result = opaque_map.insert::<isize, f64, RandomState, Global>(2_isize, 7_f64);
    ///
    /// assert_eq!(result, Some(3_f64));
    /// ```
    #[track_caller]
    pub fn insert<K, V, S, A>(&mut self, key: K, value: V) -> Option<V>
    where
        K: any::Any + Eq + hash::Hash,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.insert(key, value)
    }

    /// Inserts a new entry into the index map, returning the storage index of the old entry, if it
    /// exists.
    ///
    /// This method behaves as follows:
    ///
    /// * If the equivalent key already exists in the index map, this method replaces the old value
    ///   with the new value in the map, and returns the storage index and the old value as
    ///   `(index, Some(old_value))`. The entry retains its position in the storage order of the
    ///   index map.
    /// * If the entry with the equivalent key does not exist in the map, it is appended to the end
    ///   of the map, so the resulting entry is in last place in the storage order, and the method
    ///   returns `(index, None)`, where `index` is the index of the last entry in the map in
    ///   storage order.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Specification Definitions
    ///
    /// We say that a key `k` is in the map `map` provided that
    ///
    /// ```text
    /// ∀ k :: K. (k ∈ map) ⇔ (∃ i ∈ [0, map.len()). map[i].key() = k).
    /// ```
    ///
    /// The **index** of a key `k` in `map` is defined by
    ///
    /// ```text
    /// index(map, k) := i such that map[i].key() = k.
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ∈ map_before }
    /// map.insert_full(key, value)
    /// {
    ///     result = Some(map_before[index(map_before, key)])
    ///     ∧ map_after.len() = map_before.len()
    ///     ∧ map_after[index(map_after, key)] = value
    ///     ∧ (∀ k ∈ map_before. k ≠ key
    ///       ⇒ index(map_after, k) = index(map_before, k)
    ///       ∧ map_after[index(map_after, k)] = map_before[index(map_before, k)]
    ///     )
    /// }
    ///
    /// { key ∉ map_before }
    /// map.insert_full(key, value)
    /// {
    ///     result = None
    ///     ∧ map_after.len() = map_before.len() + 1
    ///     ∧ map_after[index(map_after, key)] = value
    ///     ∧ (∀ k ∈ map_before. index(map_after, k) = index(map_before, k)
    ///       ∧ map_after[index(map_after, k)] = map_before[index(map_before, k)]
    ///     )
    /// }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<isize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// let result = opaque_map.insert_full::<isize, f64, RandomState, Global>(isize::MAX, f64::MAX);
    ///
    /// assert_eq!(result, (3, None));
    ///
    /// let result = opaque_map.insert_full::<isize, f64, RandomState, Global>(2_isize, 7_f64);
    ///
    /// assert_eq!(result, (1, Some(3_f64)));
    /// ```
    #[track_caller]
    pub fn insert_full<K, V, S, A>(&mut self, key: K, value: V) -> (usize, Option<V>)
    where
        K: any::Any + Eq + hash::Hash,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.insert_full(key, value)
    }

    /// Inserts a new entry in the index map at its ordered position among sorted keys.
    ///
    /// An index map is in **sorted order by key** if it satisfies the following property: let `e1`
    /// and `e2` be entries in `self`. Then `e1.key() <= e2.key()` if and only if
    /// `e1.index() <= e2.index()`. More precisely, given the index map `self`
    ///
    /// ```text
    /// forall e1, e2 in self. e1.index() <= e2.index() <-> e1.key() <= e2.key()
    /// ```
    ///
    /// or equivalently over key-value pairs
    ///
    /// ```text
    /// forall i1, i2 in [0, self.len()). forall k1, k2 :: K. forall v1, v2 :: V.
    /// (i1, (k1, v1)), (i2, (k2, v2)) in self --> i1 <= i2 <-> k1 <= k2.
    /// ```
    ///
    /// Otherwise, the index map is in **unsorted order by key**, or is **unsorted** for short.
    ///
    /// This means that an index map is in sorted order if the total ordering of the keys in the map
    /// matches the storage order of the entries in the map. The keys are **sorted** if the index
    /// map is in sorted order, and **unsorted** otherwise.
    ///
    /// This method is equivalent to finding the position with [`binary_search_keys`], then either
    /// updating it or calling [`insert_before`] for a new key.
    ///
    /// This method behaves as follows:
    ///
    /// * If the index map is in sorted order and contains the sorted key `key`, its corresponding
    ///   value is updated with `value`, and the older value is returned as
    ///   `(index, Some(old_value))`, where `index` is the storage index of the sorted key.
    /// * If the index map is in sorted order and does not contain the sorted key `key`, this method
    ///   inserts the new entry at the sorted position, returns `(index, None)`, where `index` is
    ///   the storage index of the sorted key.
    /// * If the existing keys are **not** sorted order, then the insertion index is unspecified.
    ///
    /// Instead of repeating calls to `insert_sorted`, it may be faster to call batched [`insert`]
    /// or [`extend`] and only call [`sort_keys`] or [`sort_unstable_keys`] once.
    ///
    /// [`binary_search_keys`]: OpaqueIndexMap::binary_search_keys
    /// [`insert_before`]: OpaqueIndexMap::insert_before
    /// [`insert`]: OpaqueIndexMap::insert
    /// [`extend`]: OpaqueIndexMap::extend
    /// [`sort_keys`]: OpaqueIndexMap::sort_keys
    /// [`sort_unstable_keys`]: OpaqueIndexMap::sort_unstable_keys
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Specification Definitions
    ///
    /// We say that a key `k` is in the map `map` provided that
    ///
    /// ```text
    /// ∀ k :: K. (k ∈ map) ⇔ (∃ i ∈ [0, map.len()). map[i].key() = k).
    /// ```
    ///
    /// The **index** of a key `k` in `map` is defined by
    ///
    /// ```text
    /// index(map, k) := i such that map[i].key() = k.
    /// ```
    ///
    /// The index map `map` is **sorted**, or in **sorted order** if and only if
    ///
    /// ```text
    /// is_sorted(map) := ∀ i1, i2 ∈ [0, map.len()). (i1 ≤ i2) ⇒ (map[i1].key() ≤ map[i2].key())
    /// ```
    ///
    /// or equivalently over index-key-value triples
    ///
    /// ```text
    /// ∀ i1, i2 ∈ [0, map.len()). ∀ k1, k2 :: K. ∀ v1, v2 :: V.
    /// ((i1, (k1, v1)) ∈ map ∧ (i2, (k2, v2)) ∈ map) ⇒ (i1 ≤ i2 ⇔ k1 ≤ k2).
    /// ```
    ///
    /// Otherwise, the index map is in **unsorted order by key**, or is **unsorted** for short.
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { key ∈ map_before ∧ is_sorted(map_before) }
    /// map.insert_sorted(key, value)
    /// {
    ///     result = Some(map_before[index(map_before, key)])
    ///     ∧ map_after[index(map_after, key)] = value
    ///     ∧ map_after.len() = map_before.len()
    ///     ∧ (∀ k ∈ map_before. k ≠ key ⇒ map_after[index(map_after, k)] = map_before[index(map_before, k)])
    ///     ∧ is_sorted(map_after)
    /// }
    ///
    /// { key ∉ map_before ∧ is_sorted(map_before) }
    /// map.insert_sorted(key, value)
    /// {
    ///     result = None
    ///     ∧ map_after[index(map_after, key)] = value
    ///     ∧ map_after.len() = map_before.len() + 1
    ///     ∧ (∀ k ∈ map_before. map_after[index(map_after, k)] = map_before[index(map_before, k)])
    ///     ∧ (∀ i < index(map_after, key). map_after[i].key() ≤ key
    ///        ∧ ∀ i > index(map_after, key). key ≤ map_after[i].key()
    ///     )
    ///     ∧ is_sorted(map_after)
    /// }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// Calling this method on an index map with a set of sorted keys yields the index of the
    /// entry in the underlying storage.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    ///     (4_isize, 5_f64),
    ///     (5_isize, 6_f64),
    ///     (6_isize, 7_f64),
    ///     (7_isize, 8_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<isize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let result = opaque_map.insert_sorted::<isize, f64, RandomState, Global>(5_isize, 100_f64);
    ///
    /// // The map is sorted, so the index returned is the storage
    /// assert_eq!(result, (4, Some(6_f64)));
    ///
    /// assert_eq!(opaque_map.get::<_, isize, f64, RandomState, Global>(&5_isize), Some(&100_f64));
    /// ```
    ///
    /// Calling this method on an index map with a set of unsorted keys yields a meaningless
    /// result for the insertion index.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (7_isize, 8_f64),
    ///     (4_isize, 5_f64),
    ///     (2_isize, 3_f64),
    ///     (5_isize, 6_f64),
    ///     (6_isize, 7_f64),
    ///     (1_isize, 2_f64),
    ///     (3_isize, 4_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<isize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let result = opaque_map.insert_sorted::<isize, f64, RandomState, Global>(5_isize, 100_f64);
    ///
    /// // The map is unsorted, so the index returned by the method is meaningless.
    /// assert_ne!(result, (4, Some(6_f64)));
    ///
    /// assert_eq!(opaque_map.get::<_, isize, f64, RandomState, Global>(&5_isize), Some(&100_f64));
    /// ```
    #[track_caller]
    pub fn insert_sorted<K, V, S, A>(&mut self, key: K, value: V) -> (usize, Option<V>)
    where
        K: any::Any + Eq + hash::Hash + Ord,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.insert_sorted(key, value)
    }

    /// Inserts an entry into a type-erased index map before the entry at the given index, or at
    /// the end of the index map.
    ///
    /// The index `index` must be in bounds. The index `index` is **in bounds** provided that
    /// `index` is in `[0, self.len()]`. Otherwise, the index `index` is **out of bounds**.
    ///
    /// This method behaves as follows:
    ///
    /// * If an equivalent key to the key `key` exists in the index map, let `current_index` be the
    ///   storage index of the entry with the equivalent key to `key`.
    ///   - If `index > current_index`, this method moves the entry at `current_index` to
    ///     `index - 1`, shifts each entry in `(current_index, index - 1]` down one index in the
    ///     storage of the index map, replaces the old value of the entry `old_value` with the new
    ///     value `value`, then returns `(index - 1, Some(old_value))`.
    ///   - If `index < current_index`, this method moves the entry at `current_index` to `index`,
    ///     shifts each entry in `[index, current_index)` up one index in the storage for the index
    ///     map, replaces the old value of the entry `old_value` with the new value `value`, then
    ///     returns `(index, Some(old_value))`.
    ///   - If `index == current_index`, this method replaces the old value of the entry `old_value`
    ///     with the new value `value`, no other entries get shifted or moved, then returns
    ///     `(index, Some(old_value))`.
    /// * If an equivalent key to the key `key` does not exist in the index map, the new entry is
    ///   inserted exactly at the index `index`, every element in `[index, self.len())` is shifted
    ///   up one index, and the method returns `(index, None)`. When `index == self.len()`,
    ///   the interval `[index, self.len()] == [self.len(), self.len())` is empty, so no shifting
    ///   occurs.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes. Let `result` be the return value of this method after it completes.
    ///
    /// ## Specification Definitions
    ///
    /// We say that a key `k` is in the map `map` provided that
    ///
    /// ```text
    /// ∀ k :: K. (k ∈ map) ⇔ (∃ i ∈ [0, map.len()). map[i].key() = k).
    /// ```
    ///
    /// The **index** of a key `k` in `map` is defined by
    ///
    /// ```text
    /// index(map, k) := i such that map[i].key() = k.
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { index ∈ [0, map_before.len()] ∧ key ∈ map_before }
    /// map.insert_before(index, key, value)
    /// {
    ///     result = (new_index, Some(map_before[index(map_before, key)]))
    ///     ∧ map_after[index(map_after, key)] = value
    ///     ∧ map_after.len() = map_before.len()
    ///     ∧ (∀ k ∈ map_before. k ≠ key ⇒ map_after[index(map_after, k)] = map_before[index(map_before, k)])
    ///     ∧ new_index = index(map_after, key)
    ///     ∧ ((new_index = index) ∨ (new_index = index - 1))
    /// }
    ///
    /// { index ∈ [0, map_before.len()] ∧ key ∉ map_before }
    /// map.insert_before(index, key, value)
    /// {
    ///     result = (index, None)
    ///     ∧ map_after[index(map_after, key)] = value
    ///     ∧ map_after.len() = map_before.len() + 1
    ///     ∧ (∀ k ∈ map_before. map_after[index(map_after, k)] = map_before[index(map_before, k)])
    ///     ∧ map_after[index].key() = key
    ///     ∧ (∀ i ∈ [0, map_after.len()). i ≠ index ⇒ map_after[i].key() ≠ key)
    /// }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics under one of the following conditions:
    ///
    /// * If the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    ///   `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    ///   allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    ///   type `S`, and allocator type `A`, respectively.
    /// * If the index `index` is out of bounds.
    ///
    /// # Examples
    ///
    /// Inserting an existing key `key` where `index > self.get_index_of(key)`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_isize, 'a'),
    ///     (2_isize, 'b'),
    ///     (3_isize, 'c'),
    ///     (4_isize, 'd'),
    ///     (5_isize, 'e'),
    ///     (6_isize, 'f'),
    ///     (7_isize, 'g'),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<isize>());
    /// # assert!(opaque_map.has_value_type::<char>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let removed = opaque_map.insert_before::<isize, char, RandomState, Global>(5, 2_isize, '*');
    /// let expected: TypedProjVec<(isize, char)> = TypedProjVec::from([
    ///     (1_isize, 'a'),
    ///     (3_isize, 'c'),
    ///     (4_isize, 'd'),
    ///     (5_isize, 'e'),
    ///     (2_isize, '*'),
    ///     (6_isize, 'f'),
    ///     (7_isize, 'g'),
    /// ]);
    /// let result: TypedProjVec<(isize, char)> = opaque_map
    ///     .iter::<isize, char, RandomState, Global>()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result, expected);
    /// assert_eq!(removed, (4, Some('b')));
    /// ```
    ///
    /// Inserting an existing key `key` where `index < self.get_index_of(key)`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_isize, 'a'),
    ///     (2_isize, 'b'),
    ///     (3_isize, 'c'),
    ///     (4_isize, 'd'),
    ///     (5_isize, 'e'),
    ///     (6_isize, 'f'),
    ///     (7_isize, 'g'),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<isize>());
    /// # assert!(opaque_map.has_value_type::<char>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let removed = opaque_map.insert_before::<isize, char, RandomState, Global>(2, 6_isize, '*');
    /// let expected: TypedProjVec<(isize, char)> = TypedProjVec::from([
    ///     (1_isize, 'a'),
    ///     (2_isize, 'b'),
    ///     (6_isize, '*'),
    ///     (3_isize, 'c'),
    ///     (4_isize, 'd'),
    ///     (5_isize, 'e'),
    ///     (7_isize, 'g'),
    /// ]);
    /// let result: TypedProjVec<(isize, char)> = opaque_map
    ///     .iter::<isize, char, RandomState, Global>()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result, expected);
    /// assert_eq!(removed, (2, Some('f')));
    /// ```
    ///
    /// Inserting an existing key `key` where `index == self.get_index_of(key)`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_isize, 'a'),
    ///     (2_isize, 'b'),
    ///     (3_isize, 'c'),
    ///     (4_isize, 'd'),
    ///     (5_isize, 'e'),
    ///     (6_isize, 'f'),
    ///     (7_isize, 'g'),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<isize>());
    /// # assert!(opaque_map.has_value_type::<char>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let removed = opaque_map.insert_before::<isize, char, RandomState, Global>(3, 4_isize, '*');
    /// let expected: TypedProjVec<(isize, char)> = TypedProjVec::from([
    ///     (1_isize, 'a'),
    ///     (2_isize, 'b'),
    ///     (3_isize, 'c'),
    ///     (4_isize, '*'),
    ///     (5_isize, 'e'),
    ///     (6_isize, 'f'),
    ///     (7_isize, 'g'),
    /// ]);
    /// let result: TypedProjVec<(isize, char)> = opaque_map
    ///     .iter::<isize, char, RandomState, Global>()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result, expected);
    /// assert_eq!(removed, (3, Some('d')));
    /// ```
    ///
    /// Inserting a key `key` that does not exist in the index map at an index `index`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_isize, 'a'),
    ///     (2_isize, 'b'),
    ///     (3_isize, 'c'),
    ///     (4_isize, 'd'),
    ///     (5_isize, 'e'),
    ///     (6_isize, 'f'),
    ///     (7_isize, 'g'),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<isize>());
    /// # assert!(opaque_map.has_value_type::<char>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let removed = opaque_map.insert_before::<isize, char, RandomState, Global>(3, isize::MAX, '*');
    /// let expected: TypedProjVec<(isize, char)> = TypedProjVec::from([
    ///     (1_isize, 'a'),
    ///     (2_isize, 'b'),
    ///     (3_isize, 'c'),
    ///     (isize::MAX, '*'),
    ///     (4_isize, 'd'),
    ///     (5_isize, 'e'),
    ///     (6_isize, 'f'),
    ///     (7_isize, 'g'),
    /// ]);
    /// let result: TypedProjVec<(isize, char)> = opaque_map
    ///     .iter::<isize, char, RandomState, Global>()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result, expected);
    /// assert_eq!(removed, (3, None));
    /// ```
    #[track_caller]
    pub fn insert_before<K, V, S, A>(&mut self, index: usize, key: K, value: V) -> (usize, Option<V>)
    where
        K: any::Any + Eq + hash::Hash,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.insert_before(index, key, value)
    }

    /// Inserts an entry into a type-erased index map at the given storage index.
    ///
    /// The index `index` must be in bounds. The index `index` is **in bounds** provided that one
    /// of the following conditions holds:
    ///
    /// * If an entry with a key equivalent to the key `key` exists in the index map, and `index` is
    ///   in `[0, self.len())`.
    /// * If an entry with a key equivalent to the key `key` does not exist in the index map, and
    ///   index is in `[0, self.len()]`.
    ///
    /// Otherwise, the index `index` is **out of bounds**.
    ///
    /// This method behaves as follows:
    ///
    /// * If an equivalent key already exists in the map, let `current_index` be the storage index
    ///   of the entry with key equivalent to `key`.
    ///   - If `index < current_index`, every entry in range `[index, current_index)` is shifted up
    ///     one entry in the storage order, the current entry is moved from `current_index` to
    ///     `index`, the old value of the entry `old_value` is replaced with the new value `value`,
    ///     and the method returns `Some(old_value)`.
    ///   - If `index > current_index`, every entry in range `(current_index, index]` is shifted
    ///     down one entry in the storage order, the current entry is moved from `current_index` to
    ///     `index`, the old value of the entry `old_value` is replaced with the new value `value`,
    ///     and the method returns `Some(old_value)`.
    ///   - If `index == current_index`, no shifting occurs, the old value of the entry `old_value`
    ///     is replaced with the new value `value`, and the method returns `Some(old_value)`.
    /// * If an equivalent key does not exist in the index map, the new entry is inserted at the
    ///   storage index `index`, and each entry in the range `[index, self.len())` is shifted
    ///   up one index, and the method returns `None`.
    ///
    /// Note that an existing entry **cannot** be moved to the index `self.len()`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes. Let `result` be the return value of this method after it completes.
    ///
    /// ## Specification Definitions
    ///
    /// We say that a key `k` is in the map `map` provided that
    ///
    /// ```text
    /// ∀ k :: K. (k ∈ map) ⇔ (∃ i ∈ [0, map.len()). map[i].key() = k).
    /// ```
    ///
    /// The **index** of a key `k` in `map` is defined by
    ///
    /// ```text
    /// index(map, k) := i such that map[i].key() = k.
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { index ∈ [0, map_before.len()) ∧ key ∈ map_before ∧ index(map_before, key) = index }
    /// map.shift_insert(index, key, value)
    /// {
    ///     result = Some(map_before[index(map_before, key)])
    ///     ∧ map_after[index(map_after, key)] = value
    ///     ∧ map_after[index].key() = key
    ///     ∧ map_after.len() = map_before.len()
    ///     ∧ (∀ k ∈ map_before. map_after[index(map_after, k)] = map_before[index(map_before, k)])
    /// }
    ///
    /// { index ∈ [0, map_before.len()) ∧ key ∈ map_before ∧ index(map_before, key) < index }
    /// map.shift_insert(index, key, value)
    /// {
    ///     result = Some(map_before[index(map_before, key)])
    ///     ∧ map_after[index(map_after, key)] = value
    ///     ∧ map_after[index].key() = key
    ///     ∧ map_after.len() = map_before.len()
    ///     ∧ (∀ i ∈ [0, index(map_fore, key). map_after[i] = map_before[i])
    ///     ∧ (∀ i ∈ [index(map_before, key), index - 1]. map_after[i] = map_before[i + 1])
    ///     ∧ (∀ i ∈ [index + 1, map_after.len()). map_after[i] = map_before[i])
    /// }
    ///
    /// { index ∈ [0, map_before.len()) ∧ key ∈ map_before ∧ index(map_before, key) > index }
    /// map.shift_insert(index, key, value)
    /// {
    ///     result = Some(map_before[index(map_before, key)])
    ///     ∧ map_after[index(map_after, key)] = value
    ///     ∧ map_after[index].key() = key
    ///     ∧ map_after.len() = map_before.len()
    ///     ∧ (∀ i ∈ [0, index). map_after[i] = map_before[i])
    ///     ∧ (∀ i ∈ [index + 1, index(map_before, key) + 1]. map_after[i] = map_before[i - 1])
    ///     ∧ (∀ i ∈ [index(map_before, key) + 1, map_after.len()). map_after[i] = map_before[i])
    /// }
    ///
    /// { index ∈ [0, map_before.len()] ∧ key ∉ map_before }
    /// map.shift_insert(index, key, value)
    /// {
    ///     result = None
    ///     ∧ map_after[index(map_after, key)] = value
    ///     ∧ map_after[index].key() = key
    ///     ∧ map_after.len() = map_before.len() + 1
    ///     ∧ (∀ j ∈ [0, map_after.len()). j ≠ index ⇒ map_after[j].key() ≠ key)
    ///     ∧ (∀ i ∈ [0, index). map_after[i] = map_before[i])
    ///     ∧ (∀ i ∈ [index + 1, map_after.len()). map_after[i] = map_before[i - 1])
    /// }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics under one of the following conditions:
    ///
    /// * If the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    ///   `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    ///   allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    ///   type `S`, and allocator type `A`, respectively.
    /// * If the index `index` is out of bounds.
    ///
    /// # Examples
    ///
    /// Shift inserting an entry that **does not** exist with index `index < self.len()`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    ///     (4_isize, 5_f64),
    ///     (5_isize, 6_f64),
    ///     (6_isize, 7_f64),
    ///     (7_isize, 8_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<isize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let old_value = opaque_map.shift_insert::<isize, f64, RandomState, Global>(3, isize::MAX, f64::MAX);
    /// let expected: TypedProjVec<(isize, f64)> = TypedProjVec::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    ///     (isize::MAX, f64::MAX),
    ///     (4_isize, 5_f64),
    ///     (5_isize, 6_f64),
    ///     (6_isize, 7_f64),
    ///     (7_isize, 8_f64),
    /// ]);
    /// let result: TypedProjVec<(isize, f64)> = opaque_map
    ///     .iter::<isize, f64, RandomState, Global>()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result, expected);
    /// assert_eq!(old_value, None);
    /// ```
    ///
    /// Shift inserting an entry that **does not** exist with index `index == self.len()`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    ///     (4_isize, 5_f64),
    ///     (5_isize, 6_f64),
    ///     (6_isize, 7_f64),
    ///     (7_isize, 8_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<isize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let old_value = opaque_map.shift_insert::<isize, f64, RandomState, Global>(opaque_map.len(), isize::MAX, f64::MAX);
    /// let expected: TypedProjVec<(isize, f64)> = TypedProjVec::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    ///     (4_isize, 5_f64),
    ///     (5_isize, 6_f64),
    ///     (6_isize, 7_f64),
    ///     (7_isize, 8_f64),
    ///     (isize::MAX, f64::MAX),
    /// ]);
    /// let result: TypedProjVec<(isize, f64)> = opaque_map
    ///     .iter::<isize, f64, RandomState, Global>()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result, expected);
    /// assert_eq!(old_value, None);
    /// ```
    ///
    /// Shift inserting an entry that **does** exist with index `index < self.len()`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    ///     (4_isize, 5_f64),
    ///     (5_isize, 6_f64),
    ///     (6_isize, 7_f64),
    ///     (7_isize, 8_f64),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<isize>());
    /// # assert!(opaque_map.has_value_type::<f64>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let old_value = opaque_map.shift_insert::<isize, f64, RandomState, Global>(3, 6_isize, f64::MAX);
    /// let expected: TypedProjVec<(isize, f64)> = TypedProjVec::from([
    ///     (1_isize, 2_f64),
    ///     (2_isize, 3_f64),
    ///     (3_isize, 4_f64),
    ///     (6_isize, f64::MAX),
    ///     (4_isize, 5_f64),
    ///     (5_isize, 6_f64),
    ///     (7_isize, 8_f64),
    /// ]);
    /// let result: TypedProjVec<(isize, f64)> = opaque_map
    ///     .iter::<isize, f64, RandomState, Global>()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result, expected);
    /// assert_eq!(old_value, Some(7_f64));
    /// ```
    #[track_caller]
    pub fn shift_insert<K, V, S, A>(&mut self, index: usize, key: K, value: V) -> Option<V>
    where
        K: any::Any + Eq + hash::Hash,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.shift_insert(index, key, value)
    }

    /// Returns the entry in the index map corresponding to the given key.
    ///
    /// The resulting entry can be queried or manipulated directly, instead of going through the
    /// index map to do it.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     ("foo",  1_i32),
    ///     ("bar",  2_i32),
    ///     ("baz",  4_i32),
    ///     ("quux", 8_i32),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<&str>());
    /// # assert!(opaque_map.has_value_type::<i32>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert_eq!(opaque_map.len(), 4);
    ///
    /// assert_eq!(opaque_map.entry::<&str, i32, RandomState, Global>("foo").key(), &"foo");
    /// assert_eq!(opaque_map.entry::<&str, i32, RandomState, Global>("bar").key(), &"bar");
    /// assert_eq!(opaque_map.entry::<&str, i32, RandomState, Global>("baz").key(), &"baz");
    /// assert_eq!(opaque_map.entry::<&str, i32, RandomState, Global>("quux").key(), &"quux");
    ///
    /// // Vacant entries also return their keys.
    /// assert_eq!(opaque_map.entry::<&str, i32, RandomState, Global>("quuz").key(), &"quuz");
    /// assert_eq!(opaque_map.entry::<&str, i32, RandomState, Global>("garply").key(), &"garply");
    ///
    /// assert_eq!(opaque_map.entry::<&str, i32, RandomState, Global>("foo").index(), 0);
    /// assert_eq!(opaque_map.entry::<&str, i32, RandomState, Global>("bar").index(), 1);
    /// assert_eq!(opaque_map.entry::<&str, i32, RandomState, Global>("baz").index(), 2);
    /// assert_eq!(opaque_map.entry::<&str, i32, RandomState, Global>("quux").index(), 3);
    ///
    /// // Vacant entries have the length of the index map as their index.
    /// assert_eq!(opaque_map.entry::<&str, i32, RandomState, Global>("quuz").index(), opaque_map.len());
    /// assert_eq!(opaque_map.entry::<&str, i32, RandomState, Global>("garply").index(), opaque_map.len());
    ///
    /// assert_eq!(opaque_map.len(), 4);
    ///
    /// opaque_map.entry::<&str, i32, RandomState, Global>("quuz").insert_entry(16_i32);
    ///
    /// assert_eq!(opaque_map.len(), 5);
    ///
    /// assert_eq!(opaque_map.entry::<&str, i32, RandomState, Global>("quuz").index(), 4);
    /// assert_eq!(opaque_map.entry::<&str, i32, RandomState, Global>("garply").index(), 5);
    /// ```
    #[track_caller]
    pub fn entry<K, V, S, A>(&mut self, key: K) -> Entry<'_, K, V, A>
    where
        K: any::Any + Eq + hash::Hash,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.entry(key)
    }

    /// Creates a splicing iterator that replaces the specified storage range in the type-erased
    /// index map with the given `replace_with` iterator and yields the removed items. The argument
    /// `replace_with` does not need to be the same length as `range`.
    ///
    /// The `range` argument is removed even if the `Splice` iterator is not consumed before it is
    /// dropped.
    ///
    /// It is unspecified how many elements are removed from the type-erased index map
    /// if the `Splice` value is leaked.
    ///
    /// The input iterator `replace_with` is only consumed when the `Splice` value is dropped.
    /// If a key from the iterator matches an existing entry in the map (i.e. outside the range
    /// `range`), then the value will be updated in that position. Otherwise, the new entry will be
    /// inserted in the replaced `range`.
    ///
    /// # Panics
    ///
    /// This method panics under one of the following conditions:
    ///
    /// * If the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    ///   `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    ///   allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    ///   type `S`, and allocator type `A`, respectively.
    /// * If the starting point is greater than the end point or if the end point is greater than
    ///   the length of the index map.
    ///
    /// # Examples
    ///
    /// Splicing entries into an index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (0_usize, "foo"),
    ///     (1_usize, "bar"),
    ///     (2_usize, "baz"),
    ///     (3_usize, "quux"),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<&str>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let new = [
    ///     (7_usize, "garply"),
    ///     (8_usize, "corge"),
    ///     (9_usize, "grault"),
    /// ];
    /// let expected: TypedProjVec<(usize, &str)> = TypedProjVec::from([
    ///     (0_usize, "foo"),
    ///     (7_usize, "garply"),
    ///     (8_usize, "corge"),
    ///     (9_usize, "grault"),
    ///     (3_usize, "quux"),
    /// ]);
    /// let expected_removed = TypedProjVec::from([
    ///     (1_usize, "bar"),
    ///     (2_usize, "baz"),
    /// ]);
    /// let removed: TypedProjVec<(usize, &str)> = opaque_map.splice::<_, _, usize, &str, RandomState, Global>(1..3, new).collect();
    /// let result: TypedProjVec<(usize, &str)> = opaque_map
    ///     .iter::<usize, &str, RandomState, Global>()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result, expected);
    /// assert_eq!(removed, expected_removed);
    /// ```
    ///
    /// Using `splice` to insert new items into an index map efficiently at a specific position
    /// indicated by an empty range.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (0_usize, "foo"),
    ///     (4_usize, "grault")
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<&str>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let new = [
    ///     (1_usize, "bar"),
    ///     (2_usize, "baz"),
    ///     (3_usize, "quux"),
    /// ];
    /// let expected: TypedProjVec<(usize, &str)> = TypedProjVec::from([
    ///     (0_usize, "foo"),
    ///     (1_usize, "bar"),
    ///     (2_usize, "baz"),
    ///     (3_usize, "quux"),
    ///     (4_usize, "grault"),
    /// ]);
    /// let expected_removed = TypedProjVec::from([]);
    /// let removed: TypedProjVec<(usize, &str)> = opaque_map.splice::<_, _, usize, &str, RandomState, Global>(1..1, new).collect();
    /// let result: TypedProjVec<(usize, &str)> = opaque_map
    ///     .iter::<usize, &str, RandomState, Global>()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result, expected);
    /// assert_eq!(removed, expected_removed);
    /// ```
    #[track_caller]
    pub fn splice<R, I, K, V, S, A>(&mut self, range: R, replace_with: I) -> Splice<'_, I::IntoIter, K, V, S, A>
    where
        K: any::Any + Eq + hash::Hash,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync + Clone,
        R: ops::RangeBounds<usize>,
        I: IntoIterator<Item = (K, V)>,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.splice(range, replace_with)
    }

    /// Moves all entries from `other` into `self`, leaving `other` empty.
    ///
    /// This is equivalent to calling [`insert`] for each entry from `other` in order, which means
    /// that for keys that already exist in `self`, their value is updated in the current position.
    ///
    /// [`insert`]: OpaqueIndexMap::insert
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map1` and `map2` be index maps, `map1_before` be the state of `map1` before this
    /// method is called, `map2_before` be the state of `map2` before this method is called,
    /// `map1_after` be the state of `map1` after this method completes, and `map2_after` be the
    /// state of `map2` after this method completes.
    ///
    /// ## Specification Definitions
    ///
    /// We say that a key `k` is in the map `map` provided that
    ///
    /// ```text
    /// ∀ k :: K. (k ∈ map) ⇔ (∃ i ∈ [0, map.len()). map[i].key() = k).
    /// ```
    ///
    /// The **index** of a key `k` in `map` is defined by
    ///
    /// ```text
    /// index(map, k) := i such that map[i].key() = k.
    /// ```
    ///
    /// We can index an index map `map` by a key `k` by defining
    ///
    /// ```text
    /// map[key] := map[index(map, key)].
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { true }
    /// map1.append(map2)
    /// {
    ///     map1_after.len() ≤ map1_before.len() + map2_before.len()
    ///     ∧ map2_after.len() = 0
    ///     ∧ (∀ k ∈ map2_before. k ∈ map1_before ⇒ map1_after[k] = map2_before[k])
    ///     ∧ (∀ k ∈ map2_before. k ∉ map1_before ⇒ map1_after[k] = map2_before[k])
    ///     ∧ (∀ k ∈ map1_before. k ∉ map2_before ⇒ map1_after[k] = map1_before[k])
    ///     ∧ (∀ i ∈ [0, map1_before.len()). map1_after[i].key() = map1_before[i].key())
    ///     ∧ (∀ j1, j2 ∈ [0, map2_before.len()).
    ///          ((map2_before[j1].key() ∉ map1_before) ∧ (map2_before[j2].key() ∉ map1_before) ∧ (j1 < j2))
    ///          ⇒ (∃ i1, i2 ∈ [map1_before.len(), map1_after.len()).
    ///               i1 < i2
    ///               ∧ map1_after[i1].key() = map2_before[j1].key()
    ///               ∧ map1_after[i2].key() = map2_before[j2].key()
    ///          )
    ///     )
    /// }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics under the following conditions:
    ///
    /// * If the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of `self`, the
    ///   [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory allocator of
    ///   `self` do not match the requested key type `K`, value type `V`, hash builder type `S1`, and
    ///   allocator type `A1`, respectively.
    /// * If the [`TypeId`] of the keys of `other`, the [`TypeId`] of the values of `other`, the
    ///   [`TypeId`] for the hash builder of `other`, and the [`TypeId`] of the memory allocator of
    ///   `other` do not match the requested key type `K`, value type `V`, hash builder type `S2`,
    ///   and allocator type `A2`, respectively.
    ///
    /// # Examples
    ///
    /// Appending one index map to another when they have no overlapping keys.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map1 = OpaqueIndexMap::from([
    ///     ("foo",  0_usize),
    ///     ("bar",  1_usize),
    ///     ("baz",  2_usize),
    ///     ("quux", 3_usize),
    /// ]);
    /// #
    /// # assert!(opaque_map1.has_key_type::<&str>());
    /// # assert!(opaque_map1.has_value_type::<usize>());
    /// # assert!(opaque_map1.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map1.has_allocator_type::<Global>());
    /// #
    /// let mut opaque_map2 = OpaqueIndexMap::from([
    ///     ("garply", 4_usize),
    ///     ("corge",  5_usize),
    ///     ("grault", 6_usize),
    /// ]);
    /// #
    /// # assert!(opaque_map2.has_key_type::<&str>());
    /// # assert!(opaque_map2.has_value_type::<usize>());
    /// # assert!(opaque_map2.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map2.has_allocator_type::<Global>());
    /// #
    /// assert_eq!(opaque_map1.len(), 4);
    /// assert_eq!(opaque_map2.len(), 3);
    ///
    /// opaque_map1.append::<&str, usize, RandomState, RandomState, Global>(&mut opaque_map2);
    ///
    /// assert_eq!(opaque_map1.len(), 7);
    /// assert_eq!(opaque_map2.len(), 0);
    ///
    /// let expected_keys = ["foo", "bar", "baz", "quux", "garply", "corge", "grault"];
    /// let result_keys = TypedProjVec::from_iter(
    ///     opaque_map1.keys::<&str, usize, RandomState, Global>().cloned()
    /// );
    ///
    /// assert_eq!(result_keys.as_slice(), expected_keys.as_slice());
    ///
    /// let expected_values = [0_usize, 1_usize, 2_usize, 3_usize, 4_usize, 5_usize, 6_usize];
    /// let result_values = TypedProjVec::from_iter(
    ///     opaque_map1.values::<&str, usize, RandomState, Global>().cloned()
    /// );
    ///
    /// assert_eq!(result_values.as_slice(), expected_values.as_slice());
    /// ```
    ///
    /// Appending one index map to another when they have overlapping keys.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map1 = OpaqueIndexMap::from([
    ///     ("foo",  0_usize),
    ///     ("bar",  1_usize),
    ///     ("baz",  2_usize),
    ///     ("quux", 3_usize),
    /// ]);
    /// #
    /// # assert!(opaque_map1.has_key_type::<&str>());
    /// # assert!(opaque_map1.has_value_type::<usize>());
    /// # assert!(opaque_map1.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map1.has_allocator_type::<Global>());
    /// #
    /// let mut opaque_map2 = OpaqueIndexMap::from([
    ///     ("garply", 4_usize),
    ///     ("corge",  5_usize),
    ///     ("grault", 6_usize),
    ///     ("baz", usize::MAX),
    /// ]);
    /// #
    /// # assert!(opaque_map2.has_key_type::<&str>());
    /// # assert!(opaque_map2.has_value_type::<usize>());
    /// # assert!(opaque_map2.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map2.has_allocator_type::<Global>());
    /// #
    ///
    /// assert_eq!(opaque_map1.len(), 4);
    /// assert_eq!(opaque_map2.len(), 4);
    ///
    /// opaque_map1.append::<&str, usize, RandomState, RandomState, Global>(&mut opaque_map2);
    ///
    /// assert_eq!(opaque_map1.len(), 7);
    /// assert_eq!(opaque_map2.len(), 0);
    ///
    /// let expected_keys = ["foo", "bar", "baz", "quux", "garply", "corge", "grault"];
    /// let result_keys = TypedProjVec::from_iter(
    ///     opaque_map1.keys::<&str, usize, RandomState, Global>().cloned()
    /// );
    ///
    /// assert_eq!(result_keys.as_slice(), expected_keys.as_slice());
    ///
    /// let expected_values = [0_usize, 1_usize, usize::MAX, 3_usize, 4_usize, 5_usize, 6_usize];
    /// let result_values = TypedProjVec::from_iter(
    ///     opaque_map1.values::<&str, usize, RandomState, Global>().cloned()
    /// );
    ///
    /// assert_eq!(result_values.as_slice(), expected_values.as_slice());
    /// ```
    #[track_caller]
    pub fn append<K, V, S1, S2, A>(&mut self, other: &mut OpaqueIndexMap)
    where
        K: any::Any + Eq + hash::Hash,
        V: any::Any,
        S1: any::Any + hash::BuildHasher + Send + Sync,
        S1::Hasher: any::Any + hash::Hasher + Send + Sync,
        S2: any::Any + hash::BuildHasher + Send + Sync,
        S2::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S1, A>();
        let proj_other = other.as_proj_mut::<K, V, S2, A>();

        proj_self.append(proj_other);
    }
}

impl OpaqueIndexMap {
    /// Removes and returns the last entry in the index map.
    ///
    /// If `self` is nonempty, this method returns the last key-value pair in the index map
    /// as `Some((key, value))`. If `self` is empty, this method returns `None`.
    ///
    /// This method preserves the order of the remaining elements in the collection.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes. Let `result` be the return value of this method after it completes.
    ///
    /// ## Specification Definitions
    ///
    /// The **last entry** in the map `map` when `map` is non-empty is defined by
    ///
    /// ```text
    /// last(map) := map[map.len() - 1].
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { map_before.len() > 0 }
    /// map.pop()
    /// {
    ///     result = Some(last(map_before))
    ///     ∧ map_after.len() = map_before.len() - 1
    ///     ∧ (∀ i ∈ [0, map_after.len()). map_after[i] = map_before[i])
    /// }
    ///
    /// { map_before.len() = 0 }
    /// map.pop()
    /// { result = None ∧ map_after.len() = 0 }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// Popping from a nonempty index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     ("foo",  0_usize),
    ///     ("bar",  1_usize),
    ///     ("baz",  2_usize),
    ///     ("quux", 3_usize),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<&str>());
    /// # assert!(opaque_map.has_value_type::<usize>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert_eq!(opaque_map.len(), 4);
    ///
    /// let expected = Some(("quux", 3_usize));
    /// let result = opaque_map.pop::<&str, usize, RandomState, Global>();
    ///
    /// assert_eq!(result, expected);
    /// assert_eq!(opaque_map.len(), 3);
    /// ```
    ///
    /// Popping from an empty index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::new::<&str, usize>();
    /// #
    /// # assert!(opaque_map.has_key_type::<&str>());
    /// # assert!(opaque_map.has_value_type::<usize>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert!(opaque_map.is_empty());
    ///
    /// let expected = None;
    /// let result = opaque_map.pop::<&str, usize, RandomState, Global>();
    ///
    /// assert_eq!(result, expected);
    /// assert!(opaque_map.is_empty());
    /// ```
    #[track_caller]
    #[doc(alias = "pop_last")]
    pub fn pop<K, V, S, A>(&mut self) -> Option<(K, V)>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.pop()
    }

    /// Retains only the key-value pairs specified by the predicate.
    ///
    /// This method removes all entries `e` for which `keep(&e)` returns `false`. This method
    /// operates in place, visiting each element exactly once in the original order, and preserves
    /// the storage order of the retained entries. Stated differently, this method keeps only those
    /// entries `e` for which `keep(&e)` returns `true`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes. Let `result` be the return value of this method after it completes. Let
    /// `keep` be the filtering function for entries in `map`.
    ///
    /// ## Specification Definitions
    ///
    /// We say that a key-value pair `e :: (K, V)` is an **entry** in the map `map` if and only if
    ///
    /// ```text
    /// ∀ e :: (K, V). e ∈ map ⇔ (∃ i ∈ [0, map.len()). map[i] = e).
    /// ```
    ///
    /// The set of **keys** in the map `map` is defined as
    ///
    /// ```text
    /// keys(map) := { k :: K | ∃ i ∈ [0, map.len()). map[i].key() = k }
    /// ```
    ///
    /// or equivalently
    ///
    /// ```text
    /// ∀ k :: K. (k ∈ keys(map)) ⇔ (∃ i ∈ [0, map.len()). map[i].key() = k).
    /// ```
    ///
    /// The **index** of a key `k` in `map` is defined by
    ///
    /// ```text
    /// index(map, k) := i such that map[i].key() = k.
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { true }
    /// map.retain(keep)
    /// {
    ///     map_after.len() ≤ map_before.len()
    ///     ∧ (∀ (k, v) ∈ map_after. k ∈ map_before ∧ keep(k, v))
    ///     ∧ (∀ (k, v) ∈ map_before. keep(k, v) ⇒
    ///         (k, v') ∈ map_after
    ///         ∧ (if f mutated v, then v' is the updated value, else v' = v)
    ///       )
    ///     ∧ (∀ (k, v) ∈ map_before. ¬keep(k, v) ⇒ k ∉ keys(map_after))
    ///     ∧ (∀ k1, k2 ∈ keys(map_after).
    ///         index(map_before, k1) < index(map_before, k2) ⇒ index(map_after, k1) < index(map_after, k2)
    ///       )
    /// }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// fn is_odd(k: &&str, v: &mut usize) -> bool { k.len() % 2 != 0 }
    ///
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     ("foo",    0_usize),
    ///     ("bar",    1_usize),
    ///     ("baz",    2_usize),
    ///     ("quux",   3_usize),
    ///     ("quuz",   4_usize),
    ///     ("corge",  5_usize),
    ///     ("grault", 6_usize),
    ///     ("garply", 7_usize),
    ///     ("waldo",  8_usize),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<&str>());
    /// # assert!(opaque_map.has_value_type::<usize>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// opaque_map.retain::<_, &str, usize, RandomState, Global>(is_odd);
    /// let expected = TypedProjVec::from([
    ///     ("foo",    0_usize),
    ///     ("bar",    1_usize),
    ///     ("baz",    2_usize),
    ///     ("corge",  5_usize),
    ///     ("waldo",  8_usize),
    /// ]);
    /// let result: TypedProjVec<(&str, usize)> = opaque_map
    ///     .iter::<&str, usize, RandomState, Global>()
    ///     .map(|(k, v)| (k.clone(), v.clone()))
    ///     .collect();
    ///
    /// assert_eq!(result, expected);
    /// ```
    #[track_caller]
    pub fn retain<F, K, V, S, A>(&mut self, keep: F)
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
        F: FnMut(&K, &mut V) -> bool,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.retain(keep)
    }

    /// Sorts the entries in the index map into the sorted ordering of the keys as defined by the
    /// default ordering of the keys.
    ///
    /// An index map is in **sorted order by key** if it satisfies the following property: let `e1`
    /// and `e2` be entries in `self`. Then `e1.key() <= e2.key()` if and only if
    /// `e1.index() <= e2.index()`. More precisely, given the index map `self`
    ///
    /// ```text
    /// forall e1, e2 in self. e1.index() <= e2.index() <-> e1.key() <= e2.key()
    /// ```
    ///
    /// or equivalently over key-value pairs
    ///
    /// ```text
    /// forall i1, i2 in [0, self.len()). forall k1, k2 :: K. forall v1, v2 :: V.
    /// (i1, (k1, v1)), (i2, (k2, v2)) in self --> i1 <= i2 <-> k1 <= k2.
    /// ```
    ///
    /// Otherwise, the index map is in **unsorted order by key**, or is **unsorted** for short.
    ///
    /// This means that an index map is in sorted order if the total ordering of the keys in the map
    /// matches the storage order of the entries in the map. The keys are **sorted** if the index
    /// map is in sorted order, and **unsorted** otherwise.
    ///
    /// After this method completes, the index map will be in stable sorted order.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Specification Definitions
    ///
    /// We say that a key-value pair `(k, v) :: (K, V)` is an **entry** in the map `map` if and
    /// only if
    ///
    /// ```text
    /// ∀ (k, v) :: (K, V). (k, v) ∈ map ⇔ (∃ i ∈ [0, map.len()). map[i] = (k, v)).
    /// ```
    ///
    /// An index map `map1` is a **permutation** of an index map `map2` if it satisfies
    ///
    /// ```text
    /// is_permutation(map1, map2) :=
    ///     map1.len() = map2.len()
    ///     ∧ (∀ i ∈ [0, map1.len()). ∃ j ∈ [0, map2.len()). map1[i] = map2[j])
    ///     ∧ (∀ i ∈ [0, map2.len()). ∃ j ∈ [0, map1.len()). map2[i] = map1[j])
    /// ```
    ///
    /// Note that multiset equality is not needed here because every key is unique in an index map.
    ///
    /// The index map `map` is **sorted** with respect to its keys if
    ///
    /// ```text
    /// is_sorted(map) := ∀ i ∈ [0, map.len() - 1). map[i].key() ≤ map[i + 1].key().
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { true }
    /// map.sort_keys()
    /// {
    ///     map_after.len() = map_before.len()
    ///     ∧ is_permutation(map_after, map_before)
    ///     ∧ is_sorted(map_after)
    /// }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// This sort is stable because keys are unique.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (5_isize, 'e'),
    ///     (2_isize, 'b'),
    ///     (1_isize, 'a'),
    ///     (4_isize, 'd'),
    ///     (3_isize, 'c'),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<isize>());
    /// # assert!(opaque_map.has_value_type::<char>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// opaque_map.sort_keys::<isize, char, RandomState, Global>();
    /// let expected = [(1_isize, 'a'), (2_isize, 'b'), (3_isize, 'c'), (4_isize, 'd'), (5_isize, 'e')];
    ///
    /// assert_eq!(opaque_map.as_slice::<isize, char, RandomState, Global>(), expected.as_slice());
    /// ```
    #[track_caller]
    pub fn sort_keys<K, V, S, A>(&mut self)
    where
        K: any::Any + Ord,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.sort_keys()
    }

    /// Sorts the entries in the index map into the sorted ordering of the entries as defined by the
    /// provided comparison function.
    ///
    /// After this method completes, the index map will be in stable sorted order with the ordering
    /// defined by the comparison function.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Specification Definitions
    ///
    /// A **comparator** is a map `cmp : K ⨯ V ⨯ K ⨯ V → Ordering` such that given entries
    /// `(k1, v1) :: (K, V)` and `(k2, v2) :: (K, V)` from a partially ordered collection of
    /// entries
    ///
    /// ```text
    /// cmp(k1, v1, k2, v2) = Ordering::Greater when (k1, v1) > (k2, v2)
    /// cmp(k1, v2, k2, v2) = Ordering::Less    when (k1, v1) < (k2, v2)
    /// cmp(k1, v1, k2, v2) = Ordering::Equal   when (k1, v1) = (k2, v2)
    /// ```
    ///
    /// An index map `map1` is a **permutation** of an index map `map2` if it satisfies
    ///
    /// ```text
    /// is_permutation(map1, map2) :=
    ///     map1.len() = map2.len()
    ///     ∧ (∀ i ∈ [0, map1.len()). ∃ j ∈ [0, map2.len()). map1[i] = map2[j])
    ///     ∧ (∀ i ∈ [0, map2.len()). ∃ j ∈ [0, map1.len()). map2[i] = map1[j])
    /// ```
    ///
    /// Note that multiset equality is not needed here because every key is unique in an index map.
    ///
    /// The **index** of a key `k` in `map` is defined by
    ///
    /// ```text
    /// index(map, k) := i such that map[i].key() = k.
    /// ```
    ///
    /// The index map `map` is **sorted** with respect to the comparator `cmp` if
    ///
    /// ```text
    /// is_sorted(map, cmp) := ∀ i ∈ [0, map.len() - 1).
    ///     cmp(map[i].key(), map[i].value(), map[i + 1].key(), map[i + 1].value()) != Greater
    /// ```
    ///
    /// holds. We say that the sort is **stable** if and only if
    ///
    /// ```text
    /// is_stable_sorted(map, original, cmp) :=
    ///     is_sorted(map, cmp)
    ///     ∧ ∀ i, j ∈ [0, original.len()).
    ///         (cmp(original[i].key(), original[i].value(), original[j].key(), original[j].value()) = Equal ∧ (i < j))
    ///         ⇒
    ///         (index(map, original[i].key()) < index(map, original[j].key()))
    /// ```
    ///
    /// holds.
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { true }
    /// map.sort_by(cmp)
    /// {
    ///     map_after.len() = map_before.len()
    ///     ∧ is_permutation(map_after, map_before)
    ///     ∧ is_stable_sorted(map_after, map_before, cmp)
    /// }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 'b'),
    ///     (0_usize, '*'),
    ///     (3_usize, 'c'),
    ///     (2_usize, 'a'),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<char>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// opaque_map.sort_by::<_, usize, char, RandomState, Global>(|k1, v1, k2, v2| v1.cmp(&v2));
    /// let expected = [(0_usize, '*'), (2_usize, 'a'), (1_usize, 'b'), (3_usize, 'c')];
    ///
    /// assert_eq!(opaque_map.as_slice::<usize, char, RandomState, Global>(), expected.as_slice());
    /// ```
    #[track_caller]
    pub fn sort_by<F, K, V, S, A>(&mut self, cmp: F)
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
        F: FnMut(&K, &V, &K, &V) -> cmp::Ordering,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.sort_by(cmp)
    }

    /// Returns a moving iterator that returns the entries of the index map in sorted order as
    /// defined by the provided comparison function.
    ///
    /// The resulting moving iterator will return the entries of the index map in stable sorted
    /// order with the ordering defined by the comparison function.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 'b'),
    ///     (0_usize, '*'),
    ///     (3_usize, 'c'),
    ///     (2_usize, 'a'),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<char>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let result: TypedProjVec<(usize, char)> = opaque_map
    ///     .sorted_by::<_, usize, char, RandomState, Global>(|k1, v1, k2, v2| v1.cmp(&v2))
    ///     .collect();
    /// let expected = TypedProjVec::from([
    ///     (0_usize, '*'),
    ///     (2_usize, 'a'),
    ///     (1_usize, 'b'),
    ///     (3_usize, 'c')
    /// ]);
    ///
    /// assert_eq!(result.as_slice(), expected.as_slice());
    /// ```
    #[track_caller]
    pub fn sorted_by<F, K, V, S, A>(self, cmp: F) -> IntoIter<K, V, A>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
        F: FnMut(&K, &V, &K, &V) -> cmp::Ordering,
    {
        let proj_self = self.into_proj::<K, V, S, A>();

        proj_self.sorted_by(cmp)
    }

    /// Sorts the entries in the index map into the sorted ordering of the keys as defined by the
    /// default ordering of the keys, but may not preserve the order of equal values.
    ///
    /// After this method completes, the index map will be in unstable sorted order.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Specification Definitions
    ///
    /// We say that a key-value pair `(k, v) :: (K, V)` is an **entry** in the map `map` if and
    /// only if
    ///
    /// ```text
    /// ∀ (k, v) :: (K, V). (k, v) ∈ map ⇔ (∃ i ∈ [0, map.len()). map[i] = (k, v)).
    /// ```
    ///
    /// An index map `map1` is a **permutation** of an index map `map2` if it satisfies
    ///
    /// ```text
    /// is_permutation(map1, map2) :=
    ///     map1.len() = map2.len()
    ///     ∧ (∀ i ∈ [0, map1.len()). ∃ j ∈ [0, map2.len()). map1[i] = map2[j])
    ///     ∧ (∀ i ∈ [0, map2.len()). ∃ j ∈ [0, map1.len()). map2[i] = map1[j])
    /// ```
    ///
    /// Note that multiset equality is not needed here because every key is unique in an index map.
    ///
    /// The index map `map` is **sorted** with respect to its keys if
    ///
    /// ```text
    /// is_sorted(map) := ∀ i ∈ [0, map.len() - 1). map[i].key() ≤ map[i + 1].key().
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { true }
    /// map.sort_unstable_keys()
    /// {
    ///     map_after.len() = map_before.len()
    ///     ∧ is_permutation(map_after, map_before)
    ///     ∧ is_sorted(map_after)
    /// }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (5_isize, 'e'),
    ///     (2_isize, 'b'),
    ///     (1_isize, 'a'),
    ///     (4_isize, 'd'),
    ///     (3_isize, 'c'),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<isize>());
    /// # assert!(opaque_map.has_value_type::<char>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// opaque_map.sort_unstable_keys::<isize, char, RandomState, Global>();
    /// let expected = [
    ///     (1_isize, 'a'),
    ///     (2_isize, 'b'),
    ///     (3_isize, 'c'),
    ///     (4_isize, 'd'),
    ///     (5_isize, 'e'),
    /// ];
    ///
    /// assert_eq!(opaque_map.as_slice::<isize, char, RandomState, Global>(), expected.as_slice());
    /// ```
    #[track_caller]
    pub fn sort_unstable_keys<K, V, S, A>(&mut self)
    where
        K: any::Any + Ord,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.sort_unstable_keys()
    }

    /// Sorts the entries in the index map in place into the sorted ordering of the entries as
    /// defined by the provided comparison function, but may not preserve the order of equal values.
    ///
    /// After this method completes, the index map will be in unstable sorted order with the
    /// ordering defined by the comparison function.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Specification Definitions
    ///
    /// A **comparator** is a map `cmp : K ⨯ V ⨯ K ⨯ V → Ordering` such that given entries
    /// `(k1, v1) :: (K, V)` and `(k2, v2) :: (K, V)` from a partially ordered collection of
    /// entries
    ///
    /// ```text
    /// cmp(k1, v1, k2, v2) = Ordering::Greater when (k1, v1) > (k2, v2)
    /// cmp(k1, v2, k2, v2) = Ordering::Less    when (k1, v1) < (k2, v2)
    /// cmp(k1, v1, k2, v2) = Ordering::Equal   when (k1, v1) = (k2, v2)
    /// ```
    ///
    /// An index map `map1` is a **permutation** of an index map `map2` if it satisfies
    ///
    /// ```text
    /// is_permutation(map1, map2) :=
    ///     map1.len() = map2.len()
    ///     ∧ (∀ i ∈ [0, map1.len()). ∃ j ∈ [0, map2.len()). map1[i] = map2[j])
    ///     ∧ (∀ i ∈ [0, map2.len()). ∃ j ∈ [0, map1.len()). map2[i] = map1[j])
    /// ```
    ///
    /// Note that multiset equality is not needed here because every key is unique in an index map.
    ///
    /// The index map `map` is **sorted** with respect to the comparator `cmp` if
    ///
    /// ```text
    /// is_sorted(map, cmp) := ∀ i ∈ [0, map.len() - 1).
    ///     cmp(map[i].key(), map[i].value(), map[i + 1].key(), map[i + 1].value()) != Greater
    /// ```
    ///
    /// holds.
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { true }
    /// map.sort_unstable_by(cmp)
    /// {
    ///     map_after.len() = map_before.len()
    ///     ∧ is_permutation(map_after, map_before)
    ///     ∧ is_sorted(map_after cmp)
    /// }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (6_isize, 'a'),
    ///     (2_isize, 'b'),
    ///     (1_isize, 'a'),
    ///     (4_isize, 'a'),
    ///     (3_isize, 'b'),
    ///     (5_isize, 'b'),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<isize>());
    /// # assert!(opaque_map.has_value_type::<char>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let result = {
    ///     let mut _map = opaque_map.clone::<isize, char, RandomState, Global>();
    ///     _map.sort_unstable_by::<_, isize, char, RandomState, Global>(|k1, v1, k2, v2| {
    ///         match v1.cmp(&v2) {
    ///             Ordering::Equal => k1.cmp(&k2),
    ///             Ordering::Greater => Ordering::Greater,
    ///             Ordering::Less => Ordering::Less,
    ///         }
    ///     });
    ///     _map
    /// };
    /// #
    /// # assert!(result.has_key_type::<isize>());
    /// # assert!(result.has_value_type::<char>());
    /// # assert!(result.has_build_hasher_type::<RandomState>());
    /// # assert!(result.has_allocator_type::<Global>());
    /// #
    /// let expected = [
    ///     (1_isize, 'a'),
    ///     (4_isize, 'a'),
    ///     (6_isize, 'a'),
    ///     (2_isize, 'b'),
    ///     (3_isize, 'b'),
    ///     (5_isize, 'b'),
    /// ];
    ///
    /// assert_eq!(result.as_slice::<isize, char, RandomState, Global>(), expected.as_slice());
    /// ```
    #[track_caller]
    pub fn sort_unstable_by<F, K, V, S, A>(&mut self, cmp: F)
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
        F: FnMut(&K, &V, &K, &V) -> cmp::Ordering,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.sort_unstable_by(cmp)
    }

    /// Returns a moving iterator that returns the entries of the index map in sorted order as
    /// defined by the provided comparison function.
    ///
    /// The resulting moving iterator will return the elements in unstable sorted order.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (6_isize, 'a'),
    ///     (2_isize, 'b'),
    ///     (1_isize, 'a'),
    ///     (4_isize, 'a'),
    ///     (3_isize, 'b'),
    ///     (5_isize, 'b'),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<isize>());
    /// # assert!(opaque_map.has_value_type::<char>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let result: TypedProjVec<(isize, char)> = opaque_map
    ///     .sorted_unstable_by::<_, isize, char, RandomState, Global>(|k1, v1, k2, v2| {
    ///         match v1.cmp(&v2) {
    ///             Ordering::Equal => k1.cmp(&k2),
    ///             Ordering::Greater => Ordering::Greater,
    ///             Ordering::Less => Ordering::Less,
    ///         }
    ///     })
    ///     .collect();
    /// let expected = TypedProjVec::from([
    ///     (1_isize, 'a'),
    ///     (4_isize, 'a'),
    ///     (6_isize, 'a'),
    ///     (2_isize, 'b'),
    ///     (3_isize, 'b'),
    ///     (5_isize, 'b'),
    /// ]);
    ///
    /// assert_eq!(result.as_slice(), expected.as_slice());
    /// ```
    #[inline]
    #[track_caller]
    pub fn sorted_unstable_by<F, K, V, S, A>(self, cmp: F) -> IntoIter<K, V, A>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
        F: FnMut(&K, &V, &K, &V) -> cmp::Ordering,
    {
        let proj_self = self.into_proj::<K, V, S, A>();

        proj_self.sorted_unstable_by(cmp)
    }

    /// Sort the entries of the index map in place using a sort-key extraction function.
    ///
    /// During sorting, the function is called at most once per entry, by using temporary storage
    /// to remember the results of its evaluation. The order of calls to the function is
    /// unspecified. The sort is stable.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (0_usize,  4_i32),
    ///     (1_usize, -8_i32),
    ///     (2_usize, -1_i32),
    ///     (3_usize, -10_i32),
    ///     (4_usize,  2_i32),
    ///     (5_usize,  11_i32),
    ///     (6_usize,  7_i32),
    ///     (7_usize,  100_i32),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<i32>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// // Strings are sorted by lexicographical order.
    /// opaque_map.sort_by_cached_key::<_, _, usize, i32, RandomState, Global>(|k, v| v.to_string());
    /// let expected = [
    ///     (2_usize, -1_i32),
    ///     (3_usize, -10_i32),
    ///     (1_usize, -8_i32),
    ///     (7_usize,  100_i32),
    ///     (5_usize,  11_i32),
    ///     (4_usize,  2_i32),
    ///     (0_usize,  4_i32),
    ///     (6_usize,  7_i32),
    /// ];
    ///
    /// assert_eq!(opaque_map.as_slice::<usize, i32, RandomState, Global>(), expected.as_slice());
    /// ```
    #[track_caller]
    pub fn sort_by_cached_key<T, F, K, V, S, A>(&mut self, mut sort_key: F)
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
        T: Ord,
        F: FnMut(&K, &V) -> T,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.sort_by_cached_key(&mut sort_key)
    }

    /// Binary searches a sorted index map for the given key. If the index map is unsorted, the
    /// returned result is unspecified and meaningless.
    ///
    /// If the entry with the key `key` is found in the map, then this method returns `Ok(index)`,
    /// where `index` is the storage index of the entry with key `key` in the map. If the entry
    /// with the key `key` is not found in the map, then this method returns `Err(new_index)` where
    /// `new_index` is the position in the storage where an entry with the key `key` could be
    /// inserted to maintain the sorted order.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// Binary searching a sorted index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from_iter((1_isize..=26_isize).zip('a'..='z'));
    /// #
    /// # assert!(opaque_map.has_key_type::<isize>());
    /// # assert!(opaque_map.has_value_type::<char>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// for (i, (key, value)) in (1_isize..=26_isize).zip('a'..='z').enumerate() {
    ///     let result = opaque_map.binary_search_keys::<isize, char, RandomState, Global>(&key);
    ///     assert_eq!(result, Ok(i));
    /// }
    /// ```
    #[track_caller]
    pub fn binary_search_keys<K, V, S, A>(&self, key: &K) -> Result<usize, usize>
    where
        K: any::Any + Ord,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj::<K, V, S, A>();

        proj_self.binary_search_keys(key)
    }

    /// Binary searches a sorted index map using a given comparator function. If the index map is
    /// unsorted, the returned result is unspecified and meaningless.
    ///
    /// The comparator function should return an order code that indicates whether its argument is
    /// `Less`, `Equal` or `Greater` than the desired target.
    ///
    /// If the index map is not in sorted order or if the comparator function does not implement an
    /// order consistent with the sorted order of the underlying index map, the returned result is
    /// unspecified and meaningless.
    ///
    /// If an entry satisfying the comparator is found in the map, then this method returns
    /// `Ok(index)`, where `index` is the storage index of the entry found in the map. If an entry
    /// satisfying the comparator is not found in the map, then this method returns
    /// `Err(new_index)` where `new_index` is the position in the storage where an entry with the
    /// key `key` could be inserted to maintain the sorted order. If multiple entries in the index
    /// map satisfy the comparator, then any one of them could be returned. The index is chosen
    /// deterministically, but this method makes no guarantees as to how it picks that index.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// Binary searching a sorted index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from_iter((1_isize..=26_isize).zip('a'..='z'));
    /// #
    /// # assert!(opaque_map.has_key_type::<isize>());
    /// # assert!(opaque_map.has_value_type::<char>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let expected = Ok(23);
    /// let result = opaque_map.binary_search_by::<_, isize, char, RandomState, Global>(|k, v| v.cmp(&'x'));
    ///
    /// assert_eq!(result, expected);
    ///
    /// assert!('*' < 'a');
    ///
    /// let expected = Err(0);
    /// let result = opaque_map.binary_search_by::<_, isize, char, RandomState, Global>(|k, v| v.cmp(&'*'));
    ///
    /// assert_eq!(result, expected);
    /// ```
    ///
    /// Binary searching a sorted index map with repeating values.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 'a'), (2_usize, 'b'), (3_usize, 'c'),
    ///     (4_usize, 'd'), (5_usize, 'd'), (6_usize, 'd'),  (7_usize, 'd'),
    ///     (8_usize, 'e'), (9_usize, 'f'), (10_usize, 'g'), (11_usize, 'h'),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<char>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert_eq!(opaque_map.binary_search_by::<_, usize, char, RandomState, Global>(|&k, &v| v.cmp(&'a')), Ok(0));
    /// assert_eq!(opaque_map.binary_search_by::<_, usize, char, RandomState, Global>(|&k, &v| v.cmp(&'b')), Ok(1));
    /// assert_eq!(opaque_map.binary_search_by::<_, usize, char, RandomState, Global>(|&k, &v| v.cmp(&'c')), Ok(2));
    ///
    /// let result = opaque_map.binary_search_by::<_, usize, char, RandomState, Global>(|&k, &v| v.cmp(&'d'));
    /// assert!(match result { Ok(3..=6) => true, _ => false });
    ///
    /// assert_eq!(opaque_map.binary_search_by::<_, usize, char, RandomState, Global>(|&k, &v| v.cmp(&'e')), Ok(7));
    /// assert_eq!(opaque_map.binary_search_by::<_, usize, char, RandomState, Global>(|&k, &v| v.cmp(&'f')), Ok(8));
    /// assert_eq!(opaque_map.binary_search_by::<_, usize, char, RandomState, Global>(|&k, &v| v.cmp(&'g')), Ok(9));
    /// assert_eq!(opaque_map.binary_search_by::<_, usize, char, RandomState, Global>(|&k, &v| v.cmp(&'h')), Ok(10));
    /// ```
    #[inline]
    #[track_caller]
    pub fn binary_search_by<F, K, V, S, A>(&self, f: F) -> Result<usize, usize>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
        F: FnMut(&K, &V) -> cmp::Ordering,
    {
        let proj_self = self.as_proj::<K, V, S, A>();

        proj_self.binary_search_by(f)
    }

    /// Binary searches the index map with a key extraction function.
    ///
    /// This method assumes that the index map is in sorted order by the key, for instance with
    /// [`sort_by_key`] using the same key extraction function. If the index map is not sorted by
    /// the key, the returned result is unspecified and meaningless.
    ///
    /// If an entry matching the key is found in the map, then this method returns `Ok(index)`,
    /// where `index` is the storage index of the entry found in the map. If an entry matching the
    /// key is not found in the map, then this method returns `Err(new_index)` where `new_index`
    /// is the position in the storage where an entry with the matching key could be inserted to
    /// maintain the sorted order. If multiple entries in the index map match the key, then any one
    /// of them could be returned. The index is chosen deterministically, but this method makes no
    /// guarantees as to how it picks that index.
    ///
    /// See also [`binary_search`], [`binary_search_by`], and [`partition_point`].
    ///
    /// [`sort_by_key`]: OpaqueIndexMap::sort_by_key
    /// [`binary_search`]: OpaqueIndexMap::binary_search
    /// [`binary_search_by`]: OpaqueIndexMap::binary_search_by
    /// [`partition_point`]: OpaqueIndexMap::partition_point
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (0_usize,  0_isize),
    ///     (1_usize,  1_isize), (2_usize, 1_isize), (3_usize, 1_isize), (4_usize, 1_isize),
    ///     (5_usize,  2_isize),
    ///     (6_usize,  3_isize),
    ///     (7_usize,  5_isize),
    ///     (8_usize,  8_isize),
    ///     (9_usize,  13_isize),
    ///     (10_usize, 21_isize),
    ///     (11_usize, 34_isize),
    ///     (12_usize, 55_isize),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<isize>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert_eq!(opaque_map.binary_search_by_key::<_, _, usize, isize, RandomState, Global>(&13, |&a, &b| b),  Ok(9));
    /// assert_eq!(opaque_map.binary_search_by_key::<_, _, usize, isize, RandomState, Global>(&4, |&a, &b| b),   Err(7));
    /// assert_eq!(opaque_map.binary_search_by_key::<_, _, usize, isize, RandomState, Global>(&100, |&a, &b| b), Err(13));
    ///
    /// let result = opaque_map.binary_search_by_key::<_, _, usize, isize, RandomState, Global>(&1, |&a, &b| b);
    ///
    /// assert!(match result { Ok(1..=4) => true, _ => false, });
    /// ```
    #[inline]
    #[track_caller]
    pub fn binary_search_by_key<B, F, K, V, S, A>(&self, b: &B, f: F) -> Result<usize, usize>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
        F: FnMut(&K, &V) -> B,
        B: Ord,
    {
        let proj_self = self.as_proj::<K, V, S, A>();

        proj_self.binary_search_by_key(b, f)
    }

    /// Returns the index of the partition point of a sorted index map according to the given
    /// predicate (the index of the first element of the second partition).
    ///
    /// This method assumes that the storage order of the entries in the index map is partitioned
    /// according to the predicate. That is, all entries for which the predicate returns `true` are
    /// at the start of the storage, and all entries for which the predicate returns `false` are at
    /// the end of the index map's storage. If the index map's storage order does not partition
    /// according to the predicate, the result is unspecified and meaningless.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// Finding the partition point of a partitioned index map where not every entry matches the
    /// predicate.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (0_usize, 1_isize),
    ///     (1_usize, 2_isize),
    ///     (2_usize, 2_isize),
    ///     (3_usize, 3_isize),
    ///     (4_usize, 5_isize),
    ///     (5_usize, 5_isize),
    ///     (6_usize, 5_isize),
    ///     (7_usize, 6_isize),
    ///     (8_usize, 9_isize),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<isize>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert_eq!(opaque_map.partition_point::<_, usize, isize, RandomState, Global>(|&k, &v| v < 5_isize), 4);
    /// ```
    ///
    /// Finding the partition point of an index map where every entry matches the predicate.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// fn is_power_of_two(n: usize) -> bool {
    ///     n != 0 && (n & (n - 1)) == 0
    /// }
    ///
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (0_usize, 1_usize),
    ///     (1_usize, 2_usize),
    ///     (2_usize, 4_usize),
    ///     (3_usize, 8_usize),
    ///     (4_usize, 16_usize),
    ///     (5_usize, 32_usize),
    ///     (6_usize, 64_usize),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<usize>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert_eq!(opaque_map.partition_point::<_, usize, usize, RandomState, Global>(|&k, &v| is_power_of_two(v)), opaque_map.len());
    /// ```
    ///
    /// Finding the partition point of an index map where no entry matches the predicate.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// fn is_power_of_two(n: usize) -> bool {
    ///     n != 0 && (n & (n - 1)) == 0
    /// }
    ///
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (0_usize, 3_usize),
    ///     (1_usize, 5_usize),
    ///     (2_usize, 7_usize),
    ///     (3_usize, 11_usize),
    ///     (4_usize, 13_usize),
    ///     (5_usize, 17_usize),
    ///     (6_usize, 19_usize),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<usize>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert_eq!(opaque_map.partition_point::<_, usize, usize, RandomState, Global>(|&k, &v| is_power_of_two(v)), 0);
    /// ```
    #[must_use]
    #[track_caller]
    pub fn partition_point<P, K, V, S, A>(&self, pred: P) -> usize
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
        P: FnMut(&K, &V) -> bool,
    {
        let proj_self = self.as_proj::<K, V, S, A>();

        proj_self.partition_point(pred)
    }

    /// Reverses the storage order of the index map's entries in place.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (0_usize, "foo"),
    ///     (1_usize, "bar"),
    ///     (2_usize, "baz"),
    ///     (3_usize, "quux"),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<&str>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let expected = [
    ///     (3_usize, "quux"),
    ///     (2_usize, "baz"),
    ///     (1_usize, "bar"),
    ///     (0_usize, "foo"),
    /// ];
    /// opaque_map.reverse::<usize, &str, RandomState, Global>();
    ///
    /// assert_eq!(opaque_map.as_slice::<usize, &str, RandomState, Global>(), expected.as_slice());
    /// ```
    #[track_caller]
    pub fn reverse<K, V, S, A>(&mut self)
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.reverse()
    }

    /// Attempts to reserve capacity for **at least** `additional` more elements to be inserted
    /// in the given index map.
    ///
    /// The collection may reserve more space to speculatively avoid frequent reallocations.
    /// After calling this method, the capacity will be greater than or equal to
    /// `self.len() + additional` if it returns. This method does nothing if the collection
    /// capacity is already sufficient. This method preserves the contents even if a panic occurs.
    ///
    /// # Panics
    ///
    /// This method panics if one of the following conditions occurs:
    ///
    /// * If the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    ///   `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    ///   allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    ///   type `S`, and allocator type `A`, respectively.
    /// * If the capacity of the index map overflows.
    /// * If the allocator reports a failure.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    ///     (4_usize, 5_i32),
    ///     (5_usize, 6_i32),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<i32>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// opaque_map.reserve::<usize, i32, RandomState, Global>(10);
    ///
    /// assert!(opaque_map.capacity() >= opaque_map.len() + 10);
    ///
    /// let old_capacity = opaque_map.capacity();
    /// opaque_map.extend::<_, usize, i32, RandomState, Global>([(6_usize, 7_i32), (7_usize, 8_i32), (8_usize, 9_i32), (9_usize, 10_i32)]);
    ///
    /// assert_eq!(opaque_map.capacity(), old_capacity);
    /// ```
    #[track_caller]
    pub fn reserve<K, V, S, A>(&mut self, additional: usize)
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.reserve(additional)
    }

    /// Attempts to reserve capacity for **at least** `additional` more elements to be inserted
    /// in the given index map.
    ///
    /// Unlike [`reserve`], this will not deliberately over-allocate to speculatively avoid
    /// frequent allocations. After calling `reserve_exact`, the capacity of `self` will be greater
    /// than or equal to `self.len() + additional`. This method does nothing if the capacity is
    /// already sufficient.
    ///
    /// [`reserve`]: OpaqueIndexMap::reserve
    ///
    /// # Panics
    ///
    /// This method panics if one of the following conditions occurs:
    ///
    /// * If the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    ///   `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    ///   allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    ///   type `S`, and allocator type `A`, respectively.
    /// * If the capacity of the index map overflows.
    /// * If the allocator reports a failure.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    ///     (4_usize, 5_i32),
    ///     (5_usize, 6_i32),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<i32>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// opaque_map.reserve_exact::<usize, i32, RandomState, Global>(10);
    ///
    /// assert!(opaque_map.capacity() >= opaque_map.len() + 10);
    ///
    /// let old_capacity = opaque_map.capacity();
    /// opaque_map.extend::<_, usize, i32, RandomState, Global>([(6_usize, 7_i32), (7_usize, 8_i32), (8_usize, 9_i32), (9_usize, 10_i32)]);
    ///
    /// assert_eq!(opaque_map.capacity(), old_capacity);
    /// ```
    #[track_caller]
    pub fn reserve_exact<K, V, S, A>(&mut self, additional: usize)
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.reserve_exact(additional)
    }

    /// Attempts to reserve capacity for **at least** `additional` more elements to be inserted
    /// in the given index map.
    ///
    /// The collection may reserve more space to speculatively avoid frequent reallocations.
    /// After calling this method, the capacity will be greater than or equal to
    /// `self.len() + additional` if it returns `Ok(())`. This method does nothing if the collection
    /// capacity is already sufficient. This method preserves the contents even if an error occurs.
    ///
    /// # Errors
    ///
    /// This method returns an error if the capacity overflows, or the allocator reports a failure.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    ///     (4_usize, 5_i32),
    ///     (5_usize, 6_i32),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<i32>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let result = opaque_map.try_reserve::<usize, i32, RandomState, Global>(10);
    ///
    /// assert!(result.is_ok());
    /// assert!(opaque_map.capacity() >= opaque_map.len() + 10);
    ///
    /// let old_capacity = opaque_map.capacity();
    /// opaque_map.extend::<_, usize, i32, RandomState, Global>([(6_usize, 7_i32), (7_usize, 8_i32), (8_usize, 9_i32), (9_usize, 10_i32)]);
    ///
    /// assert_eq!(opaque_map.capacity(), old_capacity);
    /// ```
    #[track_caller]
    pub fn try_reserve<K, V, S, A>(&mut self, additional: usize) -> Result<(), TryReserveError>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.try_reserve(additional)
    }

    /// Attempts to reserve capacity for **at least** `additional` more elements to be inserted
    /// in the given index map.
    ///
    /// Unlike [`try_reserve`], this will not deliberately over-allocate to speculatively avoid
    /// frequent allocations. After calling `reserve_exact`, the capacity of `self` will be greater
    /// than or equal to `self.len() + additional`. This method does nothing if the capacity is
    /// already sufficient.
    ///
    /// [`try_reserve`]: OpaqueIndexMap::try_reserve
    ///
    /// # Errors
    ///
    /// This method returns an error if the capacity overflows, or the allocator reports a failure.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    ///     (4_usize, 5_i32),
    ///     (5_usize, 6_i32),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<i32>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let result = opaque_map.try_reserve_exact::<usize, i32, RandomState, Global>(10);
    ///
    /// assert!(result.is_ok());
    /// assert!(opaque_map.capacity() >= opaque_map.len() + 10);
    ///
    /// let old_capacity = opaque_map.capacity();
    /// opaque_map.extend::<_, usize, i32, RandomState, Global>([(6_usize, 7_i32), (7_usize, 8_i32), (8_usize, 9_i32), (9_usize, 10_i32)]);
    ///
    /// assert_eq!(opaque_map.capacity(), old_capacity);
    /// ```
    #[track_caller]
    pub fn try_reserve_exact<K, V, S, A>(&mut self, additional: usize) -> Result<(), TryReserveError>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.try_reserve_exact(additional)
    }

    /// Shrinks the capacity of the index map as much as possible.
    ///
    /// The behavior of this method depends on the allocator, which may either shrink the
    /// index map in place or reallocate. The resulting index map might still have some excess
    /// capacity, just as is the case for [`with_capacity`]. See [`Allocator::shrink`] for more
    /// details.
    ///
    /// [`with_capacity`]: OpaqueIndexMap::with_capacity
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::with_capacity::<usize, i32>(10);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<i32>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// opaque_map.extend::<_, usize, i32, RandomState, Global>([(0_usize, 1_i32), (1_usize, 2_i32), (2_usize, 3_i32)]);
    ///
    /// assert!(opaque_map.capacity() >= 10);
    ///
    /// opaque_map.shrink_to_fit::<usize, i32, RandomState, Global>();
    ///
    /// assert!(opaque_map.capacity() >= 3);
    /// ```
    #[track_caller]
    pub fn shrink_to_fit<K, V, S, A>(&mut self)
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.shrink_to_fit()
    }

    /// Shrinks the capacity of the index map to a lower bound.
    ///
    /// The behavior of this method depends on the allocator, which may either shrink the
    /// index map in place or reallocate. The resulting index map might still have some excess
    /// capacity, just as is the case for [`with_capacity`]. See [`Allocator::shrink`] for more
    /// details.
    ///
    /// The capacity will remain at least as large as both the length
    /// and the supplied capacity `min_capacity`. In particular, after calling this method,
    /// the capacity of `self` satisfies
    ///
    /// ```text
    /// self.capacity() >= max(self.len(), min_capacity).
    /// ```
    ///
    /// If the current capacity of the index map is less than the lower bound, the method does
    /// nothing.
    ///
    /// [`with_capacity`]: OpaqueIndexMap::with_capacity
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::with_capacity::<usize, i32>(10);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<i32>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// opaque_map.extend::<_, usize, i32, RandomState, Global>([(0_usize, 1_i32), (1_usize, 2_i32), (2_usize, 3_i32)]);
    ///
    /// assert!(opaque_map.capacity() >= 10);
    ///
    /// opaque_map.shrink_to::<usize, i32, RandomState, Global>(4);
    ///
    /// assert!(opaque_map.capacity() >= 4);
    ///
    /// opaque_map.shrink_to::<usize, i32, RandomState, Global>(0);
    ///
    /// assert!(opaque_map.capacity() >= 3);
    /// ```
    #[track_caller]
    pub fn shrink_to<K, V, S, A>(&mut self, min_capacity: usize)
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.shrink_to(min_capacity)
    }
}

#[cfg(feature = "nightly")]
impl OpaqueIndexMap {
    /// Converts an index map into a [`Box<[T]>`][owned slice].
    ///
    /// Before doing the conversion, this method discards excess capacity like [`shrink_to_fit`].
    ///
    /// [owned slice]: Box
    /// [`shrink_to_fit`]: OpaqueIndexMap::shrink_to_fit
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::map::{Slice, OpaqueIndexMap};
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::with_capacity::<usize, i32>(10);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<i32>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// opaque_map.extend::<_, usize, i32, RandomState, Global>([(0_usize, 1_i32), (1_usize, 2_i32), (2_usize, 3_i32)]);
    ///
    /// assert_eq!(opaque_map.len(), 3);
    /// assert_eq!(opaque_map.capacity(), 10);
    /// assert_eq!(opaque_map.as_slice::<usize, i32, RandomState, Global>(), &[(0_usize, 1_i32), (1_usize, 2_i32), (2_usize, 3_i32)]);
    ///
    /// let boxed_slice: Box<Slice<usize, i32>, TypedProjAlloc<Global>> = opaque_map.into_boxed_slice::<usize, i32, RandomState, Global>();
    ///
    /// assert_eq!(boxed_slice.len(), 3);
    /// assert_eq!(boxed_slice.as_ref(), &[(0_usize, 1_i32), (1_usize, 2_i32), (2_usize, 3_i32)]);
    /// ```
    #[track_caller]
    pub fn into_boxed_slice<K, V, S, A>(self) -> Box<Slice<K, V>, TypedProjAlloc<A>>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.into_proj::<K, V, S, A>();

        proj_self.into_boxed_slice()
    }
}

impl OpaqueIndexMap {
    /// Returns a (key reference, value reference) pair corresponding to the key-value pair stored
    /// at a given storage index in the index map, if it exists.
    ///
    /// If `index < self.len()`, this method returns `Some((&key, &value))`, where `key` is the key
    /// of the entry at index `index` in the map, and `value` is the value of the entry at index
    /// `index`. If `index >= self.len()`, this method returns `None`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with keys of type `K` and values of type `V`.
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { index < map.len() }
    /// map.get_index(index)
    /// { result = Some(map[index]) }
    ///
    /// { index >= map.len() }
    /// map.get_index(index)
    /// { result = None }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 10_i32),
    ///     (2_usize, 40_i32),
    ///     (3_usize, 30_i32),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<i32>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert_eq!(opaque_map.get_index::<usize, i32, RandomState, Global>(0), Some((&1_usize, &10_i32)));
    /// assert_eq!(opaque_map.get_index::<usize, i32, RandomState, Global>(1), Some((&2_usize, &40_i32)));
    /// assert_eq!(opaque_map.get_index::<usize, i32, RandomState, Global>(2), Some((&3_usize, &30_i32)));
    /// assert_eq!(opaque_map.get_index::<usize, i32, RandomState, Global>(3), None);
    /// ```
    #[track_caller]
    pub fn get_index<K, V, S, A>(&self, index: usize) -> Option<(&K, &V)>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj::<K, V, S, A>();

        proj_self.get_index(index)
    }

    /// Returns a (key reference, mutable value reference) pair corresponding to the key-value pair
    /// stored at a given storage index in the index map, if it exists.
    ///
    /// If `index < self.len()`, this method returns `Some((&key, &mut value))`, where `key` is the
    /// key of the entry at index `index` in the map, and `value` is the value of the entry at
    /// index `index`. If `index >= self.len()`, this method returns `None`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with keys of type `K` and values of type `V`.
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { index < map.len() }
    /// map.get_index_mut(index)
    /// { result = Some(map[index]) }
    ///
    /// { index >= map.len() }
    /// map.get_index_mut(index)
    /// { result = None }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 10_i32),
    ///     (2_usize, 40_i32),
    ///     (3_usize, 30_i32),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<i32>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert_eq!(opaque_map.get_index_mut::<usize, i32, RandomState, Global>(0), Some((&1_usize, &mut 10_i32)));
    /// assert_eq!(opaque_map.get_index_mut::<usize, i32, RandomState, Global>(1), Some((&2_usize, &mut 40_i32)));
    /// assert_eq!(opaque_map.get_index_mut::<usize, i32, RandomState, Global>(2), Some((&3_usize, &mut 30_i32)));
    /// assert_eq!(opaque_map.get_index_mut::<usize, i32, RandomState, Global>(3), None);
    /// ```
    #[track_caller]
    pub fn get_index_mut<K, V, S, A>(&mut self, index: usize) -> Option<(&K, &mut V)>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.get_index_mut(index)
    }

    /// Returns the entry in the index map with the given storage index, if it exists.
    ///
    /// If `index < self.len()`, this method returns `Some(entry)`, where `entry` is the entry
    /// storage at the index `index` in the index map. If `index >= self.len()`, this method
    /// returns `None`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 10_i32),
    ///     (2_usize, 40_i32),
    ///     (3_usize, 30_i32),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<i32>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    ///
    /// assert!(opaque_map.get_index_entry::<usize, i32, RandomState, Global>(0).is_some());
    /// assert!(opaque_map.get_index_entry::<usize, i32, RandomState, Global>(1).is_some());
    /// assert!(opaque_map.get_index_entry::<usize, i32, RandomState, Global>(2).is_some());
    ///
    /// assert_eq!(opaque_map.get_index_entry::<usize, i32, RandomState, Global>(0).unwrap().key(), &1_usize);
    /// assert_eq!(opaque_map.get_index_entry::<usize, i32, RandomState, Global>(0).unwrap().index(), 0);
    /// assert_eq!(opaque_map.get_index_entry::<usize, i32, RandomState, Global>(0).unwrap().get(), &10_i32);
    ///
    /// assert_eq!(opaque_map.get_index_entry::<usize, i32, RandomState, Global>(1).unwrap().key(), &2_usize);
    /// assert_eq!(opaque_map.get_index_entry::<usize, i32, RandomState, Global>(1).unwrap().index(), 1);
    /// assert_eq!(opaque_map.get_index_entry::<usize, i32, RandomState, Global>(1).unwrap().get(), &40_i32);
    ///
    /// assert_eq!(opaque_map.get_index_entry::<usize, i32, RandomState, Global>(2).unwrap().key(), &3_usize);
    /// assert_eq!(opaque_map.get_index_entry::<usize, i32, RandomState, Global>(2).unwrap().index(), 2);
    /// assert_eq!(opaque_map.get_index_entry::<usize, i32, RandomState, Global>(2).unwrap().get(), &30_i32);
    ///
    /// assert!(opaque_map.get_index_entry::<usize, i32, RandomState, Global>(3).is_none());
    /// ```
    #[track_caller]
    pub fn get_index_entry<K, V, S, A>(&mut self, index: usize) -> Option<IndexedEntry<'_, K, V, A>>
    where
        K: any::Any + Ord,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.get_index_entry(index)
    }

    /// Returns multiple references to the values of the entries at multiple storage indices at
    /// once.
    ///
    /// # Panics
    ///
    /// This method panics if there are any duplicate indices.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_isize, 'a'),
    ///     (3_isize, 'b'),
    ///     (2_isize, 'c'),
    ///     (6_isize, 'e'),
    ///     (4_isize, 'f'),
    ///     (5_isize, '@'),
    /// ]);
    ///
    /// let maybe_result = opaque_map.get_disjoint_indices_mut::<3, isize, char, RandomState, Global>([2, 1, 5]);
    ///
    /// assert!(maybe_result.is_ok());
    ///
    /// let result = maybe_result.unwrap();
    ///
    /// assert_eq!(result[0], (&2_isize, &mut 'c'));
    /// assert_eq!(result[1], (&3_isize, &mut 'b'));
    /// assert_eq!(result[2], (&5_isize, &mut '@'));
    /// ```
    #[track_caller]
    pub fn get_disjoint_indices_mut<const N: usize, K, V, S, A>(&mut self, indices: [usize; N]) -> Result<[(&K, &mut V); N], GetDisjointMutError>
    where
        K: any::Any + Ord,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.get_disjoint_indices_mut(indices)
    }

    /// Returns a slice of entries in the index map in the given storage range in the map.
    ///
    /// If the range `range` is in bounds, this method returns `Some(&slice)`, where `slice` is the
    /// slice of entries from the index map in the storage range `range`. if the range `range` is
    /// out of bounds, this method returns `None`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 10_i32),
    ///     (2_usize, 40_i32),
    ///     (3_usize, 30_i32),
    ///     (4_usize, 60_i32),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<i32>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let maybe_slice = opaque_map.get_range::<_, usize, i32, RandomState, Global>(1..);
    ///
    /// assert!(maybe_slice.is_some());
    ///
    /// let slice = maybe_slice.unwrap();
    ///
    /// assert_eq!(slice.len(), 3);
    /// assert_eq!(slice[0], 40_i32);
    /// assert_eq!(slice[1], 30_i32);
    /// assert_eq!(slice[2], 60_i32);
    /// ```
    #[track_caller]
    pub fn get_range<R, K, V, S, A>(&self, range: R) -> Option<&Slice<K, V>>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
        R: ops::RangeBounds<usize>,
    {
        let proj_self = self.as_proj::<K, V, S, A>();

        proj_self.get_range(range)
    }

    /// Returns a mutable slice of entries in the index map in the given storage range in the map.
    ///
    /// If the range `range` is in bounds, this method returns `Some(&mut slice)`, where `slice` is
    /// the slice of entries from the index map in the storage range `range`. if the range `range`
    /// is out of bounds, this method returns `None`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::cmp::Ordering;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (1_usize, 10_i32),
    ///     (2_usize, 40_i32),
    ///     (3_usize, 30_i32),
    ///     (4_usize, 60_i32),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<i32>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let maybe_slice = opaque_map.get_range_mut::<_, usize, i32, RandomState, Global>(1..);
    ///
    /// assert!(maybe_slice.is_some());
    ///
    /// let slice = maybe_slice.unwrap();
    ///
    /// assert_eq!(slice.len(), 3);
    /// assert_eq!(slice[0], 40_i32);
    /// assert_eq!(slice[1], 30_i32);
    /// assert_eq!(slice[2], 60_i32);
    /// ```
    #[track_caller]
    pub fn get_range_mut<R, K, V, S, A>(&mut self, range: R) -> Option<&mut Slice<K, V>>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
        R: ops::RangeBounds<usize>,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.get_range_mut(range)
    }

    /// Returns a reference to the first entry in the index map as a
    /// (key reference, value reference) pair, if it exists.
    ///
    /// If the index map is nonempty, this method returns `Some((&key, &value))` where `key` is the
    /// key of the first entry in the index map, and `value` is the value of the first entry in the
    /// index map. If the index map is empty, this method returns `None`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// Getting the first entry of a non-empty index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (String::from("foo"),  1_usize),
    ///     (String::from("bar"),  2_usize),
    ///     (String::from("baz"),  3_usize),
    ///     (String::from("quux"), 4_usize),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<String>());
    /// # assert!(opaque_map.has_value_type::<usize>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let result = opaque_map.first::<String, usize, RandomState, Global>();
    ///
    /// assert_eq!(result, Some((&String::from("foo"), &1_usize)));
    /// ```
    ///
    /// Getting the first entry from an empty index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::new::<String, usize>();
    /// #
    /// # assert!(opaque_map.has_key_type::<String>());
    /// # assert!(opaque_map.has_value_type::<usize>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let maybe_entry = opaque_map.first::<String, usize, RandomState, Global>();
    ///
    /// assert!(maybe_entry.is_none());
    /// ```
    #[track_caller]
    #[doc(alias = "first_key_value")]
    pub fn first<K, V, S, A>(&self) -> Option<(&K, &V)>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj::<K, V, S, A>();

        proj_self.first()
    }

    /// Returns a reference to the first entry in the index map as a
    /// (key reference, mutable value reference) pair, if it exists.
    ///
    /// If the index map is nonempty, this method returns `Some((&key, &mut value))` where `key` is
    /// the key of the first entry in the index map, and `value` is the value of the first entry in
    /// the index map. If the index map is empty, this method returns `None`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// Getting the first entry of a non-empty index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (String::from("foo"),  1_usize),
    ///     (String::from("bar"),  2_usize),
    ///     (String::from("baz"),  3_usize),
    ///     (String::from("quux"), 4_usize),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<String>());
    /// # assert!(opaque_map.has_value_type::<usize>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let result = opaque_map.first_mut::<String, usize, RandomState, Global>();
    ///
    /// assert_eq!(result, Some((&String::from("foo"), &mut 1_usize)));
    /// ```
    ///
    /// Getting the first entry from an empty index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::new::<String, usize>();
    /// #
    /// # assert!(opaque_map.has_key_type::<String>());
    /// # assert!(opaque_map.has_value_type::<usize>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let maybe_entry = opaque_map.first_mut::<String, usize, RandomState, Global>();
    ///
    /// assert!(maybe_entry.is_none());
    /// ```
    #[track_caller]
    pub fn first_mut<K, V, S, A>(&mut self) -> Option<(&K, &mut V)>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.first_mut()
    }

    /// Returns the first entry in the index map, if it exists.
    ///
    /// If the index map is nonempty, this method returns `Some(entry)` where `entry` is the first
    /// entry in the index map. If the index map is empty, this method returns `None`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// Getting the first entry of a non-empty index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (String::from("foo"),  1_usize),
    ///     (String::from("bar"),  2_usize),
    ///     (String::from("baz"),  3_usize),
    ///     (String::from("quux"), 4_usize),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<String>());
    /// # assert!(opaque_map.has_value_type::<usize>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let maybe_entry = opaque_map.first_entry::<String, usize, RandomState, Global>();
    ///
    /// assert!(maybe_entry.is_some());
    ///
    /// let entry = maybe_entry.unwrap();
    ///
    /// assert_eq!(entry.key(), "foo");
    /// assert_eq!(entry.index(), 0);
    /// assert_eq!(entry.get(), &1_usize);
    /// ```
    ///
    /// Getting the first entry from an empty index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::new::<String, usize>();
    /// #
    /// # assert!(opaque_map.has_key_type::<String>());
    /// # assert!(opaque_map.has_value_type::<usize>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let entry = opaque_map.first_entry::<String, usize, RandomState, Global>();
    ///
    /// assert!(entry.is_none());
    /// ```
    #[track_caller]
    pub fn first_entry<K, V, S, A>(&mut self) -> Option<IndexedEntry<'_, K, V, A>>
    where
        K: any::Any + Ord,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.first_entry()
    }

    /// Returns a reference to the last entry in the index map as a (key reference, value reference)
    /// pair, if it exists.
    ///
    /// If the index map is nonempty, this method returns `Some((&key, &value))` where `key` is the
    /// key of the last entry in the index map, and `value` is the value of the last entry in the
    /// index map. If the index map is empty, this method returns `None`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// Getting the last entry of a non-empty index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (String::from("foo"),  1_usize),
    ///     (String::from("bar"),  2_usize),
    ///     (String::from("baz"),  3_usize),
    ///     (String::from("quux"), 4_usize),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<String>());
    /// # assert!(opaque_map.has_value_type::<usize>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let result = opaque_map.last::<String, usize, RandomState, Global>();
    ///
    /// assert_eq!(result, Some((&String::from("quux"), &4_usize)));
    /// ```
    ///
    /// Getting the last entry from an empty index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::new::<String, usize>();
    /// #
    /// # assert!(opaque_map.has_key_type::<String>());
    /// # assert!(opaque_map.has_value_type::<usize>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let maybe_entry = opaque_map.last::<String, usize, RandomState, Global>();
    ///
    /// assert!(maybe_entry.is_none());
    /// ```
    #[track_caller]
    #[doc(alias = "last_key_value")]
    pub fn last<K, V, S, A>(&self) -> Option<(&K, &V)>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj::<K, V, S, A>();

        proj_self.last()
    }

    /// Returns a reference to the last entry in the index map as a
    /// (key reference, mutable value reference) pair, if it exists.
    ///
    /// If the index map is nonempty, this method returns `Some((&key, &mut value))` where `key` is
    /// the key of the last entry in the index map, and `value` is the value of the last entry in
    /// the index map. If the index map is empty, this method returns `None`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// Getting the last entry of a non-empty index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (String::from("foo"),  1_usize),
    ///     (String::from("bar"),  2_usize),
    ///     (String::from("baz"),  3_usize),
    ///     (String::from("quux"), 4_usize),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<String>());
    /// # assert!(opaque_map.has_value_type::<usize>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let result = opaque_map.last_mut::<String, usize, RandomState, Global>();
    ///
    /// assert_eq!(result, Some((&String::from("quux"), &mut 4_usize)));
    /// ```
    ///
    /// Getting the last entry from an empty index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::new::<String, usize>();
    /// #
    /// # assert!(opaque_map.has_key_type::<String>());
    /// # assert!(opaque_map.has_value_type::<usize>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let maybe_entry = opaque_map.last_mut::<String, usize, RandomState, Global>();
    ///
    /// assert!(maybe_entry.is_none());
    /// ```
    #[track_caller]
    pub fn last_mut<K, V, S, A>(&mut self) -> Option<(&K, &mut V)>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.last_mut()
    }

    /// Returns the last entry in the index map, if it exists.
    ///
    /// If the index map is nonempty, this method returns `Some(entry)` where `entry` is the last
    /// entry in the index map. If the index map is empty, this method returns `None`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// Getting the last entry of a non-empty index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (String::from("foo"),  1_usize),
    ///     (String::from("bar"),  2_usize),
    ///     (String::from("baz"),  3_usize),
    ///     (String::from("quux"), 4_usize),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<String>());
    /// # assert!(opaque_map.has_value_type::<usize>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let maybe_entry = opaque_map.last_entry::<String, usize, RandomState, Global>();
    ///
    /// assert!(maybe_entry.is_some());
    ///
    /// let entry = maybe_entry.unwrap();
    ///
    /// assert_eq!(entry.key(), "quux");
    /// assert_eq!(entry.index(), 3);
    /// assert_eq!(entry.get(), &4_usize);
    /// ```
    ///
    /// Getting the last entry from an empty index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::new::<String, usize>();
    /// #
    /// # assert!(opaque_map.has_key_type::<String>());
    /// # assert!(opaque_map.has_value_type::<usize>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let entry = opaque_map.last_entry::<String, usize, RandomState, Global>();
    ///
    /// assert!(entry.is_none());
    /// ```
    #[track_caller]
    pub fn last_entry<K, V, S, A>(&mut self) -> Option<IndexedEntry<'_, K, V, A>>
    where
        K: any::Any + Ord,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.last_entry()
    }

    /// Swap removes an entry from the index map by storage index.
    ///
    /// This method behaves as follows:
    ///
    /// * If `index < self.len() - 1`, this method removes the entry at storage index `index`, and
    ///   swaps the last entry in `self` into the slot at `index`. This method removes and returns
    ///   `Some((key, value))`, where `key` is the key, and `value` is the value from the removed
    ///   entry.
    /// * If `index == self.len() - 1`, this method remove the entry at storage index `index`, and
    ///   returns `Some((key, value))`, where `key` is the key, and `value` is the value from the
    ///   removed entry.
    /// * If `index >= self.len()`, the index `index` is out of bounds, so the method returns
    ///   `None`.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Specification Definitions
    ///
    /// The **last entry** in the map `map` when `map` is non-empty is defined by
    ///
    /// ```text
    /// last(map) := map[map.len() - 1].
    /// ```
    ///
    /// We say that two maps `map1` and `map2` are **equal** if and only if
    ///
    /// ```text
    /// map1 = map2 ⇔ (map1.len() = map2.len()) ∧ (∀ i ∈ [0, map1.len()). map1[i] = map2[i]).
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { index < map_before.len() - 1 }
    /// map.swap_remove_index(index)
    /// {
    ///     result = Some(map_before[index])
    ///     ∧ map_after.len() = map_before.len() - 1
    ///     ∧ (∀ i ∈ [0, index). map_after[i] = map_before[i])
    ///     ∧ map_after[index] = last(map_before))
    ///     ∧ (∀ i ∈ [index + 1, map_after.len()). map_after[i] = map_before[i])
    /// }
    ///
    /// { index = map_before.len() - 1 }
    /// map.swap_remove_index(index)
    /// {
    ///     result = Some(map_before[index])
    ///     ∧ map_after.len() = map_before.len() - 1
    ///     ∧ (∀ i ∈ [0, map_after.len()). map_after[i] = map_before[i])
    /// }
    ///
    /// { index ≥ map_before.len() }
    /// map.swap_remove_index(index)
    /// { result = None ∧ map_after = map_before }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (0_usize, ()),
    ///     (1_usize, ()),
    ///     (2_usize, ()),
    ///     (3_usize, ()),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<()>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let removed = opaque_map.swap_remove_index::<usize, (), RandomState, Global>(1);
    /// let expected = [(0_usize, ()), (3_usize, ()), (2_usize, ())];
    ///
    /// assert_eq!(removed, Some((1_usize, ())));
    /// assert_eq!(opaque_map.as_slice::<usize, (), RandomState, Global>(), expected.as_slice());
    /// ```
    #[track_caller]
    pub fn swap_remove_index<K, V, S, A>(&mut self, index: usize) -> Option<(K, V)>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.swap_remove_index(index)
    }

    /// Shift removes an entry from the index map by storage index.
    ///
    /// This method behaves as follows:
    ///
    /// * If `index < self.len() - 1`, this method removes the entry at storage index `index`, and
    ///   shifts each entry in `(index, self.len() - 1)` down one unit. This method removes and
    ///   returns `Some((key, value))`, where `key` is the key, and `value` is the value from the
    ///   removed entry.
    /// * If `index == self.len() - 1`, this method remove the entry at storage index `index`, and
    ///   returns `Some((key, value))`, where `key` is the key, and `value` is the value from the
    ///   removed entry.
    /// * If `index >= self.len()`, the index `index` is out of bounds, so the method returns
    ///   `None`.
    ///
    /// Note that when `self.len() == 1`, `self` is empty, so no shifting occurs.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Specification Definitions
    ///
    /// We say that two maps `map1` and `map2` are **equal** if and only if
    ///
    /// ```text
    /// map1 = map2 ⇔ (map1.len() = map2.len()) ∧ (∀ i ∈ [0, map1.len()). map1[i] = map2[i]).
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { index < map_before.len() - 1 }
    /// map.shift_remove_index(index)
    /// {
    ///     result = Some(map_before[index])
    ///     ∧ map_after.len() = map_before.len() - 1
    ///     ∧ (∀ i ∈ [0, index). map_after[i] = map_before[i])
    ///     ∧ (∀ i ∈ [index, map_after.len()). map_after[i] = map_before[i + 1])
    /// }
    ///
    /// { index = map_before.len() - 1 }
    /// map.shift_remove_index(index)
    /// {
    ///     result = Some(map_before[index])
    ///     ∧ map_after.len() = map_before.len() - 1
    ///     ∧ (∀ i ∈ [0, map_after.len()). map_after[i] = map_before[i])
    /// }
    ///
    /// { index ≥ map_before.len() }
    /// map.shift_remove_index(index)
    /// { result = None ∧ map_after = map_before }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     (0_usize, ()),
    ///     (1_usize, ()),
    ///     (2_usize, ()),
    ///     (3_usize, ()),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<()>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let removed = opaque_map.shift_remove_index::<usize, (), RandomState, Global>(1);
    /// let expected = [(0_usize, ()), (2_usize, ()), (3_usize, ())];
    ///
    /// assert_eq!(removed, Some((1_usize, ())));
    /// assert_eq!(opaque_map.as_slice::<usize, (), RandomState, Global>(), expected.as_slice());
    /// ```
    #[track_caller]
    pub fn shift_remove_index<K, V, S, A>(&mut self, index: usize) -> Option<(K, V)>
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.shift_remove_index(index)
    }

    /// Moves the storage position of an entry from one index to another by shifting all other
    /// pairs in between.
    ///
    /// This method behaves as follows:
    ///
    /// * If `from < to`, the other pairs will shift up while the targeted pair moves down.
    /// * If `from > to`, the other pairs will shift down while the targeted pair moves up.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Specification Definitions
    ///
    /// We say that two maps `map1` and `map2` are **equal** if and only if
    ///
    /// ```text
    /// map1 = map2 ⇔ (map1.len() = map2.len()) ∧ (∀ i ∈ [0, map1.len()). map1[i] = map2[i]).
    /// ```
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { from < map_before.len() ∧ to < map_before.len() ∧ from < to }
    /// map.move_index(from, to)
    /// {
    ///     map_after.len() = map_before.len()
    ///     ∧ map_after[to] = map_before[from]
    ///     ∧ (∀ i ∈ [0, from). map_after[i] = map_before[i])
    ///     ∧ (∀ i ∈ [from, to). map_after[i] = map_before[i + 1])
    ///     ∧ (∀ i ∈ [to + 1, map_after.len()). map_after[i] = map_before[i])
    /// }
    ///
    /// { from < map_before.len() ∧ to < map_before.len() ∧ from > to }
    /// map.move_index(from, to)
    /// {
    ///     map_after.len() = map_before.len()
    ///     ∧ map_after[to] = map_before[from]
    ///     ∧ (∀ i ∈ [0, to). map_after[i] = map_before[i])
    ///     ∧ (∀ i ∈ [to, from). map_after[i + 1] = map_before[i])
    ///     ∧ (∀ i ∈ [from + 1, map_after.len()). map_after[i] = map_before[i])
    /// }
    ///
    /// { from < map_before.len() ∧ to < map_before.len() ∧ from = to }
    /// map.move_index(from, to)
    /// { map_after = map_before }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if one of the following conditions occurs:
    ///
    /// * If the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    ///   `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    ///   allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    ///   type `S`, and allocator type `A`, respectively.
    /// * If `from` or `to` are out of bounds.
    ///
    /// # Examples
    ///
    /// Moving an index where `from < to`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     ("foo",    0_usize),
    ///     ("bar",    1_usize),
    ///     ("baz",    2_usize),
    ///     ("quux",   3_usize),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<&str>());
    /// # assert!(opaque_map.has_value_type::<usize>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// opaque_map.move_index::<&str, usize, RandomState, Global>(0, 3);
    /// let expected = [("bar", 1_usize), ("baz", 2_usize), ("quux", 3_usize), ("foo", 0_usize)];
    ///
    /// assert_eq!(opaque_map.as_slice::<&str, usize, RandomState, Global>(), expected.as_slice());
    /// ```
    ///
    /// Moving an index where `from > to`.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     ("foo",    0_usize),
    ///     ("bar",    1_usize),
    ///     ("baz",    2_usize),
    ///     ("quux",   3_usize),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<&str>());
    /// # assert!(opaque_map.has_value_type::<usize>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// opaque_map.move_index::<&str, usize, RandomState, Global>(3, 0);
    /// let expected = [("quux", 3_usize), ("foo", 0_usize), ("bar", 1_usize), ("baz", 2_usize)];
    ///
    /// assert_eq!(opaque_map.as_slice::<&str, usize, RandomState, Global>(), expected.as_slice());
    /// ```
    #[track_caller]
    pub fn move_index<K, V, S, A>(&mut self, from: usize, to: usize)
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.move_index(from, to)
    }

    /// Swaps the position of two entries in the index map.
    ///
    /// # Formal Properties (Optional Section)
    ///
    /// ***Note: This section is optional for most users and contains advanced material.
    /// It explains the precise axiomatic (formal, logic-based) semantics of these operations for
    /// those seeking a thorough understanding.***
    ///
    /// Let `map` be an index map with key type `K` and value type `V`. Let `map_before` be the
    /// state of `map` before this method is called, `map_after` be the state of `map` after this
    /// method completes.
    ///
    /// ## Method Specification
    ///
    /// This method satisfies:
    ///
    /// ```text
    /// { a < map_before.len() ∧ b < map_before.len() }
    /// map.swap_indices(a, b)
    /// {
    ///     map_after.len() = map_before.len()
    ///     ∧ map_after[a] = map_before[b]
    ///     ∧ map_after[b] = map_before[a]
    ///     ∧ (∀ i ∈ [0, map_after.len()). i ∉ {a, b} ⇒ map_after[i] = map_before[i])
    /// }
    /// ```
    ///
    /// where `{P} S {Q}` is the Hoare triple indicating how this method acts on `map`.
    ///
    /// # Panics
    ///
    /// This method panics if one of the following conditions occurs:
    ///
    /// * If the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    ///   `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    ///   allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    ///   type `S`, and allocator type `A`, respectively.
    /// * If either `a` is out of bounds, or `b` is out of bounds.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let mut opaque_map = OpaqueIndexMap::from([
    ///     ("foo",    0_usize),
    ///     ("bar",    1_usize),
    ///     ("baz",    2_usize),
    ///     ("quux",   3_usize),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<&str>());
    /// # assert!(opaque_map.has_value_type::<usize>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// opaque_map.swap_indices::<&str, usize, RandomState, Global>(0, 3);
    /// let expected = [("quux", 3_usize), ("bar", 1_usize), ("baz", 2_usize), ("foo", 0_usize)];
    ///
    /// assert_eq!(opaque_map.as_slice::<&str, usize, RandomState, Global>(), expected.as_slice());
    /// ```
    #[track_caller]
    pub fn swap_indices<K, V, S, A>(&mut self, a: usize, b: usize)
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.swap_indices(a, b)
    }
}

impl OpaqueIndexMap {
    /// Clones a type-erased index map.
    ///
    /// This method acts identically to an implementation of the [`Clone`] trait on a
    /// type-projected index map [`TypedProjIndexMap`], or a generic [`HashMap`].
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// Cloning an empty type-erased index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::new::<i32, f32>();
    /// #
    /// # assert!(opaque_map.has_key_type::<i32>());
    /// # assert!(opaque_map.has_value_type::<f32>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// assert!(opaque_map.is_empty());
    ///
    /// let cloned_opaque_map = opaque_map.clone::<i32, f32, RandomState, Global>();
    /// #
    /// # assert!(cloned_opaque_map.has_key_type::<i32>());
    /// # assert!(cloned_opaque_map.has_value_type::<f32>());
    /// # assert!(cloned_opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(cloned_opaque_map.has_allocator_type::<Global>());
    /// #
    /// assert!(cloned_opaque_map.is_empty());
    ///
    /// let expected = cloned_opaque_map.as_slice::<i32, f32, RandomState, Global>();
    /// let result = opaque_map.as_slice::<i32, f32, RandomState, Global>();
    ///
    /// assert_eq!(result, expected);
    /// ```
    ///
    /// Cloning a non-empty type-erased index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let array: [(i32, f32); 6] = [
    ///     (1_i32, 2_f32),
    ///     (2_i32, 3_f32),
    ///     (3_i32, 4_f32),
    ///     (4_i32, 5_f32),
    ///     (5_i32, 6_f32),
    ///     (6_i32, 7_f32),
    /// ];
    /// let opaque_map = OpaqueIndexMap::from(array);
    /// #
    /// # assert!(opaque_map.has_key_type::<i32>());
    /// # assert!(opaque_map.has_value_type::<f32>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// assert!(!opaque_map.is_empty());
    ///
    /// let cloned_opaque_map = opaque_map.clone::<i32, f32, RandomState, Global>();
    /// #
    /// # assert!(cloned_opaque_map.has_key_type::<i32>());
    /// # assert!(cloned_opaque_map.has_value_type::<f32>());
    /// # assert!(cloned_opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(cloned_opaque_map.has_allocator_type::<Global>());
    /// #
    /// assert!(!cloned_opaque_map.is_empty());
    ///
    /// assert_eq!(opaque_map.len(), cloned_opaque_map.len());
    ///
    /// let expected = cloned_opaque_map.as_slice::<i32, f32, RandomState, Global>();
    /// let result = opaque_map.as_slice::<i32, f32, RandomState, Global>();
    ///
    /// assert_eq!(result, expected);
    /// ```
    #[inline]
    #[track_caller]
    pub fn clone<K, V, S, A>(&self) -> Self
    where
        K: any::Any + Clone,
        V: any::Any + Clone,
        S: any::Any + hash::BuildHasher + Send + Sync + Clone,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync + Clone,
    {
        let proj_self = self.as_proj::<K, V, S, A>();
        let proj_cloned_self = Clone::clone(proj_self);
        let cloned_self = OpaqueIndexMap::from_proj(proj_cloned_self);

        cloned_self
    }
}

impl OpaqueIndexMap {
    /// Extends a type-erased index map.
    ///
    /// This method acts identically to an implementation of the [`Extend`] trait on a
    /// type-projected index map [`TypedProjIndexMap`], or a generic [`HashMap`].
    ///
    /// If the key of any entry from the iterable has an equivalent key in `self`, the value of
    /// the entry with the key `key` will be updated to the value from the iterator.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// Extending a type-erased index map without overlapping keys.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let array: [(usize, i32); 6] = [
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    ///     (4_usize, 5_i32),
    ///     (5_usize, 6_i32),
    /// ];
    /// let extension: [(usize, i32); 4] = [
    ///     (6_usize, 7_i32),
    ///     (7_usize, 8_i32),
    ///     (8_usize, 9_i32),
    ///     (9_usize, 10_i32),
    /// ];
    /// let combined: [(usize, i32); 10] = [
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    ///     (4_usize, 5_i32),
    ///     (5_usize, 6_i32),
    ///     (6_usize, 7_i32),
    ///     (7_usize, 8_i32),
    ///     (8_usize, 9_i32),
    ///     (9_usize, 10_i32),
    /// ];
    /// let expected = OpaqueIndexMap::from(combined);
    /// #
    /// # assert!(expected.has_key_type::<usize>());
    /// # assert!(expected.has_value_type::<i32>());
    /// # assert!(expected.has_build_hasher_type::<RandomState>());
    /// # assert!(expected.has_allocator_type::<Global>());
    /// #
    /// let mut result = OpaqueIndexMap::from(array);
    /// #
    /// # assert!(result.has_key_type::<usize>());
    /// # assert!(result.has_value_type::<i32>());
    /// # assert!(result.has_build_hasher_type::<RandomState>());
    /// # assert!(result.has_allocator_type::<Global>());
    /// #
    /// result.extend::<_, usize, i32, RandomState, Global>(extension.iter().cloned());
    ///
    /// assert_eq!(result.len(), expected.len());
    /// assert_eq!(result.as_slice::<usize, i32, RandomState, Global>(), expected.as_slice::<usize, i32, RandomState, Global>());
    /// ```
    #[inline]
    #[track_caller]
    pub fn extend<I, K, V, S, A>(&mut self, iterable: I)
    where
        K: any::Any + hash::Hash + Eq,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
        I: IntoIterator<Item = (K, V)>,
    {
        let proj_self = self.as_proj_mut::<K, V, S, A>();

        proj_self.extend(iterable)
    }
}

impl OpaqueIndexMap {
    /// Returns a moving iterator for the type-erased index map.
    ///
    /// # Panics
    ///
    /// This method panics if the [`TypeId`] of the keys of `self`, the [`TypeId`] of the values of
    /// `self`, the [`TypeId`] for the hash builder of `self`, and the [`TypeId`] of the memory
    /// allocator of `self` do not match the requested key type `K`, value type `V`, hash builder
    /// type `S`, and allocator type `A`, respectively.
    ///
    /// # Examples
    ///
    /// Iterating over a type-erased index map.
    ///
    /// ```
    /// # #![cfg_attr(feature = "nightly", feature(allocator_api))]
    /// # use opaque_index_map::OpaqueIndexMap;
    /// # use opaque_hash::TypedProjBuildHasher;
    /// # use opaque_alloc::TypedProjAlloc;
    /// # use opaque_vec::TypedProjVec;
    /// # use std::any::TypeId;
    /// # use std::hash::RandomState;
    /// #
    /// # #[cfg(feature = "nightly")]
    /// # use std::alloc::Global;
    /// #
    /// # #[cfg(not(feature = "nightly"))]
    /// # use opaque_allocator_api::alloc::Global;
    /// #
    /// let opaque_map = OpaqueIndexMap::from([
    ///     (0_usize, 1_i32),
    ///     (1_usize, 2_i32),
    ///     (2_usize, 3_i32),
    ///     (3_usize, 4_i32),
    ///     (4_usize, 5_i32),
    ///     (5_usize, 6_i32),
    /// ]);
    /// #
    /// # assert!(opaque_map.has_key_type::<usize>());
    /// # assert!(opaque_map.has_value_type::<i32>());
    /// # assert!(opaque_map.has_build_hasher_type::<RandomState>());
    /// # assert!(opaque_map.has_allocator_type::<Global>());
    /// #
    /// let mut iterator = opaque_map.into_iter::<usize, i32, RandomState, Global>();
    ///
    /// assert_eq!(iterator.next(), Some((0_usize, 1_i32)));
    /// assert_eq!(iterator.next(), Some((1_usize, 2_i32)));
    /// assert_eq!(iterator.next(), Some((2_usize, 3_i32)));
    /// assert_eq!(iterator.next(), Some((3_usize, 4_i32)));
    /// assert_eq!(iterator.next(), Some((4_usize, 5_i32)));
    /// assert_eq!(iterator.next(), Some((5_usize, 6_i32)));
    /// assert_eq!(iterator.next(), None);
    ///
    /// for _ in 0..100 {
    ///     assert_eq!(iterator.next(), None);
    /// }
    /// ```
    #[inline]
    #[track_caller]
    pub fn into_iter<K, V, S, A>(self) -> IntoIter<K, V, A>
    where
        K: any::Any + hash::Hash + Eq,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let proj_self = self.into_proj::<K, V, S, A>();

        proj_self.into_iter()
    }
}

impl fmt::Debug for OpaqueIndexMap {
    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
        formatter
            .debug_struct("OpaqueIndexMap")
            .finish()
    }
}

#[cfg(feature = "std")]
impl<K, V> FromIterator<(K, V)> for OpaqueIndexMap
where
    K: any::Any + hash::Hash + Eq,
    V: any::Any,
{
    fn from_iter<I>(iterable: I) -> Self
    where
        I: IntoIterator<Item = (K, V)>
    {
        let proj_map = TypedProjIndexMap::<K, V, hash::RandomState, alloc::Global>::from_iter(iterable);

        Self::from_proj(proj_map)
    }
}

#[cfg(feature = "std")]
impl<K, V, const N: usize> From<[(K, V); N]> for OpaqueIndexMap
where
    K: any::Any + hash::Hash + Eq,
    V: any::Any,
{
    fn from(array: [(K, V); N]) -> Self {
        let proj_map = TypedProjIndexMap::<K, V, hash::RandomState, alloc::Global>::from_iter(array);

        Self::from_proj(proj_map)
    }
}

mod dummy {
    use super::*;
    use core::ptr::NonNull;
    use core::marker;

    #[allow(dead_code)]
    pub(super) struct DummyHasher {
        _do_not_construct: marker::PhantomData<()>,
    }

    impl hash::Hasher for DummyHasher {
        #[inline]
        fn finish(&self) -> u64 {
            panic!("[`DummyHasher::finish`] should never actually be called. Its purpose is to test struct layouts.");
        }

        #[inline]
        fn write(&mut self, _bytes: &[u8]) {
            panic!("[`DummyHasher::write`] should never actually be called. Its purpose is to test struct layouts.");
        }
    }

    #[allow(dead_code)]
    pub(super) struct DummyBuildHasher {
        _do_not_construct: marker::PhantomData<()>,
    }

    impl hash::BuildHasher for DummyBuildHasher {
        type Hasher = DummyHasher;
        fn build_hasher(&self) -> Self::Hasher {
            panic!("[`DummyBuildHasher::build_hasher`] should never actually be called. Its purpose is to test struct layouts.");
        }
    }

    #[allow(dead_code)]
    pub(super) struct DummyAlloc {
        _do_not_construct: marker::PhantomData<()>,
    }

    unsafe impl alloc::Allocator for DummyAlloc {
        fn allocate(&self, _layout: alloc::Layout) -> Result<NonNull<[u8]>, alloc::AllocError> {
            panic!("[`DummyAlloc::allocate`] should never actually be called. Its purpose is to test struct layouts.");
        }

        unsafe fn deallocate(&self, _ptr: NonNull<u8>, _layout: alloc::Layout) {
            panic!("[`DummyAlloc::deallocate`] should never actually be called. Its purpose is to test struct layouts.");
        }
    }
}

mod layout_testing_types {
    use super::*;
    use core::marker;

    #[allow(dead_code)]
    pub(super) struct TangentSpace {
        tangent: [f32; 3],
        bitangent: [f32; 3],
        normal: [f32; 3],
        _do_not_construct: marker::PhantomData<()>,
    }

    #[allow(dead_code)]
    pub(super) struct SurfaceDifferential {
        dpdu: [f32; 3],
        dpdv: [f32; 3],
        _do_not_construct: marker::PhantomData<()>,
    }

    #[allow(dead_code)]
    pub(super) struct OctTreeNode {
        center: [f32; 3],
        extent: f32,
        children: [Option<Box<OctTreeNode>>; 8],
        occupancy: u8,
        _do_not_construct: marker::PhantomData<()>,
    }
}

#[cfg(test)]
mod index_map_layout_tests {
    use super::*;
    use core::mem;

    fn run_test_opaque_index_map_match_sizes<K, V, S, A>()
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let expected = mem::size_of::<TypedProjIndexMap<K, V, S, A>>();
        let result = mem::size_of::<OpaqueIndexMap>();

        assert_eq!(result, expected, "Opaque and Typed Projected data types size mismatch");
    }

    fn run_test_opaque_index_map_match_alignments<K, V, S, A>()
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let expected = mem::align_of::<TypedProjIndexMap<K, V, S, A>>();
        let result = mem::align_of::<OpaqueIndexMap>();

        assert_eq!(result, expected, "Opaque and Typed Projected data types alignment mismatch");
    }

    fn run_test_opaque_index_map_match_offsets<K, V, S, A>()
    where
        K: any::Any,
        V: any::Any,
        S: any::Any + hash::BuildHasher + Send + Sync,
        S::Hasher: any::Any + hash::Hasher + Send + Sync,
        A: any::Any + alloc::Allocator + Send + Sync,
    {
        let expected = mem::offset_of!(TypedProjIndexMap<K, V, S, A>, inner);
        let result = mem::offset_of!(OpaqueIndexMap, inner);

        assert_eq!(result, expected, "Opaque and Typed Projected data types offsets mismatch");
    }

    macro_rules! layout_tests {
        ($module_name:ident, $key_typ:ty, $value_typ:ty, $build_hasher_typ:ty, $alloc_typ:ty) => {
            mod $module_name {
                use super::*;

                #[test]
                fn test_opaque_index_map_layout_match_sizes() {
                    run_test_opaque_index_map_match_sizes::<$key_typ, $value_typ, $build_hasher_typ, $alloc_typ>();
                }

                #[test]
                fn test_opaque_index_map_layout_match_alignments() {
                    run_test_opaque_index_map_match_alignments::<$key_typ, $value_typ, $build_hasher_typ, $alloc_typ>();
                }

                #[test]
                fn test_opaque_index_map_layout_match_offsets() {
                    run_test_opaque_index_map_match_offsets::<$key_typ, $value_typ, $build_hasher_typ, $alloc_typ>();
                }
            }
        };
    }

    #[cfg(feature = "std")]
    layout_tests!(unit_zst_unit_zstrandom_state_global, (), (), hash::RandomState, alloc::Global);

    #[cfg(feature = "std")]
    layout_tests!(unit_zst_u8random_state_global, (), u8, hash::RandomState, alloc::Global);

    #[cfg(feature = "std")]
    layout_tests!(unit_zst_u64random_state_global, (), u64, hash::RandomState, alloc::Global);

    #[cfg(feature = "std")]
    layout_tests!(unit_zst_strrandom_state_global, (), &'static str, hash::RandomState, alloc::Global);

    #[cfg(feature = "std")]
    layout_tests!(unit_zst_tangent_spacerandom_state_global, (), layout_testing_types::TangentSpace, hash::RandomState, alloc::Global);

    #[cfg(feature = "std")]
    layout_tests!(unit_zst_surface_differentialrandom_state_global, (), layout_testing_types::SurfaceDifferential, hash::RandomState, alloc::Global);

    #[cfg(feature = "std")]
    layout_tests!(unit_zst_oct_tree_noderandom_state_global, (), layout_testing_types::OctTreeNode, hash::RandomState, alloc::Global);

    #[cfg(feature = "std")]
    layout_tests!(u8_unit_zstrandom_state_global, u8, (), hash::RandomState, alloc::Global);

    #[cfg(feature = "std")]
    layout_tests!(u8_u8random_state_global, u8, u8, hash::RandomState, alloc::Global);

    #[cfg(feature = "std")]
    layout_tests!(u8_u64random_state_global, u8, u64, hash::RandomState, alloc::Global);

    #[cfg(feature = "std")]
    layout_tests!(u8_strrandom_state_global, u8, &'static str, hash::RandomState, alloc::Global);

    #[cfg(feature = "std")]
    layout_tests!(u8_tangent_spacerandom_state_global, u8, layout_testing_types::TangentSpace, hash::RandomState, alloc::Global);

    #[cfg(feature = "std")]
    layout_tests!(u8_surface_differentialrandom_state_global, u8, layout_testing_types::SurfaceDifferential, hash::RandomState, alloc::Global);

    #[cfg(feature = "std")]
    layout_tests!(u8_oct_tree_noderandom_state_global, u8, layout_testing_types::OctTreeNode, hash::RandomState, alloc::Global);

    #[cfg(feature = "std")]
    layout_tests!(u64_unit_zstrandom_state_global, u64, (), hash::RandomState, alloc::Global);

    #[cfg(feature = "std")]
    layout_tests!(u64_u8random_state_global, u64, u8, hash::RandomState, alloc::Global);

    #[cfg(feature = "std")]
    layout_tests!(u64_u64random_state_global, u64, u64, hash::RandomState, alloc::Global);

    #[cfg(feature = "std")]
    layout_tests!(u64_strrandom_state_global, u64, &'static str, hash::RandomState, alloc::Global);

    #[cfg(feature = "std")]
    layout_tests!(u64_tangent_spacerandom_state_global, u64, layout_testing_types::TangentSpace, hash::RandomState, alloc::Global);

    #[cfg(feature = "std")]
    layout_tests!(u64_surface_differentialrandom_state_global, u64, layout_testing_types::SurfaceDifferential, hash::RandomState, alloc::Global);

    #[cfg(feature = "std")]
    layout_tests!(u64_oct_tree_noderandom_state_global, u64, layout_testing_types::OctTreeNode, hash::RandomState, alloc::Global);

    layout_tests!(unit_zst_unit_zst_dummy_hasher_dummy_alloc, (), (), dummy::DummyBuildHasher, dummy::DummyAlloc);
    layout_tests!(unit_zst_u8_dummy_hasher_dummy_alloc, (), u8, dummy::DummyBuildHasher, dummy::DummyAlloc);
    layout_tests!(unit_zst_u64_dummy_hasher_dummy_alloc, (), u64, dummy::DummyBuildHasher, dummy::DummyAlloc);
    layout_tests!(unit_zst_str_dummy_hasher_dummy_alloc, (), &'static str, dummy::DummyBuildHasher, dummy::DummyAlloc);
    layout_tests!(unit_zst_tangent_space_dummy_hasher_dummy_alloc, (), layout_testing_types::TangentSpace, dummy::DummyBuildHasher, dummy::DummyAlloc);
    layout_tests!(unit_zst_surface_differential_dummy_hasher_dummy_alloc, (), layout_testing_types::SurfaceDifferential, dummy::DummyBuildHasher, dummy::DummyAlloc);
    layout_tests!(unit_zst_oct_tree_node_dummy_hasher_dummy_alloc, (), layout_testing_types::OctTreeNode, dummy::DummyBuildHasher, dummy::DummyAlloc);

    layout_tests!(u8_unit_zst_dummy_hasher_dummy_alloc, u8, (), dummy::DummyBuildHasher, dummy::DummyAlloc);
    layout_tests!(u8_u8_dummy_hasher_dummy_alloc, u8, u8, dummy::DummyBuildHasher, dummy::DummyAlloc);
    layout_tests!(u8_u64_dummy_hasher_dummy_alloc, u8, u64, dummy::DummyBuildHasher, dummy::DummyAlloc);
    layout_tests!(u8_str_dummy_hasher_dummy_alloc, u8, &'static str, dummy::DummyBuildHasher, dummy::DummyAlloc);
    layout_tests!(u8_tangent_space_dummy_hasher_dummy_alloc, u8, layout_testing_types::TangentSpace, dummy::DummyBuildHasher, dummy::DummyAlloc);
    layout_tests!(u8_surface_differential_dummy_hasher_dummy_alloc, u8, layout_testing_types::SurfaceDifferential, dummy::DummyBuildHasher, dummy::DummyAlloc);
    layout_tests!(u8_oct_tree_node_dummy_hasher_dummy_alloc, u8, layout_testing_types::OctTreeNode, dummy::DummyBuildHasher, dummy::DummyAlloc);

    layout_tests!(u64_unit_zst_dummy_hasher_dummy_alloc, u64, (), dummy::DummyBuildHasher, dummy::DummyAlloc);
    layout_tests!(u64_u8_dummy_hasher_dummy_alloc, u64, u8, dummy::DummyBuildHasher, dummy::DummyAlloc);
    layout_tests!(u64_u64_dummy_hasher_dummy_alloc, u64, u64, dummy::DummyBuildHasher, dummy::DummyAlloc);
    layout_tests!(u64_str_dummy_hasher_dummy_alloc, u64, &'static str, dummy::DummyBuildHasher, dummy::DummyAlloc);
    layout_tests!(u64_tangent_space_dummy_hasher_dummy_alloc, u64, layout_testing_types::TangentSpace, dummy::DummyBuildHasher, dummy::DummyAlloc);
    layout_tests!(u64_surface_differential_dummy_hasher_dummy_alloc, u64, layout_testing_types::SurfaceDifferential, dummy::DummyBuildHasher, dummy::DummyAlloc);
    layout_tests!(u64_oct_tree_node_dummy_hasher_dummy_alloc, u64, layout_testing_types::OctTreeNode, dummy::DummyBuildHasher, dummy::DummyAlloc);
}

#[cfg(test)]
mod index_map_assert_send_sync {
    use super::*;

    #[cfg(feature = "std")]
    #[test]
    fn test_assert_send_sync1() {
        fn assert_send_sync<T: Send + Sync>() {}

        assert_send_sync::<TypedProjIndexMap<i32, i32, hash::RandomState, alloc::Global>>();
    }

    #[test]
    fn test_assert_send_sync2() {
        fn assert_send_sync<T: Send + Sync>() {}

        assert_send_sync::<TypedProjIndexMap<i32, i32, dummy::DummyBuildHasher, alloc::Global>>();
    }
}
